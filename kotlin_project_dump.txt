
================================================================================
ðŸ“„ FICHIER : src\main\kotlin\AppConfig.kt
================================================================================

package dev.deadzone

object AppConfig {
    lateinit var gameHost: String
    var gamePort: Int = 7777

    fun initialize(host: String, port: Int) {
        gameHost = host
        gamePort = port
    }
}



================================================================================
ðŸ“„ FICHIER : src\main\kotlin\Application.kt
================================================================================

package dev.deadzone

import api.routes.apiRoutes
import api.routes.authRoutes
import api.routes.broadcastRoutes
import api.routes.caseInsensitiveStaticResources
import api.routes.fileRoutes
import server.broadcast.BroadcastService
import server.PolicyFileServer
import server.PolicyFileServerConfig
import context.PlayerContextTracker
import context.ServerConfig
import context.ServerContext
import core.data.GameDefinition
import core.metadata.model.ByteArrayAsBase64Serializer
import core.model.game.data.Building
import core.model.game.data.BuildingLike
import core.model.game.data.JunkBuilding
import data.db.BigDBMariaImpl
import dev.deadzone.socket.core.BroadcastServer
import dev.deadzone.socket.core.BroadcastServerConfig
import server.ServerContainer
import utils.Emoji
import io.ktor.http.*
import io.ktor.serialization.kotlinx.json.*
import io.ktor.serialization.kotlinx.protobuf.*
import io.ktor.server.application.*
import io.ktor.server.netty.*
import io.ktor.server.plugins.calllogging.*
import io.ktor.server.plugins.contentnegotiation.*
import io.ktor.server.plugins.cors.routing.*
import io.ktor.server.plugins.statuspages.*
import io.ktor.server.response.*
import io.ktor.server.routing.*
import io.ktor.server.websocket.*
import kotlinx.coroutines.runBlocking
import kotlinx.serialization.ExperimentalSerializationApi
import kotlinx.serialization.json.Json
import kotlinx.serialization.modules.SerializersModule
import kotlinx.serialization.modules.polymorphic
import kotlinx.serialization.protobuf.ProtoBuf
import org.jetbrains.exposed.sql.Database
import server.core.OnlinePlayerRegistry
import server.GameServer
import server.GameServerConfig
import server.handler.save.arena.ArenaSaveHandler
import server.handler.save.bounty.BountySaveHandler
import server.handler.save.chat.ChatSaveHandler
import server.handler.save.command.CommandSaveHandler
import server.handler.save.compound.building.BuildingSaveHandler
import server.handler.save.compound.misc.CmpMiscSaveHandler
import server.handler.save.compound.task.TaskSaveHandler
import server.handler.save.crate.CrateSaveHandler
import server.handler.save.item.ItemSaveHandler
import server.handler.save.misc.MiscSaveHandler
import server.handler.save.mission.MissionSaveHandler
import server.handler.save.purchase.PurchaseSaveHandler
import server.handler.save.quest.QuestSaveHandler
import server.handler.save.raid.RaidSaveHandler
import server.handler.save.survivor.SurvivorSaveHandler
import server.tasks.ServerTaskDispatcher
import user.PlayerAccountRepositoryMaria
import user.auth.SessionManager
import user.auth.WebsiteAuthProvider
import utils.JSON
import utils.Logger
import java.io.File
import kotlin.time.Duration.Companion.seconds

fun main(args: Array<String>) = EngineMain.main(args)

@Suppress("unused")
fun Application.module() {
    install(WebSockets) {
        pingPeriod = 15.seconds
        timeout = 15.seconds
        masking = true
    }

    Logger.setLevel(level = environment.config.propertyOrNull("logger.level")?.getString() ?: "0")
    Logger.enableColorfulLog(
        useColor = environment.config.propertyOrNull("logger.colorful")?.getString()?.toBooleanStrictOrNull() ?: true
    )
    Logger.info("${Emoji.Rocket} Starting DeadZone server")

    val module = SerializersModule {
        polymorphic(BuildingLike::class) {
            subclass(Building::class, Building.serializer())
            subclass(JunkBuilding::class, JunkBuilding.serializer())
            contextual(ByteArray::class, ByteArrayAsBase64Serializer)
        }
    }
    val json = Json {
        serializersModule = module
        classDiscriminator = "_t"
        prettyPrint = true
        isLenient = true
        ignoreUnknownKeys = true
        encodeDefaults = true
    }
    @OptIn(ExperimentalSerializationApi::class)
    install(ContentNegotiation) {
        json(json)
        protobuf(ProtoBuf)
    }

    JSON.initialize(json)
    GameDefinition.initialize()

    AppConfig.initialize(
        host = environment.config.propertyOrNull("game.host")?.getString() ?: "127.0.0.1",
        port = environment.config.propertyOrNull("game.port")?.getString()?.toIntOrNull() ?: 7777
    )

    val config = ServerConfig(
        adminEnabled = environment.config.propertyOrNull("game.enableAdmin")?.getString()?.toBooleanStrictOrNull()
            ?: false,
        useMaria = true,
        mariaUrl = environment.config.propertyOrNull("maria.url")?.getString()
            ?: "jdbc:mariadb://localhost:3306/deadzone",
        mariaUser = environment.config.propertyOrNull("maria.user")?.getString() ?: "root",
        mariaPassword = environment.config.propertyOrNull("maria.password")?.getString() ?: "",
        isProd = !developmentMode,
        gameHost = environment.config.propertyOrNull("game.host")?.getString() ?: "127.0.0.1",
        gamePort = environment.config.propertyOrNull("game.port")?.getString()?.toIntOrNull() ?: 7777,
        broadcastEnabled = environment.config.propertyOrNull("broadcast.enabled")?.getString()?.toBooleanStrictOrNull()
            ?: true,
        broadcastHost = environment.config.propertyOrNull("broadcast.host")?.getString() ?: "0.0.0.0",
        broadcastPorts = environment.config.propertyOrNull("broadcast.ports")?.getString()?.split(",")
            ?.mapNotNull { it.trim().toIntOrNull() }
            ?: listOf(2121, 2122, 2123),
        broadcastPolicyServerEnabled = environment.config.propertyOrNull("broadcast.enablePolicyServer")?.getString()
            ?.toBooleanStrictOrNull()
            ?: true,
        policyHost = environment.config.propertyOrNull("policy.host")?.getString() ?: "0.0.0.0",
        policyPort = environment.config.propertyOrNull("policy.port")?.getString()?.toIntOrNull() ?: 843,
    )
    Logger.info("${Emoji.Database} Connecting to MariaDB...")
    val database = try {
        val mariaDb = Database.connect(
            url = config.mariaUrl,
            driver = "org.mariadb.jdbc.Driver",
            user = config.mariaUser,
            password = config.mariaPassword
        )
        Logger.info("${Emoji.Green} MariaDB connected")
        BigDBMariaImpl(mariaDb, config.adminEnabled)
    } catch (e: Exception) {
        Logger.error("${Emoji.Red} MariaDB connection failed: ${e.message}")
        throw e
    }
    val sessionManager = SessionManager()
    val playerAccountRepository = PlayerAccountRepositoryMaria(database.database, json)
    val onlinePlayerRegistry = OnlinePlayerRegistry()
    val authProvider = WebsiteAuthProvider(database, playerAccountRepository, sessionManager)
    val taskDispatcher = ServerTaskDispatcher()
    val playerContextTracker = PlayerContextTracker()
    val saveHandlers = listOf(
        ArenaSaveHandler(), BountySaveHandler(), ChatSaveHandler(), CommandSaveHandler(),
        BuildingSaveHandler(), CmpMiscSaveHandler(), TaskSaveHandler(), CrateSaveHandler(),
        ItemSaveHandler(), MiscSaveHandler(), MissionSaveHandler(), PurchaseSaveHandler(),
        QuestSaveHandler(), RaidSaveHandler(), SurvivorSaveHandler()
    )
    val serverContext = ServerContext(
        db = database,
        playerAccountRepository = playerAccountRepository,
        sessionManager = sessionManager,
        onlinePlayerRegistry = onlinePlayerRegistry,
        authProvider = authProvider,
        taskDispatcher = taskDispatcher,
        playerContextTracker = playerContextTracker,
        saveHandlers = saveHandlers,
        config = config,
    )
    install(CORS) {
        anyHost()
        allowHeader(HttpHeaders.ContentType)
        allowHeaders { true }
        allowMethod(HttpMethod.Get)
        allowMethod(HttpMethod.Post)
        allowMethod(HttpMethod.Put)
        allowMethod(HttpMethod.Delete)
        allowMethod(HttpMethod.Options)
    }
    install(StatusPages) {
        exception<Throwable> { call, cause ->
            Logger.error("Server error: ${cause.message}")
            call.respondText(text = "500: ${cause.message}", status = HttpStatusCode.InternalServerError)
        }
    }
    install(CallLogging)
    routing {
        fileRoutes()
        caseInsensitiveStaticResources("/game/data", File("static"))
        authRoutes(serverContext)
        apiRoutes(serverContext)
        broadcastRoutes(serverContext)
    }

    var broadcastServer: BroadcastServer? = null

    val servers = buildList {
        add(GameServer(GameServerConfig(host = config.gameHost, port = config.gamePort)))

        if (config.broadcastEnabled) {
            broadcastServer = BroadcastServer(
                BroadcastServerConfig(
                    host = config.broadcastHost,
                    ports = config.broadcastPorts
                )
            ).also { add(it) }
        }

        if (config.broadcastPolicyServerEnabled) {
            add(
                PolicyFileServer(
                    PolicyFileServerConfig(
                        host = config.policyHost,
                        port = config.policyPort,
                        allowedPorts = config.broadcastPorts
                    )
                )
            )
        }
    }

    val container = ServerContainer(servers, serverContext)
    runBlocking {
        container.initializeAll()
        container.startAll()
    }
    broadcastServer?.let { BroadcastService.initialize(it) }

    Logger.info("${Emoji.Party} Server started successfully")
    Logger.info("${Emoji.Satellite} Socket server listening on ${config.gameHost}:${config.gamePort}")
    Logger.info("${Emoji.Internet} API server available at ${config.gameHost}:${environment.config.property("ktor.deployment.port").getString()}")

    Runtime.getRuntime().addShutdownHook(Thread {
        runBlocking {
            container.shutdownAll()
        }
        Logger.info("${Emoji.Red} Server shutdown complete")
    })
}


================================================================================
ðŸ“„ FICHIER : src\main\kotlin\api\handler\Authenticate.kt
================================================================================

package api.handler

import api.message.auth.AuthenticateArgs
import api.message.auth.AuthenticateOutput
import api.utils.pioFraming
import context.ServerContext
import core.data.AdminData
import dev.deadzone.AppConfig
import utils.Logger
import utils.logInput
import utils.logOutput
import io.ktor.http.*
import io.ktor.server.request.*
import io.ktor.server.response.*
import io.ktor.server.routing.*
import io.ktor.utils.io.*
import kotlinx.serialization.ExperimentalSerializationApi
import kotlinx.serialization.decodeFromByteArray
import kotlinx.serialization.encodeToByteArray
import kotlinx.serialization.protobuf.ProtoBuf

@OptIn(ExperimentalSerializationApi::class)
suspend fun RoutingContext.authenticate(serverContext: ServerContext) {
    val body = try {
        call.receiveChannel().toByteArray()
    } catch (e: Exception) {
        Logger.error { "authenticate: failed to read request body: ${e.message}" }
        call.respond(HttpStatusCode.BadRequest, "invalid_body")
        return
    }

    val authenticateArgs = try {
        ProtoBuf.decodeFromByteArray<AuthenticateArgs>(body)
    } catch (e: Exception) {
        Logger.error { "authenticate: failed to decode args: ${e.message}" }
        call.respond(HttpStatusCode.BadRequest, "invalid_payload")
        return
    }

    logInput(authenticateArgs, disableLogging = true)

    val userToken = authenticateArgs
        .authenticationArguments
        .find { it.key == "userToken" }?.value

    if (userToken.isNullOrBlank()) {
        Logger.error { "Client-error: missing userToken in API 13 request" }
        call.respond(HttpStatusCode.BadRequest, "userToken is missing")
        return
    }

    val authenticateOutput = if (userToken == AdminData.TOKEN) {
        AuthenticateOutput.admin()
    } else {
        val isValid = try {
            serverContext.sessionManager.verify(userToken)
        } catch (e: Exception) {
            Logger.error { "authenticate: session verification failed: ${e.message}" }
            false
        }

        if (!isValid) {
            call.respond(HttpStatusCode.Unauthorized, "token is invalid, try re-login")
            return
        }

        val playerId = try {
            serverContext.sessionManager.getPlayerId(userToken)
        } catch (e: Exception) {
            Logger.error { "authenticate: failed to get playerId from session: ${e.message}" }
            null
        }

        if (playerId.isNullOrBlank()) {
            call.respond(HttpStatusCode.InternalServerError, "failed to resolve player")
            return
        }

        AuthenticateOutput(
            token = userToken,
            userId = playerId,
            apiServerHosts = listOf(AppConfig.gameHost)
        )
    }

    val encodedOutput = try {
        ProtoBuf.encodeToByteArray(authenticateOutput)
    } catch (e: Exception) {
        Logger.error { "authenticate: failed to encode output: ${e.message}" }
        call.respond(HttpStatusCode.InternalServerError, "encode_error")
        return
    }

    logOutput(encodedOutput, disableLogging = true)

    call.respondBytes(encodedOutput.pioFraming())
}



================================================================================
ðŸ“„ FICHIER : src\main\kotlin\api\handler\CreateJoinRoom.kt
================================================================================

package api.handler

import api.message.server.CreateJoinRoomArgs
import api.message.server.CreateJoinRoomOutput
import api.utils.pioFraming
import io.ktor.http.HttpStatusCode
import utils.logInput
import utils.logOutput
import io.ktor.server.request.*
import io.ktor.server.response.*
import io.ktor.server.routing.*
import io.ktor.utils.io.*
import kotlinx.serialization.ExperimentalSerializationApi
import kotlinx.serialization.decodeFromByteArray
import kotlinx.serialization.encodeToByteArray
import kotlinx.serialization.protobuf.ProtoBuf

@OptIn(ExperimentalSerializationApi::class)
suspend fun RoutingContext.createJoinRoom() {
    val body = try {
        call.receiveChannel().toByteArray()
    } catch (e: Exception) {
        call.respond(HttpStatusCode.BadRequest, "invalid_body")
        return
    }

    val args = try {
        ProtoBuf.decodeFromByteArray<CreateJoinRoomArgs>(body)
    } catch (e: Exception) {
        call.respond(HttpStatusCode.BadRequest, "invalid_payload")
        return
    }

    logInput(args, disableLogging = true)

    val output = CreateJoinRoomOutput.defaultRoom()
    val outputBytes = try {
        ProtoBuf.encodeToByteArray(output)
    } catch (e: Exception) {
        call.respond(HttpStatusCode.InternalServerError, "encode_error")
        return
    }

    logOutput(outputBytes, disableLogging = true)

    call.respondBytes(outputBytes.pioFraming())
}



================================================================================
ðŸ“„ FICHIER : src\main\kotlin\api\handler\LoadIndexRange.kt
================================================================================

package api.handler

import api.message.db.LoadIndexRangeArgs
import api.message.db.LoadObjectsOutput
import api.utils.pioFraming
import utils.logInput
import io.ktor.server.request.receiveChannel
import io.ktor.server.response.respondBytes
import io.ktor.server.routing.RoutingContext
import io.ktor.utils.io.toByteArray
import io.ktor.http.HttpStatusCode
import io.ktor.server.response.respond
import kotlinx.serialization.ExperimentalSerializationApi
import kotlinx.serialization.decodeFromByteArray
import kotlinx.serialization.encodeToByteArray
import kotlinx.serialization.protobuf.ProtoBuf

@OptIn(ExperimentalSerializationApi::class)
suspend fun RoutingContext.loadIndexRange() {
    val body = try {
        call.receiveChannel().toByteArray()
    } catch (e: Exception) {
        call.respond(HttpStatusCode.BadRequest, "invalid_body")
        return
    }

    val args = try {
        ProtoBuf.decodeFromByteArray<LoadIndexRangeArgs>(body)
    } catch (e: Exception) {
        call.respond(HttpStatusCode.BadRequest, "invalid_payload")
        return
    }

    logInput(args, disableLogging = true)

    val outputBytes = try {
        ProtoBuf.encodeToByteArray(
            LoadObjectsOutput(objects = emptyList())
        )
    } catch (e: Exception) {
        call.respond(HttpStatusCode.InternalServerError, "encode_error")
        return
    }

    call.respondBytes(outputBytes.pioFraming())
}



================================================================================
ðŸ“„ FICHIER : src\main\kotlin\api\handler\LoadObjects.kt
================================================================================

package api.handler

import api.message.db.BigDBObject
import api.message.db.LoadObjectsArgs
import api.message.db.LoadObjectsOutput
import api.utils.pioFraming
import context.ServerContext
import context.getPlayerContextOrNull
import data.collection.NeighborHistory
import dev.deadzone.core.LazyDataUpdater
import utils.LogConfigAPIError
import utils.LogConfigSocketToClient
import utils.Logger
import utils.logInput
import utils.logOutput
import io.ktor.http.*
import io.ktor.server.request.*
import io.ktor.server.response.*
import io.ktor.server.routing.*
import io.ktor.utils.io.*
import kotlinx.serialization.ExperimentalSerializationApi
import kotlinx.serialization.decodeFromByteArray
import kotlinx.serialization.encodeToByteArray
import kotlinx.serialization.protobuf.ProtoBuf
import kotlin.math.max

@OptIn(ExperimentalSerializationApi::class)
suspend fun RoutingContext.loadObjects(serverContext: ServerContext) {
    val body = try {
        call.receiveChannel().toByteArray()
    } catch (e: Exception) {
        call.respond(HttpStatusCode.BadRequest, "invalid_body")
        return
    }

    val loadObjectsArgs = try {
        ProtoBuf.decodeFromByteArray<LoadObjectsArgs>(body)
    } catch (e: Exception) {
        call.respond(HttpStatusCode.BadRequest, "invalid_payload")
        return
    }

    logInput(loadObjectsArgs, disableLogging = true)

    val dbObjects = mutableListOf<BigDBObject>()

    for (objId in loadObjectsArgs.objectIds) {
        val playerId = objId.keys.firstOrNull() ?: continue
        if (playerId.endsWith("-2")) continue

        val profile = serverContext.playerAccountRepository.getProfileOfPlayerId(playerId).getOrNull() ?: continue
        val lastLogin = profile.lastLogin

        val playerObjects = serverContext.db.loadPlayerObjects(playerId) ?: continue
        val neighborHistory = serverContext.db.loadNeighborHistory(playerId)
        val inventory = serverContext.db.loadInventory(playerId)

        val obj: BigDBObject? = when (objId.table) {
            "PlayerObjects" -> {
                val updatedBuildings = LazyDataUpdater.removeBuildingTimerIfDone(playerObjects.buildings)
                val updatedResources = LazyDataUpdater.depleteResources(lastLogin, playerObjects.resources)
                val updatedSurvivors = playerObjects.survivors.map { srv -> srv.copy(level = max(srv.level, 1)) }

                val ctx = serverContext.getPlayerContextOrNull(playerId)
                if (ctx != null) {
                    runCatching { ctx.services.compound.updateAllBuildings(updatedBuildings) }
                    runCatching { ctx.services.compound.updateResource { updatedResources } }
                    runCatching { ctx.services.survivor.updateSurvivors(updatedSurvivors) }
                } else {
                    runCatching {
                        val updatedPlayerObjects = playerObjects.copy(
                            buildings = updatedBuildings,
                            resources = updatedResources,
                            survivors = updatedSurvivors
                        )
                        serverContext.db.updatePlayerObjectsJson(playerId, updatedPlayerObjects)
                    }.onFailure {
                        Logger.error(LogConfigSocketToClient) { "Failed to persist updates for $playerId: ${it.message}" }
                    }
                }

                LoadObjectsOutput.fromData(
                    playerObjects.copy(
                        buildings = updatedBuildings,
                        resources = updatedResources,
                        survivors = updatedSurvivors
                    )
                )
            }

            "NeighborHistory" -> neighborHistory?.let {
                LoadObjectsOutput.fromData(NeighborHistory(playerId = playerId, map = it.map))
            }

            "Inventory" -> inventory?.let { LoadObjectsOutput.fromData(it) }

            else -> {
                Logger.error(LogConfigAPIError) { "Unimplemented table for ${objId.table}" }
                null
            }
        }

        if (obj != null) dbObjects.add(obj)
    }

    val encoded = ProtoBuf.encodeToByteArray(LoadObjectsOutput(objects = dbObjects))
    logOutput(encoded, disableLogging = true)
    call.respondBytes(encoded.pioFraming())
}


================================================================================
ðŸ“„ FICHIER : src\main\kotlin\api\handler\SocialRefresh.kt
================================================================================

package api.handler

import api.message.social.SocialProfile
import api.message.social.SocialRefreshOutput
import api.utils.pioFraming
import context.ServerContext
import core.data.AdminData
import utils.LogConfigAPIError
import utils.Logger
import utils.logInput
import utils.logOutput
import io.ktor.http.*
import io.ktor.server.request.*
import io.ktor.server.response.*
import io.ktor.server.routing.*
import io.ktor.utils.io.*
import kotlinx.serialization.ExperimentalSerializationApi
import kotlinx.serialization.encodeToByteArray
import kotlinx.serialization.protobuf.ProtoBuf

@OptIn(ExperimentalSerializationApi::class)
suspend fun RoutingContext.socialRefresh(serverContext: ServerContext, token: String?) {
    if (token.isNullOrBlank()) {
        call.respond(HttpStatusCode.Unauthorized, "missing_token")
        return
    }

    val pid = runCatching { serverContext.sessionManager.getPlayerId(token) }.getOrNull()
    if (pid.isNullOrBlank()) {
        call.respond(HttpStatusCode.Unauthorized, "invalid_token")
        return
    }

    val profile = serverContext.playerAccountRepository.getProfileOfPlayerId(pid).getOrNull()
    if (profile == null) {
        Logger.error(LogConfigAPIError) { "Profile not found for playerId=$pid" }
        call.respond(HttpStatusCode.InternalServerError, "profile_missing")
        return
    }

    val output = if (pid == AdminData.PLAYER_ID) {
        SocialRefreshOutput.admin()
    } else {
        SocialRefreshOutput(
            myProfile = SocialProfile(
                userId = pid,
                displayName = profile.displayName,
                avatarUrl = profile.avatarUrl,
                lastOnline = profile.lastLogin,
                countryCode = profile.countryCode ?: "",
                userToken = token
            ),
            friends = emptyList(),
            blocked = ""
        )
    }

    val encoded = ProtoBuf.encodeToByteArray(output)
    logOutput(encoded, disableLogging = true)
    call.respondBytes(encoded.pioFraming())
}


================================================================================
ðŸ“„ FICHIER : src\main\kotlin\api\handler\WriteError.kt
================================================================================

package api.handler

import api.message.utils.WriteErrorArgs
import api.message.utils.WriteErrorError
import api.utils.pioFraming
import io.ktor.http.HttpStatusCode
import io.ktor.server.request.*
import io.ktor.server.response.*
import io.ktor.server.routing.*
import io.ktor.utils.io.*
import kotlinx.serialization.ExperimentalSerializationApi
import kotlinx.serialization.decodeFromByteArray
import kotlinx.serialization.encodeToByteArray
import kotlinx.serialization.protobuf.ProtoBuf
import utils.LogConfigAssetsError
import utils.LogConfigWriteError
import utils.Logger
import utils.logInput

@OptIn(ExperimentalSerializationApi::class)
suspend fun RoutingContext.writeError() {
    val body = try {
        call.receiveChannel().toByteArray()
    } catch (e: Exception) {
        call.respond(HttpStatusCode.BadRequest, "invalid_body")
        return
    }

    val writeErrorArgs = try {
        ProtoBuf.decodeFromByteArray<WriteErrorArgs>(body)
    } catch (e: Exception) {
        call.respond(HttpStatusCode.BadRequest, "invalid_payload")
        return
    }

    logInput("\n$writeErrorArgs", disableLogging = true)

    Logger.error(LogConfigWriteError) { writeErrorArgs.toString() }

    if (writeErrorArgs.details.contains("Load Never Completed", ignoreCase = true) ||
        writeErrorArgs.details.contains("Resource not found", ignoreCase = true) ||
        writeErrorArgs.details.contains("Resource load fail", ignoreCase = true) ||
        writeErrorArgs.details.contains("2036", ignoreCase = true) ||
        writeErrorArgs.details.contains("Stream error", ignoreCase = true)
    ) {
        Logger.error(LogConfigAssetsError) { writeErrorArgs.details }
    }

    val loadObjectsOutput = try {
        ProtoBuf.encodeToByteArray(WriteErrorError.dummy())
    } catch (e: Exception) {
        call.respond(HttpStatusCode.InternalServerError, "encode_error")
        return
    }

    call.respondBytes(loadObjectsOutput.pioFraming())
}


================================================================================
ðŸ“„ FICHIER : src\main\kotlin\api\message\auth\AuthenticateArgs.kt
================================================================================

package api.message.auth

import api.message.utils.KeyValuePair
import kotlinx.serialization.Serializable

@Serializable
data class AuthenticateArgs(
    val gameId: String = "",
    val connectionId: String = "",
    val authenticationArguments: List<KeyValuePair> = emptyList(),
    val playerInsightSegments: List<String> = emptyList(),
    val clientAPI: String = "",
    val clientInfo: List<KeyValuePair> = emptyList(),
    val playCodes: List<String> = emptyList()
)



================================================================================
ðŸ“„ FICHIER : src\main\kotlin\api\message\auth\AuthenticateOutput.kt
================================================================================

package api.message.auth

import dev.deadzone.AppConfig
import api.message.social.PlayerInsightState
import core.data.AdminData
import kotlinx.serialization.Serializable

@Serializable
data class AuthenticateOutput(
    val token: String = "",
    val userId: String = "",
    val showBranding: Boolean = false,
    val gameFSRedirectMap: String = "",
    val playerInsightState: PlayerInsightState? = null,
    val startDialogs: List<AuthenticateStartDialog> = emptyList(),
    val isSocialNetworkUser: Boolean = false,
    val newPlayCodes: List<String> = emptyList(),
    val notificationClickPayload: String = "",
    val isInstalledByPublishingNetwork: Boolean = false,
    val deprecated1: List<String> = emptyList(),
    val apiSecurity: Int = 0, // ENUM: depends on enum definition
    val apiServerHosts: List<String> = emptyList()
) {
    companion object {
        fun admin(): AuthenticateOutput {
            return AuthenticateOutput(
                token = AdminData.TOKEN,
                userId = AdminData.PLAYER_ID,
                apiServerHosts = listOf(AppConfig.gameHost)
            )
        }
    }
}


================================================================================
ðŸ“„ FICHIER : src\main\kotlin\api\message\auth\AuthenticateStartDialog.kt
================================================================================

package api.message.auth

import api.message.utils.KeyValuePair
import kotlinx.serialization.Serializable

@Serializable
data class AuthenticateStartDialog(
    val name: String = "",
    val arguments: List<KeyValuePair> = emptyList()
)


================================================================================
ðŸ“„ FICHIER : src\main\kotlin\api\message\db\ArrayProperty.kt
================================================================================

package api.message.db

import kotlinx.serialization.Serializable

@Serializable
data class ArrayProperty(
    val index: Int = 0,
    val value: ValueObject = ValueObject()
)


================================================================================
ðŸ“„ FICHIER : src\main\kotlin\api\message\db\BigDBObject.kt
================================================================================

package api.message.db

import kotlinx.serialization.Serializable

@Serializable
data class BigDBObject(
    val key: String = "",
    val version: String = "",
    val properties: List<ObjectProperty> = listOf(),
    val creator: UInt = 0u,
)


================================================================================
ðŸ“„ FICHIER : src\main\kotlin\api\message\db\BigDBObjectId.kt
================================================================================

package api.message.db

import kotlinx.serialization.Serializable

@Serializable
data class BigDBObjectId(
    val table: String = "",
    val keys: List<String> = listOf()
)


================================================================================
ðŸ“„ FICHIER : src\main\kotlin\api\message\db\LoadIndexRangeArgs.kt
================================================================================

package api.message.db

import kotlinx.serialization.Serializable

/**
 * Mirrors PlayerIO BigDB LoadIndexRange args:
 * - table: BigDB table name
 * - index: index name within the table
 * - startIndexValue: inclusive start of index (composite allowed)
 * - stopIndexValue: inclusive stop of index (composite allowed)
 * - limit: maximum number of objects to return
 */
@Serializable
data class LoadIndexRangeArgs(
    val table: String,
    val index: String,
    val startIndexValue: List<ValueObject> = emptyList(),
    val stopIndexValue: List<ValueObject> = emptyList(),
    val limit: Int = 0
)


================================================================================
ðŸ“„ FICHIER : src\main\kotlin\api\message\db\LoadObjectsArgs.kt
================================================================================

package api.message.db

import kotlinx.serialization.Serializable

@Serializable
data class LoadObjectsArgs(
    val objectIds: List<BigDBObjectId> = listOf()
)


================================================================================
ðŸ“„ FICHIER : src\main\kotlin\api\message\db\LoadObjectsOutput.kt
================================================================================

package api.message.db

import api.utils.BigDBConverter
import kotlinx.serialization.Serializable

@Serializable
data class LoadObjectsOutput(
    val objects: List<BigDBObject> = listOf()
) {
    companion object {
        inline fun <reified T : Any> fromData(obj: T): BigDBObject {
            return BigDBConverter.toBigDBObject(obj = obj)
        }
    }
}


================================================================================
ðŸ“„ FICHIER : src\main\kotlin\api\message\db\ObjectProperty.kt
================================================================================

package api.message.db

import kotlinx.serialization.Serializable

@Serializable
data class ObjectProperty(
    val name: String = "",
    val value: ValueObject = ValueObject()
)


================================================================================
ðŸ“„ FICHIER : src\main\kotlin\api\message\db\ValueObject.kt
================================================================================

package api.message.db

import kotlinx.serialization.Serializable

@Serializable
data class ValueObject(
    val valueType: ValueType = ValueType.STRING,
    val string: String = "",
    val int32: Int = 0,
    val uInt: UInt = 0u,
    val long: Long = 0L,
    val bool: Boolean = false,
    val float: Float = 0f,
    val double: Double = 0.0,
    val byteArray: ByteArray = byteArrayOf(),
    val dateTime: Long = 0L,
    val arrayProperties: List<ArrayProperty> = listOf(),
    val objectProperties: List<ObjectProperty> = listOf()
) {
    override fun equals(other: Any?): Boolean {
        if (this === other) return true
        if (javaClass != other?.javaClass) return false

        other as ValueObject

        if (int32 != other.int32) return false
        if (long != other.long) return false
        if (bool != other.bool) return false
        if (float != other.float) return false
        if (double != other.double) return false
        if (dateTime != other.dateTime) return false
        if (valueType != other.valueType) return false
        if (string != other.string) return false
        if (uInt != other.uInt) return false
        if (!byteArray.contentEquals(other.byteArray)) return false
        if (arrayProperties != other.arrayProperties) return false
        if (objectProperties != other.objectProperties) return false

        return true
    }

    override fun hashCode(): Int {
        var result = int32
        result = 31 * result + long.hashCode()
        result = 31 * result + bool.hashCode()
        result = 31 * result + float.hashCode()
        result = 31 * result + double.hashCode()
        result = 31 * result + dateTime.hashCode()
        result = 31 * result + valueType.hashCode()
        result = 31 * result + string.hashCode()
        result = 31 * result + uInt.hashCode()
        result = 31 * result + byteArray.contentHashCode()
        result = 31 * result + arrayProperties.hashCode()
        result = 31 * result + objectProperties.hashCode()
        return result
    }
}


================================================================================
ðŸ“„ FICHIER : src\main\kotlin\api\message\db\ValueType.kt
================================================================================

package api.message.db

import kotlinx.serialization.Serializable

@Serializable
enum class ValueType {
    STRING,
    INT32,
    UINT,
    LONG,
    BOOL,
    FLOAT,
    DOUBLE,
    BYTE_ARRAY,
    DATETIME,
    ARRAY,
    OBJECT
}


================================================================================
ðŸ“„ FICHIER : src\main\kotlin\api\message\server\CreateJoinRoomArgs.kt
================================================================================

package api.message.server

import api.message.utils.KeyValuePair
import kotlinx.serialization.Serializable

@Serializable
data class CreateJoinRoomArgs(
    val roomId: String = "",
    val roomType: String = "",
    val visible: Boolean = false,
    val roomData: KeyValuePair = KeyValuePair(),
    val joinData: KeyValuePair = KeyValuePair(),
    val isDevRoom: Boolean = false,
)



================================================================================
ðŸ“„ FICHIER : src\main\kotlin\api\message\server\CreateJoinRoomOutput.kt
================================================================================

package api.message.server

import kotlinx.serialization.Serializable

@Serializable
data class CreateJoinRoomOutput(
    val roomId: String = "",
    val joinKey: String = "",
    val endpoints: ServerEndpoint,
) {
    companion object {
        fun defaultRoom(): CreateJoinRoomOutput {
            return CreateJoinRoomOutput(
                roomId = "defaultRoomId",
                joinKey = "defaultJoinKey",
                endpoints = ServerEndpoint.socketServer()
            )
        }
    }
}



================================================================================
ðŸ“„ FICHIER : src\main\kotlin\api\message\server\ServerEndpoint.kt
================================================================================

package api.message.server

import dev.deadzone.AppConfig
import kotlinx.serialization.Serializable

@Serializable
data class ServerEndpoint(
    val address: String = "",
    val port: Int = 0,
) {
    companion object {
        fun socketServer(): ServerEndpoint {
            return ServerEndpoint(
                address = AppConfig.gameHost,
                port = AppConfig.gamePort
            )
        }
    }
}


================================================================================
ðŸ“„ FICHIER : src\main\kotlin\api\message\social\PlayerInsightState.kt
================================================================================

package api.message.social

import api.message.utils.KeyValuePair
import kotlinx.serialization.Serializable

@Serializable
data class PlayerInsightState(
    val playersOnline: Int = 0,
    val segments: List<KeyValuePair> = emptyList()
)



================================================================================
ðŸ“„ FICHIER : src\main\kotlin\api\message\social\SocialProfile.kt
================================================================================

package api.message.social

import core.data.AdminData
import io.ktor.util.date.getTimeMillis
import kotlinx.serialization.Serializable

@Serializable
data class SocialProfile(
    val userId: String = "",
    val displayName: String = "",
    val avatarUrl: String = "",
    val lastOnline: Long = 0,
    val countryCode: String = "",
    val userToken: String = "",
) {
    companion object {
        fun admin(): SocialProfile {
            return SocialProfile(
                userId = AdminData.PLAYER_ID,
                displayName = AdminData.DISPLAY_NAME,
                avatarUrl = AdminData.AVATAR_URL,
                lastOnline = getTimeMillis() - (1000L * 2000),
                countryCode = AdminData.COUNTRY_CODE,
                userToken = AdminData.TOKEN,
            )
        }
    }
}



================================================================================
ðŸ“„ FICHIER : src\main\kotlin\api\message\social\SocialRefreshOutput.kt
================================================================================

package api.message.social

import kotlinx.serialization.Serializable

@Serializable
data class SocialRefreshOutput(
    val myProfile: SocialProfile = SocialProfile(),
    val friends: List<SocialProfile> = emptyList(),
    val blocked: String = "",
) {
    companion object {
        fun admin(): SocialRefreshOutput {
            return SocialRefreshOutput(
                myProfile = SocialProfile.admin(),
                friends = listOf(SocialProfile.admin()),
                blocked = "No one"
            )
        }
    }
}



================================================================================
ðŸ“„ FICHIER : src\main\kotlin\api\message\utils\KeyValuePair.kt
================================================================================

package api.message.utils

import kotlinx.serialization.Serializable

@Serializable
data class KeyValuePair(
    val key: String = "",
    val value: String = "",
) {
    companion object {
        fun dummy(): KeyValuePair {
            return KeyValuePair(
                key = "examplekey",
                value = "examplevalue",
            )
        }
    }
}



================================================================================
ðŸ“„ FICHIER : src\main\kotlin\api\message\utils\WriteErrorArgs.kt
================================================================================

package api.message.utils

import kotlinx.serialization.Serializable

@Serializable
data class WriteErrorArgs(
    val source: String = "",
    val error: String = "",
    val details: String = "",
    val stacktrace: String = "",
    val extraData: List<KeyValuePair> = listOf(),
)



================================================================================
ðŸ“„ FICHIER : src\main\kotlin\api\message\utils\WriteErrorError.kt
================================================================================

package api.message.utils

import kotlinx.serialization.Serializable

@Serializable
data class WriteErrorError(
    val errorCode: Int = 0,
    val message: String = "",
) {
    companion object {
        fun dummy(): WriteErrorError {
            return WriteErrorError(
                errorCode = 42,
                message = "Write error, error"
            )
        }
    }
}



================================================================================
ðŸ“„ FICHIER : src\main\kotlin\api\routes\ApiRoutes.kt
================================================================================

package api.routes

import api.handler.*
import context.ServerContext
import utils.LogConfigAPIError
import utils.Logger
import io.ktor.http.HttpStatusCode
import io.ktor.server.response.respond
import io.ktor.server.routing.Route
import io.ktor.server.routing.get
import io.ktor.server.routing.post

fun Route.apiRoutes(serverContext: ServerContext) {
    get("/api/status") {
        call.respond(HttpStatusCode.OK, mapOf("status" to "online"))
    }

    post("/api/{path}") {
        val path = call.parameters["path"] ?: return@post call.respond(HttpStatusCode.BadRequest)

        val playerToken = if (path != "13" && path != "50") {
            call.request.queryParameters["playertoken"]
                ?: call.request.headers["playertoken"]
                ?: return@post call.respond(HttpStatusCode.Unauthorized, "Missing playertoken")
        } else {
            null
        }

        when (path) {
            "13" -> authenticate(serverContext)
            "601" -> socialRefresh(serverContext, playerToken!!)
            "27" -> createJoinRoom()
            "50" -> writeError()
            "85" -> loadObjects(serverContext)
            "97" -> loadIndexRange()
            else -> {
                Logger.error(LogConfigAPIError) { "Unimplemented API route: $path" }
                call.respond(HttpStatusCode.NotFound, "Unimplemented API: $path")
            }
        }
    }
}



================================================================================
ðŸ“„ FICHIER : src\main\kotlin\api\routes\AuthRoutes.kt
================================================================================

package api.routes

import context.ServerContext
import core.data.AdminData
import utils.Logger
import io.ktor.http.*
import io.ktor.server.request.*
import io.ktor.server.response.*
import io.ktor.server.routing.*

fun Route.authRoutes(serverContext: ServerContext) {

    post("/api/login") {
        val data = call.receive<Map<String, String>>()
        val username = data["username"]
        val password = data["password"]

        if (username == null || password == null) {
            call.respond(HttpStatusCode.BadRequest, mapOf("reason" to "Missing credentials"))
            return@post
        }

        if (username == AdminData.ADMIN_RESERVED_NAME) {
            if (serverContext.config.adminEnabled) {
                val session = serverContext.authProvider.adminLogin()
                if (session != null) {
                    call.respond(HttpStatusCode.OK, mapOf("playerId" to session.playerId, "token" to session.token))
                } else {
                    call.respond(
                        HttpStatusCode.InternalServerError,
                        mapOf("reason" to "unexpected error: admin account doesn't exist")
                    )
                }
            } else {
                call.respond(HttpStatusCode.Forbidden, mapOf("reason" to "admin account not enabled"))
            }
            return@post
        }

        val usernameExist = serverContext.authProvider.doesUserExist(username)
        if (usernameExist) {
            val loginSession = serverContext.authProvider.login(username, password)
            val passwordRight = loginSession != null
            if (passwordRight) {
                call.respond(
                    HttpStatusCode.OK,
                    mapOf("playerId" to loginSession.playerId, "token" to loginSession.token)
                )
            } else {
                call.respond(
                    HttpStatusCode.Unauthorized,
                    mapOf("reason" to "wrong password")
                )
            }
        } else {
            val session = serverContext.authProvider.register(username, password)
            call.respond(
                HttpStatusCode.OK,
                mapOf("playerId" to session.playerId, "token" to session.token)
            )
        }
    }

    get("/api/userexist") {
        val username = call.parameters["username"]
        if (username.isNullOrBlank()) {
            call.respondText("no", status = HttpStatusCode.BadRequest)
            return@get
        }

        if (username == AdminData.ADMIN_RESERVED_NAME) {
            if (serverContext.config.adminEnabled) {
                call.respondText("granted")
            } else {
                call.respondText("reserved")
            }
            return@get
        }

        try {
            val exists = serverContext.authProvider.doesUserExist(username)
            call.respondText(if (exists) "yes" else "no")
        } catch (e: Exception) {
            Logger.error { "Failed to check if user exists: $username, e.message:${e.message}" }
            call.respond(HttpStatusCode.InternalServerError, mapOf("reason" to "Database error"))
        }
    }

    get("/keepalive") {
        val token = call.parameters["token"] ?: return@get call.respond(HttpStatusCode.BadRequest, "missing token")
        if (serverContext.sessionManager.refresh(token)) {
            return@get call.respond(HttpStatusCode.OK)
        } else {
            return@get call.respond(HttpStatusCode.Unauthorized, "Session expired, please login again")
        }
    }
}



================================================================================
ðŸ“„ FICHIER : src\main\kotlin\api\routes\BroadcastRoutes.kt
================================================================================

package api.routes

import server.broadcast.BroadcastMessage
import server.broadcast.BroadcastProtocol
import server.broadcast.BroadcastService
import context.ServerContext
import io.ktor.http.*
import io.ktor.server.request.*
import io.ktor.server.response.*
import io.ktor.server.routing.*
import kotlinx.serialization.Serializable
import utils.Logger

@Serializable
data class BroadcastRequest(
    val protocol: String,
    val arguments: List<String> = emptyList()
)

@Serializable
data class BroadcastResponse(
    val success: Boolean,
    val message: String,
    val clientCount: Int = 0
)

fun Route.broadcastRoutes(context: ServerContext) {
    route("/api/broadcast") {
        // Get broadcast status
        get("/status") {
            call.respond(
                HttpStatusCode.OK,
                mapOf(
                    "enabled" to BroadcastService.isEnabled(),
                    "clientCount" to BroadcastService.getClientCount()
                )
            )
        }

        // Send a broadcast message (admin only in production)
        post("/send") {
            if (context.config.isProd && !context.config.adminEnabled) {
                call.respond(HttpStatusCode.Forbidden, BroadcastResponse(false, "Broadcast API is disabled in production"))
                return@post
            }

            try {
                val request = call.receive<BroadcastRequest>()
                val protocol = BroadcastProtocol.fromCode(request.protocol)

                if (protocol == null) {
                    call.respond(
                        HttpStatusCode.BadRequest,
                        BroadcastResponse(false, "Invalid protocol: ${request.protocol}")
                    )
                    return@post
                }

                val message = BroadcastMessage(protocol, request.arguments)
                BroadcastService.broadcast(message)

                Logger.info("ðŸ“¤ Broadcast sent via API: ${message.toWireFormat()}")

                call.respond(
                    HttpStatusCode.OK,
                    BroadcastResponse(
                        success = true,
                        message = "Broadcast sent successfully",
                        clientCount = BroadcastService.getClientCount()
                    )
                )
            } catch (e: Exception) {
                Logger.error("Failed to send broadcast: ${e.message}")
                call.respond(
                    HttpStatusCode.InternalServerError,
                    BroadcastResponse(false, "Failed to send broadcast: ${e.message}")
                )
            }
        }

        // Quick test endpoint for plain text
        post("/test") {
            if (context.config.isProd && !context.config.adminEnabled) {
                call.respond(HttpStatusCode.Forbidden, BroadcastResponse(false, "Broadcast API is disabled in production"))
                return@post
            }

            @Serializable
            data class TestRequest(val message: String)

            try {
                val request = call.receive<TestRequest>()
                BroadcastService.broadcastPlainText(request.message)

                Logger.info("ðŸ“¤ Test broadcast sent: ${request.message}")

                call.respond(
                    HttpStatusCode.OK,
                    BroadcastResponse(
                        success = true,
                        message = "Test broadcast sent",
                        clientCount = BroadcastService.getClientCount()
                    )
                )
            } catch (e: Exception) {
                Logger.error("Failed to send test broadcast: ${e.message}")
                call.respond(
                    HttpStatusCode.InternalServerError,
                    BroadcastResponse(false, "Failed to send test broadcast: ${e.message}")
                )
            }
        }
    }
}



================================================================================
ðŸ“„ FICHIER : src\main\kotlin\api\routes\CaseInsensitiveStaticResources.kt
================================================================================

package api.routes

import io.ktor.http.ContentType
import io.ktor.http.HttpStatusCode
import io.ktor.http.defaultForFileExtension
import io.ktor.server.request.path
import io.ktor.server.response.respond
import io.ktor.server.response.respondFile
import io.ktor.server.routing.Route
import io.ktor.server.routing.contentType
import io.ktor.server.routing.get
import java.io.File
import kotlin.io.extension

fun Route.caseInsensitiveStaticResources(baseUrl: String, rootFolder: File) {
    val fileMap = scanFileSystemResources(rootFolder)

    get("$baseUrl/{...}") {
        val rawPath = call.request.path().replace(Regex("/+"), "/")
        val relativePath = rawPath.removePrefix(baseUrl).trimStart('/')
        val lookupKey = "$baseUrl/${relativePath}".lowercase()

        val file = fileMap[lookupKey]
        if (file != null && file.exists()) {
            val contentType = ContentType.defaultForFileExtension(file.extension)
            return@get call.respondFile(file, configure = {
                contentType(contentType) {}
            })
        }

        call.respond(HttpStatusCode.NotFound)
    }
}

fun scanFileSystemResources(resourceRoot: File): Map<String, File> {
    val map = mutableMapOf<String, File>()

    resourceRoot.walkTopDown()
        .filter { it.isFile }
        .forEach { file ->
            val relativePath = file.relativeTo(resourceRoot).invariantSeparatorsPath
            val key = ("/$relativePath").lowercase()
            map[key] = file
        }

    return map
}



================================================================================
ðŸ“„ FICHIER : src\main\kotlin\api\routes\FileRoutes.kt
================================================================================

package api.routes

import io.ktor.http.*
import io.ktor.server.http.content.*
import io.ktor.server.response.*
import io.ktor.server.routing.*
import java.io.File

fun Route.fileRoutes() {
    get("/") {
        val indexFile = File("static/index.html")
        if (indexFile.exists()) {
            call.respondFile(indexFile)
        } else {
            call.respond(HttpStatusCode.NotFound, "Index HTML not available, please use DZ app")
        }
    }
    staticFiles("/game", File("static/game/"))
    staticFiles("/assets", File("static/assets"))
    staticFiles("/crossdomain.xml", File("static/crossdomain.xml"))
}



================================================================================
ðŸ“„ FICHIER : src\main\kotlin\api\utils\BigDBConverter.kt
================================================================================

package api.utils

import api.message.db.ArrayProperty
import api.message.db.BigDBObject
import api.message.db.ObjectProperty
import api.message.db.ValueObject
import api.message.db.ValueType
import kotlin.reflect.KProperty1
import kotlin.reflect.KVisibility

object BigDBConverter {
    inline fun <reified T : Any> toBigDBObject(key: String = "", obj: T, creator: UInt = 0u): BigDBObject {
        val props = toObjectProperties(obj)
        return BigDBObject(
            key = key,
            version = "1",
            properties = props,
            creator = creator
        )
    }

    fun toValueObject(value: Any?, isDate: Boolean? = null): ValueObject {
        return when (value) {
            null -> ValueObject(valueType = ValueType.STRING, string = "")
            is String -> ValueObject(valueType = ValueType.STRING, string = value)
            is Int -> ValueObject(valueType = ValueType.INT32, int32 = value)
            is UInt -> ValueObject(valueType = ValueType.UINT, uInt = value)
            is Long -> {
                if (isDate == true) {
                    ValueObject(valueType = ValueType.DATETIME, dateTime = value)
                } else {
                    ValueObject(valueType = ValueType.LONG, long = value)
                }
            }
            is Boolean -> ValueObject(valueType = ValueType.BOOL, bool = value)
            is Float -> ValueObject(valueType = ValueType.FLOAT, float = value)
            is Double -> ValueObject(valueType = ValueType.DOUBLE, double = value)
            is ByteArray -> ValueObject(valueType = ValueType.BYTE_ARRAY, byteArray = value)
            is List<*> -> ValueObject(
                valueType = ValueType.ARRAY,
                arrayProperties = value.mapIndexed { idx, v ->
                    ArrayProperty(index = idx, value = toValueObject(v))
                }
            )

            is Map<*, *> -> {
                val props = value.entries.mapNotNull { (k, v) ->
                    k?.toString()?.let { ObjectProperty(it, toValueObject(v)) }
                }
                ValueObject(valueType = ValueType.OBJECT, objectProperties = props)
            }

            is Enum<*> -> ValueObject(valueType = ValueType.STRING, string = value.name)
            else -> {
                val props = toObjectProperties(value)
                ValueObject(valueType = ValueType.OBJECT, objectProperties = props)
            }
        }
    }

    fun toObjectProperties(obj: Any): List<ObjectProperty> {
        val reserved = setOf("key", "creator", "version")
        val knownDateKeys = setOf("nextDZBountyIssue", "lastLogout", "lastLogin", "prevLogin")

        return obj::class.members
            .filterIsInstance<KProperty1<Any, *>>()
            .filter { it.visibility == KVisibility.PUBLIC }
            .mapNotNull { prop ->
                val name = prop.name
                if (name in reserved) return@mapNotNull null
                val value = runCatching { prop.get(obj) }.getOrNull()

                if (value == null) return@mapNotNull null

                if (name in knownDateKeys) {
                    ObjectProperty(name, toValueObject(value, true))
                } else {
                    ObjectProperty(name, toValueObject(value))
                }
            }
    }
}


================================================================================
ðŸ“„ FICHIER : src\main\kotlin\api\utils\PIOFraming.kt
================================================================================

package api.utils

/**
 * Adds a PlayerIO framing prefix to the byte array.
 *
 * This is required by the PlayerIO API message convention, which expects each request and response
 * to be prefixed with two specific bytes: `0x00` and `0x01`.
 *
 * @receiver The original unframed [ByteArray] representing a protocol buffer message.
 * @return A new [ByteArray] with `0x00` and `0x01` prepended.
 */
fun ByteArray.pioFraming(): ByteArray {
    return byteArrayOf(0, 1) + this
}



================================================================================
ðŸ“„ FICHIER : src\main\kotlin\context\PlayerContext.kt
================================================================================

package context

import core.compound.CompoundService
import core.items.InventoryService
import core.metadata.PlayerObjectsMetadataService
import core.survivor.SurvivorService
import data.collection.PlayerAccount
import server.core.Connection

/**
 * A player-scoped data holder. This includes player's socket connection, metadata,
 * and the player's game data, which isn't directly, but found in various [PlayerService].
 *
 * A PlayerContext, including its services, is initialized in the [JoinHandler].
 */
data class PlayerContext(
    val playerId: String,
    val connection: Connection,
    val onlineSince: Long,
    val playerAccount: PlayerAccount,
    val services: PlayerServices
)

data class PlayerServices(
    val survivor: SurvivorService,
    val compound: CompoundService,
    val inventory: InventoryService,
    val playerObjectMetadata: PlayerObjectsMetadataService
)



================================================================================
ðŸ“„ FICHIER : src\main\kotlin\context\PlayerContextTracker.kt
================================================================================

package context

import core.compound.CompoundRepositoryMaria
import core.compound.CompoundService
import core.items.InventoryRepositoryMaria
import core.items.InventoryService
import core.metadata.PlayerObjectsMetadataRepositoryMaria
import core.metadata.PlayerObjectsMetadataService
import core.survivor.SurvivorRepositoryMaria
import core.survivor.SurvivorService
import data.db.BigDB
import data.db.BigDBMariaImpl
import io.ktor.util.date.*
import server.core.Connection
import java.util.concurrent.ConcurrentHashMap

class PlayerContextTracker {
    val players = ConcurrentHashMap<String, PlayerContext>()
    
    suspend fun createContext(playerId: String, connection: Connection, db: BigDB) {
        val playerAccount = requireNotNull(db.loadPlayerAccount(playerId)) { 
            "Missing PlayerAccount for playerid=$playerId" 
        }
        
        val context = PlayerContext(
            playerId = playerId,
            connection = connection,
            onlineSince = getTimeMillis(),
            playerAccount = playerAccount,
            services = initializeServices(playerId, db)
        )
        players[playerId] = context
    }
    
    private suspend fun initializeServices(playerId: String, db: BigDB): PlayerServices {
        // RÃ©cupÃ©rer la database Exposed depuis BigDB
        val database = (db as BigDBMariaImpl).database
        
        requireNotNull(db.loadPlayerAccount(playerId)) { 
            "Weird, PlayerAccount for playerId=$playerId is null" 
        }
        
        val playerObjects = requireNotNull(db.loadPlayerObjects(playerId)) { 
            "Weird, PlayerObjects for playerId=$playerId is null" 
        }

        val survivor = SurvivorService(
            survivorLeaderId = playerObjects.playerSurvivor!!,
            survivorRepository = SurvivorRepositoryMaria(database)
        )
        
        val inventory = InventoryService(inventoryRepository = InventoryRepositoryMaria(database))
        val compound = CompoundService(compoundRepository = CompoundRepositoryMaria(database))
        val playerObjectMetadata = PlayerObjectsMetadataService(
            playerObjectsMetadataRepository = PlayerObjectsMetadataRepositoryMaria(database)
        )
        
        survivor.init(playerId).onFailure { "Failure during survivor service init: ${it.message}" }
        inventory.init(playerId).onFailure { "Failure during inventory service init: ${it.message}" }
        compound.init(playerId).onFailure { "Failure during compound service init: ${it.message}" }
        playerObjectMetadata.init(playerId).onFailure { "Failure during playerObjectMetadata service init: ${it.message}" }
        
        return PlayerServices(
            survivor = survivor,
            compound = compound,
            inventory = inventory,
            playerObjectMetadata = playerObjectMetadata
        )
    }
    
    fun getContext(playerId: String): PlayerContext? {
        return players[playerId]
    }
    
    fun removePlayer(playerId: String) {
        players.remove(playerId)
    }
    
    fun shutdown() {
        players.values.forEach {
            it.connection.shutdown()
        }
        players.clear()
    }
}



================================================================================
ðŸ“„ FICHIER : src\main\kotlin\context\ServerContext.kt
================================================================================

package context

import data.db.BigDB
import server.core.OnlinePlayerRegistry
import server.handler.save.SaveSubHandler
import server.tasks.ServerTaskDispatcher
import user.PlayerAccountRepository
import user.auth.AuthProvider
import user.auth.SessionManager

data class ServerContext(
    val db: BigDB,
    val playerAccountRepository: PlayerAccountRepository,
    val sessionManager: SessionManager,
    val onlinePlayerRegistry: OnlinePlayerRegistry,
    val authProvider: AuthProvider,
    val taskDispatcher: ServerTaskDispatcher,
    val playerContextTracker: PlayerContextTracker,
    val saveHandlers: List<SaveSubHandler>,
    val config: ServerConfig,
)

fun ServerContext.getPlayerContextOrNull(playerId: String): PlayerContext? =
    playerContextTracker.getContext(playerId)

fun ServerContext.requirePlayerContext(playerId: String): PlayerContext =
    getPlayerContextOrNull(playerId)
        ?: error("PlayerContext not found for pid=$playerId")

data class ServerConfig(
    val adminEnabled: Boolean,
    val useMaria: Boolean,
    val mariaUrl: String,
    val mariaUser: String,
    val mariaPassword: String,
    val isProd: Boolean,
    val gameHost: String = "127.0.0.1",
    val gamePort: Int = 7777,
    val broadcastEnabled: Boolean = true,
    val broadcastHost: String = "0.0.0.0",
    val broadcastPorts: List<Int> = listOf(2121, 2122, 2123),
    val broadcastPolicyServerEnabled: Boolean = true,
    val policyHost: String = "0.0.0.0",
    val policyPort: Int = 843,
)


================================================================================
ðŸ“„ FICHIER : src\main\kotlin\core\LazyDataUpdater.kt
================================================================================

package dev.deadzone.core

import core.model.game.data.*
import dev.deadzone.core.model.game.data.*
import io.ktor.util.date.*
import kotlin.math.ceil
import kotlin.math.max
import kotlin.time.Duration.Companion.milliseconds

/**
 * Lazily update player's data based on timer or lastLogin
 */
object LazyDataUpdater {
    fun depleteResources(lastLogin: Long, res: GameResources): GameResources {
        val now = getTimeMillis()
        val minutesPassed = max(0, (now - lastLogin).milliseconds.inWholeMinutes)
        val depletionRate = 0.01
        // TO-DO depletion should be based on the number of survivors
        // depletion formula right now: each minutes deplete res by 0.01, an hour is 0.6, ceil the result

        val depleted = ceil(depletionRate * minutesPassed).toInt()
        return res.copy(
            food = max(0, res.food - depleted),
            water = max(0, res.water - depleted)
        )
    }

    @Suppress("CAST_NEVER_SUCCEEDS")
    fun removeBuildingTimerIfDone(buildings: List<BuildingLike>): List<BuildingLike> {
        return buildings.map { bld ->
            if (bld is Building) {
                val upgradeWasGoing = bld.upgrade != null
                val repairWasGoing = bld.repair != null

                if (upgradeWasGoing) {
                    val upgradeDone = bld.upgrade.hasEnded()

                    if (upgradeDone) {
                        val level = (bld.upgrade.data?.get("level") as? Int ?: 1)
                        bld.copy(level = level, upgrade = null)
                    }
                }

                if (repairWasGoing) {
                    val repairDone = bld.repair.hasEnded()

                    if (repairDone) {
                        bld.copy(repair = null, destroyed = false)
                    }
                }
            }
            bld
        }
    }
}



================================================================================
ðŸ“„ FICHIER : src\main\kotlin\core\LoginStateBuilder.kt
================================================================================

package core

import context.ServerContext
import core.data.PlayerLoginState
import utils.JSON

/**
 * Per-player dynamic updates.
 *
 * Assumption:
 *   Some fields come from PlayerObjects and represent values that change over time.
 *   When a player logs out, their data is stored in the database, but certain values
 *   (e.g., resources) can change while theyâ€™re offline due to natural depletion or
 *   external events such as PvP attacks.
 *
 *   Therefore, when the player logs in, we must recalculate these values to reflect
 *   the time elapsed since their last session. The updated values should then be
 *   written back to the database before proceeding, since API 85 (the load request)
 *   will immediately send this data to the client.
 */
object LoginStateBuilder {
    /**
     * Build login state for the given [pid], returning the raw JSON string.
     */
    fun build(serverContext: ServerContext, pid: String): String {
        // must not be null, just initialized in handle
        val context = serverContext.playerContextTracker.getContext(playerId = pid)!!

        // TODO: create service and repository methods
        return JSON.encode(
            PlayerLoginState(
                // global game services
                settings = emptyMap(),
                news = emptyMap(),
                sales = emptyList(),
                allianceWinnings = emptyMap(),
                recentPVPList = emptyList(),

                // per-player update
                invsize = 500, // the default inventory size
                upgrades = "",

                // per-player data
                allianceId = null,
                allianceTag = null,

                // if true will prompt captcha
                longSession = false,

                // per-player update
                leveledUp = false,

                // global server update
                promos = emptyList(),
                promoSale = null,
                dealItem = null,

                // per-player update
                leaderResets = 0,
                unequipItemBinds = emptyList(),

                // unsure
                globalStats = emptyMap(),

                // per-player update
                resources = context.services.compound.getResources(),
                survivors = context.services.survivor.getAllSurvivors(),
                tasks = null,
                missions = null,
                bountyCap = null,
                bountyCapTimestamp = null,
                research = null
            )
        )
    }
}



================================================================================
ðŸ“„ FICHIER : src\main\kotlin\core\PlayerService.kt
================================================================================

package core

/**
 * Represents a player-scoped game service.
 *
 * This service manages data and domain logic related to a specific game domain for a particular player,
 * such as survivors, inventory, or loot. It is not responsible for low-level database operations,
 * nor should it handle player identification on each operations. Instead, it stores domain data and provides
 * operations to callers.
 *
 * Typically, the service initializes local data through the [init] method.
 * It receives a repository specific to the domain (e.g., [SurvivorRepository]) to delegates the
 * low-level database work. Each repository is preferred to be wrapped in try-catch
 * and always return a Result<T> type. This is to ensure consistency on error handling across repository.
 *
 * Repository may define CRUD operations only, letting the service define the more complex operations.
 *
 * See examples: [SurvivorService]
 */
interface PlayerService {
    /**
     * Initializes the service for the specified [playerId].
     *
     * This method should be used to load or prepare all data related to the player
     * in this service's domain.
     *
     * @return An empty result just for denoting success or failure.
     */
    suspend fun init(playerId: String): Result<Unit>

    /**
     * Closes the service for the specified [playerId].
     *
     * This method is called when the player logs off or disconnects.
     * It should synchronize any in-memory state with persistent storage
     * to ensure no progress or transient data is lost.
     *
     * For example, [CompoundService] maintains additional timing data to enable lazy
     * calculation of building resource production without storing additional time data
     * in the DB and doing more query. This also avoid the need of server running
     * an increment resource task on each production building.
     *
     * However, without a server-initiated task, the DB wouldn't keep the latest data at all time.
     * The `close` method would update fields such as `resourceValue` on production buildings,
     * to reflect the final accumulated resources since the last time resources was collected.
     *
     * @return An empty result just for denoting success or failure.
     */
    suspend fun close(playerId: String): Result<Unit>
}



================================================================================
ðŸ“„ FICHIER : src\main\kotlin\core\compound\CompoundRepository.kt
================================================================================

package core.compound

import core.model.game.data.BuildingLike
import core.model.game.data.GameResources

interface CompoundRepository {
    // Resource C_U_
    suspend fun getGameResources(playerId: String): Result<GameResources>
    suspend fun updateGameResources(
        playerId: String,
        newResources: GameResources
    ): Result<Unit>

    // Building CRUD
    suspend fun createBuilding(
        playerId: String,
        newBuilding: BuildingLike
    ): Result<Unit>
    suspend fun getBuildings(playerId: String): Result<List<BuildingLike>>
    suspend fun updateBuilding(
        playerId: String,
        bldId: String,
        updatedBuilding: BuildingLike
    ): Result<Unit>
    suspend fun updateAllBuildings(
        playerId: String,
        updatedBuildings: List<BuildingLike>
    ): Result<Unit>
    suspend fun deleteBuilding(playerId: String, bldId: String): Result<Unit>
}



================================================================================
ðŸ“„ FICHIER : src\main\kotlin\core\compound\CompoundRepositoryMaria.kt
================================================================================

package core.compound

import core.model.game.data.BuildingLike
import core.model.game.data.GameResources
import core.model.game.data.id
import data.collection.PlayerObjects
import data.db.PlayerObjectsTable
import data.db.suspendedTransactionResult
import org.jetbrains.exposed.sql.Database
import org.jetbrains.exposed.sql.selectAll
import org.jetbrains.exposed.sql.update
import utils.JSON

class CompoundRepositoryMaria(private val database: Database) : CompoundRepository {

    private suspend fun <T> getPlayerObjectsData(playerId: String, transform: (PlayerObjects) -> T): Result<T> {
        return database.suspendedTransactionResult {
            PlayerObjectsTable
                .selectAll()
                .where { PlayerObjectsTable.playerId eq playerId }
                .singleOrNull()
                ?.let { row ->
                    val playerObjects =
                        JSON.decode(PlayerObjects.serializer(), row[PlayerObjectsTable.dataJson])
                    transform(playerObjects)
                } ?: throw NoSuchElementException("getPlayerObjectsData: No PlayerObjects found with id=$playerId")
        }
    }

    private suspend fun updatePlayerObjectsData(
        playerId: String,
        updateAction: (PlayerObjects) -> PlayerObjects
    ): Result<Unit> {
        return database.suspendedTransactionResult {
            val currentRow = PlayerObjectsTable.selectAll().where { PlayerObjectsTable.playerId eq playerId }
                .singleOrNull() ?: throw NoSuchElementException("No player found with id=$playerId")

            val currentData = JSON.decode(PlayerObjects.serializer(), currentRow[PlayerObjectsTable.dataJson])
            val updatedData = updateAction(currentData)

            val rowsUpdated = PlayerObjectsTable.update({ PlayerObjectsTable.playerId eq playerId }) {
                it[dataJson] = JSON.encode(PlayerObjects.serializer(), updatedData)
            }
            if (rowsUpdated == 0) {
                throw Exception("Failed to update PlayerObjects in updatePlayerObjectsData for playerId=$playerId")
            }
        }

    }

    override suspend fun getGameResources(playerId: String): Result<GameResources> {
        return getPlayerObjectsData(playerId) { it.resources }
    }

    override suspend fun updateGameResources(playerId: String, newResources: GameResources): Result<Unit> {
        return updatePlayerObjectsData(playerId) { it.copy(resources = newResources) }
    }

    override suspend fun createBuilding(playerId: String, newBuilding: BuildingLike): Result<Unit> {
        return updatePlayerObjectsData(playerId) { currentData ->
            currentData.copy(buildings = currentData.buildings + newBuilding)
        }
    }

    override suspend fun getBuildings(playerId: String): Result<List<BuildingLike>> {
        return getPlayerObjectsData(playerId) { it.buildings }
    }

    override suspend fun updateBuilding(playerId: String, bldId: String, updatedBuilding: BuildingLike): Result<Unit> {
        return updatePlayerObjectsData(playerId) { currentData ->
            val updatedBuildings = currentData.buildings.toMutableList()

            val buildingIndex = updatedBuildings.indexOfFirst { it.id == bldId }
            if (buildingIndex == -1) {
                throw NoSuchElementException("No building found for bldId=$bldId on playerId=$playerId")
            }

            updatedBuildings[buildingIndex] = updatedBuilding
            currentData.copy(buildings = updatedBuildings)
        }
    }

    override suspend fun updateAllBuildings(
        playerId: String,
        updatedBuildings: List<BuildingLike>
    ): Result<Unit> {
        return updatePlayerObjectsData(playerId) { currentData ->
            currentData.copy(buildings = updatedBuildings)
        }
    }

    override suspend fun deleteBuilding(playerId: String, bldId: String): Result<Unit> {
        return updatePlayerObjectsData(playerId) { currentData ->
            val updatedBuildings = currentData.buildings.filterNot { it.id == bldId }
            currentData.copy(buildings = updatedBuildings)
        }
    }
}



================================================================================
ðŸ“„ FICHIER : src\main\kotlin\core\compound\CompoundService.kt
================================================================================

package core.compound

import core.PlayerService
import core.model.game.data.*
import utils.LogConfigSocketError
import utils.Logger
import io.ktor.util.date.*
import kotlin.time.Duration
import kotlin.time.Duration.Companion.seconds

class CompoundService(private val compoundRepository: CompoundRepository) : PlayerService {
    private lateinit var resources: GameResources
    private val buildings = mutableListOf<BuildingLike>()
    private val lastResourceValueUpdated = mutableMapOf<String, Long>()
    private lateinit var playerId: String

    fun getResources() = resources

    fun getIndexOfBuilding(bldId: String): Int {
        val idx = buildings.indexOfFirst { it.id == bldId }
        if (idx == -1) {
            Logger.error(LogConfigSocketError) { "Building bldId=$bldId not found for playerId=$playerId" }
        }
        return idx
    }

    fun getBuilding(bldId: String): BuildingLike? {
        return buildings.find { it.id == bldId }
    }

    suspend fun updateBuilding(
        bldId: String,
        updateAction: suspend (BuildingLike) -> BuildingLike
    ): Result<Unit> {
        val idx = getIndexOfBuilding(bldId)
        if (idx == -1) return Result.failure(NoSuchElementException("Building bldId=$bldId not found for playerId=$playerId"))

        val update = updateAction(buildings[idx])

        val result = compoundRepository.updateBuilding(playerId, bldId, update)
        result.onFailure {
            Logger.error(LogConfigSocketError) { "Error on updateBuilding for playerId=$playerId: ${it.message}" }
        }
        result.onSuccess {
            buildings[idx] = update
        }
        return result
    }

    suspend fun updateAllBuildings(buildings: List<BuildingLike>): Result<Unit> {
        val result = compoundRepository.updateAllBuildings(playerId, buildings)
        result.onFailure {
            Logger.error(LogConfigSocketError) { "Error on updateAllBuildings for playerId=$playerId: ${it.message}" }
        }
        result.onSuccess {
            this.buildings.clear()
            this.buildings.addAll(buildings)
        }
        return result
    }

    suspend fun createBuilding(createAction: suspend () -> (BuildingLike)): Result<Unit> {
        val create = createAction()
        val result = compoundRepository.createBuilding(playerId, create)
        result.onFailure {
            Logger.error(LogConfigSocketError) { "Error on createBuilding for playerId=$playerId: ${it.message}" }
        }
        result.onSuccess {
            this.buildings.add(create)
        }
        return result
    }

    suspend fun deleteBuilding(bldId: String): Result<Unit> {
        val result = compoundRepository.deleteBuilding(playerId, bldId)
        result.onFailure {
            Logger.error(LogConfigSocketError) { "Error on deleteBuilding for playerId=$playerId: ${it.message}" }
        }
        result.onSuccess {
            this.buildings.removeIf { it.id == bldId }
        }
        return result
    }


    suspend fun collectBuilding(bldId: String): Result<GameResources> {
        val lastUpdate = lastResourceValueUpdated[bldId]
            ?: return Result.failure(NoSuchElementException("Building bldId=$bldId is not categorized as production buildings"))

        val collectedAmount = calculateResource(lastUpdate.seconds)
        lastResourceValueUpdated[bldId] = getTimeMillis()

        val updateResult = updateBuilding(bldId) { oldBld ->
            oldBld.copy(resourceValue = 0.0)
        }
        updateResult.onFailure { return Result.failure(it) }

        return Result.success(GameResources(wood = collectedAmount.toInt()))
    }

    suspend fun updateResource(updateAction: suspend (GameResources) -> (GameResources)): Result<Unit> {
        val update = updateAction(this.resources)
        val result = compoundRepository.updateGameResources(playerId, update)
        result.onFailure {
            Logger.error(LogConfigSocketError) { "Error on updateResource for playerId=$playerId: ${it.message}" }
        }
        result.onSuccess {
            this.resources = update
        }
        return result
    }

    fun calculateResource(durationSec: Duration): Double {
        val productionRate = 4
        // Parameter: building level, effects
        // See GameDefinitions of building.xml for realistic result
        return 10.0 + (productionRate * durationSec.inWholeMinutes)
    }

    override suspend fun init(playerId: String): Result<Unit> {
        return runCatching {
            this.playerId = playerId
            val _resources = compoundRepository.getGameResources(playerId).getOrThrow()
            val _buildings = compoundRepository.getBuildings(playerId).getOrThrow()
            this.resources = _resources
            buildings.addAll(_buildings)

            val now = getTimeMillis()

            for (bldLike in buildings) {
                if (isProductionBuilding(bldLike.type)) {
                    lastResourceValueUpdated[bldLike.id] = now
                }
            }
        }
    }

    override suspend fun close(playerId: String): Result<Unit> {
        return runCatching {
            val now = getTimeMillis()

            for (bldLike in buildings) {
                if (bldLike is JunkBuilding) continue
                val lastUpdate = lastResourceValueUpdated[bldLike.id] ?: continue
                val updateResult = updateBuilding(bldLike.id) { oldBld ->
                    oldBld.copy(resourceValue = calculateResource((now - lastUpdate).seconds))
                }
                updateResult.onFailure {
                    Logger.error(LogConfigSocketError) { "Failed to update building ${bldLike.id} during close for playerId=$playerId: ${it.message}" }
                }
            }
        }
    }

    private fun isProductionBuilding(idInXML: String): Boolean {
        return idInXML.contains("resource")
    }
}


================================================================================
ðŸ“„ FICHIER : src\main\kotlin\core\compound\model\Building.kt
================================================================================

package core.model.game.data

import core.items.model.Item
import dev.deadzone.core.model.game.data.TimerData
import utils.LogConfigSocketToClient
import utils.Logger
import utils.UUID
import kotlinx.serialization.DeserializationStrategy
import kotlinx.serialization.ExperimentalSerializationApi
import kotlinx.serialization.Serializable
import kotlinx.serialization.SerializationException
import kotlinx.serialization.json.*

@OptIn(ExperimentalSerializationApi::class)
@Serializable(with = BuildingLikeSerializer::class)
@JsonClassDiscriminator("_t")
sealed class BuildingLike

private object Unspecified {
    override fun toString() = "Unspecified"
}

fun BuildingLike.toBuilding(): Building {
    return this as Building
}

val BuildingLike.id: String
    get() = when (this) {
        is Building -> this.id
        is JunkBuilding -> this.id
    }

val BuildingLike.type: String
    get() = when (this) {
        is Building -> this.type
        is JunkBuilding -> this.type
    }

val BuildingLike.level: Int
    get() = when(this) {
        is Building -> this.level
        is JunkBuilding -> this.level
    }

val BuildingLike.upgrade: TimerData?
    get() = when (this) {
        is Building -> this.upgrade
        is JunkBuilding -> this.upgrade
    }

val BuildingLike.repair: TimerData?
    get() = when (this) {
        is Building -> this.repair
        is JunkBuilding -> this.repair
    }

fun BuildingLike.copy(
    id: String? = null,
    name: String? = null,
    type: String? = null,
    level: Int? = null,
    rotation: Int? = null,
    tx: Int? = null,
    ty: Int? = null,
    destroyed: Boolean? = null,
    resourceValue: Double? = null,
    upgrade: Any? = Unspecified,
    repair: Any? = Unspecified,
    items: List<Item>? = null,
    pos: String? = null,
    rot: String? = null
): BuildingLike = when (this) {
    is Building -> this.copy(
        id = id ?: this.id,
        name = name ?: this.name,
        type = type ?: this.type,
        level = level ?: this.level,
        rotation = rotation ?: this.rotation,
        tx = tx ?: this.tx,
        ty = ty ?: this.ty,
        destroyed = destroyed ?: this.destroyed,
        resourceValue = resourceValue ?: this.resourceValue,
        upgrade = if (upgrade === Unspecified) this.upgrade else upgrade as TimerData?,
        repair = if (repair === Unspecified) this.repair else repair as TimerData?
    )

    is JunkBuilding -> this.copy(
        id = id ?: this.id,
        name = name ?: this.name,
        type = type ?: this.type,
        level = level ?: this.level,
        rotation = rotation ?: this.rotation,
        tx = tx ?: this.tx,
        ty = ty ?: this.ty,
        destroyed = destroyed ?: this.destroyed,
        resourceValue = resourceValue ?: this.resourceValue,
        upgrade = if (upgrade === Unspecified) this.upgrade else upgrade as TimerData?,
        repair = if (repair === Unspecified) this.repair else repair as TimerData?,
        items = items ?: this.items,
        pos = pos ?: this.pos,
        rot = rot ?: this.rot
    )
}


@Serializable
data class Building(
    val id: String = UUID.new(),    // building's unique ID
    val name: String? = null,
    val type: String,  // building's ID in buildings.xml, not to be confused with type in XML
    val level: Int = 0,
    val rotation: Int = 0,
    val tx: Int = 0,
    val ty: Int = 0,
    val destroyed: Boolean = false,
    val resourceValue: Double = 0.0,
    val upgrade: TimerData? = null,
    val repair: TimerData? = null
) : BuildingLike()

fun Building.toCompactString(): String {
    return "Building(id=$id, type=$type, level=$level, upgrade=$upgrade, repair=$repair, resourceValue=$resourceValue)"
}

object BuildingLikeSerializer : JsonContentPolymorphicSerializer<BuildingLike>(BuildingLike::class) {
    override fun selectDeserializer(element: JsonElement): DeserializationStrategy<BuildingLike> {
        return when (val discriminator = element.jsonObject["_t"]?.jsonPrimitive?.contentOrNull) {
            "core.model.game.data.Building" -> Building.serializer()
            "core.model.game.data.JunkBuilding" -> JunkBuilding.serializer()
            null -> {
                val obj = element.jsonObject
                return when {
                    obj.containsKey("items") && obj.containsKey("pos") && obj.containsKey("rot") ->
                        JunkBuilding.serializer()

                    else ->
                        Building.serializer()
                }
            }

            else -> {
                Logger.error(
                    LogConfigSocketToClient,
                    forceLogFull = true
                ) { "Error during serialization of BuildingLike type: $element" }
                throw SerializationException("Unknown type: '$discriminator'")
            }
        }
    }
}



================================================================================
ðŸ“„ FICHIER : src\main\kotlin\core\compound\model\BuildingCollection.kt
================================================================================

package core.model.game.data

import kotlinx.serialization.Serializable

@Serializable
data class BuildingCollection(
    val list: List<BuildingLike> = listOf()
) {
    companion object {
        fun starterBase(): List<BuildingLike> {
            // player starter junks, based on compound.xml; id randomized, name based on 'name' field on XML.
            val junks = listOf(
                JunkBuilding(name = "junk", type = "junk-tutorial", pos = "-650,950,-1", rot = "0,0,0"),
                JunkBuilding(name = "junk1", type = "junk-pile-corner", pos = "-927,-1026,0", rot = "0,0,90"),
                JunkBuilding(name = "junk2", type = "junk-drums", pos = "-974,-323,0", rot = "0,0,90"),
                JunkBuilding(name = "junk3", type = "junk-machinery-small", pos = "1150,1150,0", rot = "0,0,0"),
                JunkBuilding(name = "junk4", type = "junk-pile-corner", pos = "-950,1150,0", rot = "0,0,0"),
                JunkBuilding(name = "junk5", type = "junk-pile-mid", pos = "-950,-639,0", rot = "0,0,180"),
                JunkBuilding(name = "junk6", type = "junk-machinery-large", pos = "-1050,150,0", rot = "0,0,270"),
                JunkBuilding(name = "junk7", type = "junk-pallets", pos = "-850,550,0", rot = "0,0,0"),
                JunkBuilding(name = "junk9", type = "junk-drums", pos = "-550,1150,0", rot = "0,0,0"),
                JunkBuilding(name = "junk11", type = "junk-drums", pos = "462,-1116,0", rot = "0,0,220"),
                JunkBuilding(name = "junk12", type = "junk-pile-small", pos = "950,-550,-1", rot = "0,0,180"),
                JunkBuilding(name = "junk14", type = "junk-pile-mid", pos = "650,-950,0", rot = "0,0,270"),
                JunkBuilding(name = "junk15", type = "junk-pallets", pos = "1048,-350,0", rot = "0,0,155"),
                JunkBuilding(name = "junk16", type = "junk-pile-mid", pos = "950,850,0", rot = "0,0,0"),
                JunkBuilding(name = "junk17", type = "junk-pallets", pos = "151,1161,0", rot = "0,0,270"),
                JunkBuilding(name = "junk20", type = "junk-machinery-small", pos = "1060,-1196,0", rot = "0,0,270"),
                JunkBuilding(name = "junk-outside-1", type = "junk-pile-small", pos = "950,-1950,-1", rot = "0,0,35"),
                JunkBuilding(name = "junk-outside-2", type = "junk-pallets", pos = "1214,-1984,0", rot = "0,0,0"),
                JunkBuilding(name = "junk-outside-3", type = "junk-pile-mid", pos = "1450,-1050,0", rot = "0,0,265"),
                JunkBuilding(name = "junk-outside-4", type = "junk-pile-car", pos = "1541,952,0", rot = "0,0,0"),
                JunkBuilding(name = "junk-outside-5", type = "junk-pile-small", pos = "1450,1850,-1", rot = "0,0,65"),
                JunkBuilding(name = "junk-outside-6", type = "junk-drums", pos = "1351,2149,0", rot = "0,0,90"),
                JunkBuilding(name = "junkCloth1", type = "junk-cloth", pos = "1420,-639,0", rot = "0,0,0"),
                JunkBuilding(name = "junkCloth2", type = "junk-cloth", pos = "-750,2750,0", rot = "0,0,180"),
                JunkBuilding(name = "junkCloth3", type = "junk-cloth", pos = "-850,-2350,0", rot = "0,0,90"),
                JunkBuilding(name = "junkCloth4", type = "junk-cloth", pos = "450,-450,0", rot = "0,0,0"),
                JunkBuilding(name = "junk-outside-25", type = "junk-pile-mid", pos = "2250,-52,0", rot = "0,0,0"),
                JunkBuilding(name = "junk-outside-26", type = "junk-pile-small", pos = "2350,2451,0", rot = "0,0,0"),
                JunkBuilding(name = "junk-outside-27", type = "junk-pile-mid", pos = "-450,-1650,0", rot = "0,0,0"),
                JunkBuilding(name = "junk-outside-wood-1", type = "junk-pallets", pos = "3392,2987,0", rot = "0,0,0"),
                JunkBuilding(name = "junk-outside-metal-1", type = "junk-drums", pos = "3550,-3050,0", rot = "0,0,0"),
                JunkBuilding(name = "junk-huge-1", type = "junk-pile-huge", pos = "2521,-2201,0", rot = "0,0,0"),
                JunkBuilding(name = "junk-huge-2", type = "junk-pile-huge-2", pos = "2441,-1635,0", rot = "0,0,0"),
                JunkBuilding(name = "junk-pile-huge-1-2", type = "junk-pile-huge", pos = "320,1982,0", rot = "0,0,180"),
                JunkBuilding(name = "junk-pile-huge-2-2", type = "junk-pile-huge-2", pos = "2600,1366,0", rot = "0,0,90"),
            )

            return buildList {
                addAll(junks)
                // defaults building
                add(Building(type = "rally", tx = 15, ty = 33, rotation = 0))
                add(Building(type = "bed", tx = 15, ty = 42, rotation = 0))
                add(Building(type = "car", tx = 35, ty = 50, rotation = 0))
            }
        }

        fun simpleBase(): List<BuildingLike> {
            return listOf(
                Building(type = "bed", tx = 19, ty = 35, level = 2, rotation = 3),
                Building(type = "storage-ammunition", tx = 11, ty = 47, level = 5, rotation = 2),
                Building(type = "storage-cloth", tx = 12, ty = 38, level = 5, rotation = 0),
                Building(type = "storage-water", tx = 16, ty = 42, level = 5, rotation = 0),
                Building(type = "storage-metal", tx = 12, ty = 44, level = 5, rotation = 0),
                Building(type = "recycler", tx = 21, ty = 40, level = 9, rotation = 1),
                Building(type = "compound-barricade-small", tx = 17, ty = 62, level = 0, rotation = 3),
                Building(type = "compound-barricade-small", tx = 20, ty = 61, level = 0, rotation = 0),
                Building(type = "compound-barricade-small", tx = 15, ty = 59, level = 0, rotation = 2),
                Building(type = "compound-barricade-small", tx = 31, ty = 46, level = 0, rotation = 3),
                Building(type = "compound-barricade-small", tx = 33, ty = 42, level = 0, rotation = 1),
                Building(type = "compound-barricade-small", tx = 34, ty = 45, level = 0, rotation = 0),
                Building(type = "compound-barricade-small", tx = 18, ty = 29, level = 0, rotation = 0),
                Building(type = "compound-barricade-small", tx = 17, ty = 26, level = 0, rotation = 1),
                Building(type = "compound-barricade-small", tx = 14, ty = 27, level = 0, rotation = 2),
                Building(type = "deadend", tx = 31, ty = 51, level = 0, rotation = 0),
                Building(type = "deadend", tx = 32, ty = 38, level = 0, rotation = 0),
                Building(type = "deadend", tx = 25, ty = 60, level = 0, rotation = 3),
                Building(type = "rally", tx = 18, ty = 60, level = 0, rotation = 3),
                Building(type = "rally", tx = 32, ty = 44, level = 0, rotation = 0),
                Building(type = "rally", tx = 16, ty = 24, level = 0, rotation = 1),
            )
        }

        fun goodBase(): List<BuildingLike> {
            return listOf(
                // inside
                Building(type = "bed", tx = 9, ty = 46, level = 4, rotation = 0),
                Building(type = "bed", tx = 9, ty = 43, level = 4, rotation = 0),
                Building(type = "bed", tx = 9, ty = 40, level = 4, rotation = 0),
                Building(type = "shower", tx = 15, ty = 50, level = 4, rotation = 0),
                Building(type = "shower", tx = 18, ty = 50, level = 4, rotation = 0),
                Building(type = "storage-ammunition", tx = 15, ty = 42, level = 5, rotation = 0),
                Building(type = "storage-ammunition", tx = 18, ty = 42, level = 5, rotation = 0),
                Building(type = "storage-cloth", tx = 7, ty = 34, level = 5, rotation = 3),
                Building(type = "storage-cloth", tx = 24, ty = 34, level = 5, rotation = 3),
                Building(type = "storage-water", tx = 8, ty = 55, level = 5, rotation = 0),
                Building(type = "storage-water", tx = 8, ty = 52, level = 5, rotation = 0),
                Building(type = "storage-metal", tx = 27, ty = 55, level = 5, rotation = 0),
                Building(type = "storage-metal", tx = 24, ty = 55, level = 5, rotation = 0),
                Building(type = "recycler", tx = 14, ty = 34, level = 9, rotation = 0),
                Building(type = "workbench", tx = 14, ty = 45, level = 4, rotation = 3),
                Building(type = "bench-engineering", tx = 19, ty = 34, level = 4, rotation = 3),
                Building(type = "bench-weapon", tx = 19, ty = 44, level = 4, rotation = 0),

                // right side
                Building(type = "barricadeSmall", tx = 13, ty = 28, level = 4, rotation = 2),
                Building(type = "barricadeSmall", tx = 15, ty = 27, level = 4, rotation = 1),
                Building(type = "barricadeSmall", tx = 18, ty = 27, level = 4, rotation = 1),
                Building(type = "barricadeSmall", tx = 18, ty = 30, level = 4, rotation = 0),
                Building(type = "door", tx = 17, ty = 57, level = 4, rotation = 3),
                Building(type = "rally", tx = 16, ty = 24, level = 0, rotation = 1),

                // outer right side
                Building(type = "defence-wire", tx = 26, ty = 15, level = 3, rotation = 1),
                Building(type = "defence-wire", tx = 32, ty = 15, level = 3, rotation = 1),
                Building(type = "defence-wire", tx = 38, ty = 15, level = 3, rotation = 1),
                Building(type = "defence-wire", tx = 38, ty = 21, level = 3, rotation = 0),
                Building(type = "defence-wire", tx = 38, ty = 27, level = 3, rotation = 0),
                Building(type = "windmill", tx = 33, ty = 20, level = 4, rotation = 1),
                Building(type = "trap-halloween-decoy", tx = 10, ty = 14, level = 0, rotation = 1),
                Building(type = "trap-halloween-decoy", tx = 8, ty = 14, level = 0, rotation = 1),

                // front side
                Building(type = "barricadeSmall", tx = 32, ty = 35, level = 4, rotation = 1),
                Building(type = "barricadeSmall", tx = 35, ty = 35, level = 4, rotation = 1),
                Building(type = "barricadeLarge", tx = 30, ty = 57, level = 4, rotation = 3),
                Building(type = "barricadeLarge", tx = 36, ty = 57, level = 4, rotation = 3),
                Building(type = "barricadeLarge", tx = 41, ty = 56, level = 4, rotation = 0),
                Building(type = "barricadeLarge", tx = 41, ty = 47, level = 4, rotation = 0),
                Building(type = "barricadeLarge", tx = 41, ty = 41, level = 4, rotation = 0),
                Building(type = "barricadeLarge", tx = 41, ty = 35, level = 4, rotation = 1),
                Building(type = "watchtower", tx = 31, ty = 53, level = 3, rotation = 3),
                Building(type = "watchtower", tx = 33, ty = 39, level = 3, rotation = 0),
                Building(type = "gate", tx = 41, ty = 50, level = 4, rotation = 0),
                Building(type = "deadend", tx = 37, ty = 50, level = 0, rotation = 0),
                Building(type = "deadend", tx = 37, ty = 38, level = 0, rotation = 0),
                Building(type = "rally", tx = 32, ty = 44, level = 0, rotation = 0),

                // left side
                Building(type = "barricadeLarge", tx = 14, ty = 58, level = 4, rotation = 2),
                Building(type = "barricadeLarge", tx = 15, ty = 63, level = 4, rotation = 3),
                Building(type = "barricadeLarge", tx = 21, ty = 63, level = 4, rotation = 0),
                Building(type = "construction-yard", tx = 28, ty = 59, level = 4, rotation = 1),
                Building(type = "door", tx = 16, ty = 31, level = 4, rotation = 1),
                Building(type = "deadend", tx = 18, ty = 67, level = 0, rotation = 3),
                Building(type = "rally", tx = 17, ty = 59, level = 0, rotation = 3),
            )
        }
    }
}



================================================================================
ðŸ“„ FICHIER : src\main\kotlin\core\compound\model\CompoundData.kt
================================================================================

package core.model.game.data

import kotlinx.serialization.Serializable
import data.collection.PlayerObjects

@Serializable
data class CompoundData(
    val player: PlayerObjects?,
    val buildings: BuildingCollection = BuildingCollection(),
    val resources: GameResources = GameResources(),
    val survivors: SurvivorCollection = SurvivorCollection(),
    val tasks: TaskCollection = TaskCollection(),
    val effects: EffectCollection = EffectCollection(),
    val globalEffects: EffectCollection = EffectCollection(),
    val morale: Morale = Morale(),
    val moraleFilter: List<String> = listOf("food", "water", "security", "comfort")
)



================================================================================
ðŸ“„ FICHIER : src\main\kotlin\core\compound\model\GameResources.kt
================================================================================

package core.model.game.data

import kotlinx.serialization.Serializable

@Serializable
data class GameResources(
    val wood: Int = 0,
    val metal: Int = 0,
    val cloth: Int = 0,
    val water: Int = 0,
    val food: Int = 0,
    val ammunition: Int = 0,
    val cash: Int = 0
) {
    operator fun plus(other: GameResources): GameResources = GameResources(
        wood = this.wood + other.wood,
        metal = this.metal + other.metal,
        cloth = this.cloth + other.cloth,
        water = this.water + other.water,
        food = this.food + other.food,
        ammunition = this.ammunition + other.ammunition,
        cash = this.cash + other.cash
    )
}

fun GameResources.getNonEmptyResAmountOrNull(): Int? {
    val nonEmpty = listOf(
        wood, metal, cloth, food, water, ammunition, cash
    ).filter { it != 0 }

    return if (nonEmpty.size == 1) nonEmpty.first() else null
}

fun GameResources.getNonEmptyResTypeOrNull(): String? {
    val nonEmpty = listOf(
        "wood" to wood,
        "metal" to metal,
        "cloth" to cloth,
        "food" to food,
        "water" to water,
        "ammunition" to ammunition,
        "cash" to cash
    ).filter { it.second != 0 }

    return nonEmpty.singleOrNull()?.first
}



================================================================================
ðŸ“„ FICHIER : src\main\kotlin\core\compound\model\GameResourcesConstants.kt
================================================================================

package core.model.game.data

import kotlinx.serialization.Serializable

@Serializable
@JvmInline
value class GameResourcesConstants(val value: String)

object GameResourcesConstants_Constants {
    val CASH = GameResourcesConstants("cash")
    val WOOD = GameResourcesConstants("wood")
    val METAL = GameResourcesConstants("metal")
    val CLOTH = GameResourcesConstants("cloth")
    val WATER = GameResourcesConstants("water")
    val FOOD = GameResourcesConstants("food")
    val AMMUNITION = GameResourcesConstants("ammunition")
}



================================================================================
ðŸ“„ FICHIER : src\main\kotlin\core\compound\model\JunkBuilding.kt
================================================================================

package core.model.game.data

import kotlinx.serialization.Serializable
import core.items.model.Item
import dev.deadzone.core.model.game.data.TimerData
import utils.UUID

@Serializable
data class JunkBuilding(
    // from Building
    val id: String = UUID.new(),
    val name: String? = null,
    val type: String,
    val level: Int = 0,
    val rotation: Int = 0,
    val tx: Int = 0,
    val ty: Int = 0,
    val destroyed: Boolean = false,
    val resourceValue: Double = 0.0,
    val upgrade: TimerData? = null,
    val repair: TimerData? = null,

    // JunkBuilding-specific fields
    val items: List<Item> = emptyList(),
    val pos: String,
    val rot: String
) : BuildingLike()



================================================================================
ðŸ“„ FICHIER : src\main\kotlin\core\data\AdminData.kt
================================================================================

package core.data

/**
 * Dummy data ready to use, typically for admin account.
 */
object AdminData {
    const val ADMIN_RESERVED_NAME = "givemeadmin"
    const val PLAYER_ID = "adm-id-123456"
    const val DISPLAY_NAME = "AdminPlayer" // also known as username or nickname
    const val EMAIL = "admin@admin.com"
    const val PASSWORD = "admin"
    const val TOKEN = "admin-token-123456"
    const val COUNTRY_CODE = "US"
    const val AVATAR_URL = "https://picsum.photos/200"
    const val IS_ADMIN = true
    const val PLAYER_DATA_KEY = "admkey"
    const val PLAYER_SRV_ID = "srv-player"
    const val PLAYER_LEADER_TITLE = "MercifulLeader"
    const val PLAYER_LEVEL = 60
    const val PLAYER_EXP = 100
    const val FIGHTER_SRV_ID = "srv-fighter-m"
    const val RECON_SRV_ID = "srv-recon-f"
    const val PLAYER_WEP_ID = "deagle-replica"
    const val FIGHTER_WEP_ID = "bladesaw"
    const val RECON_WEP_ID = "fal3"
}



================================================================================
ðŸ“„ FICHIER : src\main\kotlin\core\data\GameDefinition.kt
================================================================================

package core.data

import core.data.assets.*
import core.data.resources.*
import core.model.game.data.GameResources
import io.ktor.util.date.*
import utils.Emoji
import utils.Logger
import java.io.File
import java.util.zip.GZIPInputStream
import javax.xml.parsers.DocumentBuilderFactory
import kotlin.time.Duration.Companion.milliseconds

object GameDefinition {
    val itemsById = mutableMapOf<String, ItemResource>()
    val itemsByIdUppercased = mutableMapOf<String, ItemResource>()
    val itemsByType = mutableMapOf<String, MutableList<ItemResource>>()
    val itemsByLootable = mutableMapOf<String, MutableList<ItemResource>>()

    val buildingsById = mutableMapOf<String, BuildingResource>()
    val buildingsByType = mutableMapOf<String, MutableList<BuildingResource>>()

    val craftingRecipesById = mutableMapOf<String, CraftingResource>()
    val craftingRecipesByType = mutableMapOf<String, MutableList<CraftingResource>>()

    val skillsById = mutableMapOf<String, SkillResource>()

    val effectsById = mutableMapOf<String, EffectResource>()
    val effectTypes = mutableListOf<String>()

    fun initialize() {
        val resourcesToLoad = mapOf(
            "static/game/data/xml/items.xml.gz" to ItemsParser(),
            "static/game/data/xml/buildings.xml.gz" to BuildingsParser(),
            "static/game/data/xml/crafting.xml.gz" to CraftingParser(),
            "static/game/data/xml/skills.xml.gz" to SkillsParser(),
            "static/game/data/xml/effects.xml.gz" to EffectsParser()
        )

        for ((path, parser) in resourcesToLoad) {
            val start = getTimeMillis()
            val file = File(path)

            if (!file.exists()) {
                Logger.warn { "File not found: $path" }
                continue
            }

            GZIPInputStream(file.inputStream()).use {
                val document = DocumentBuilderFactory.newInstance().newDocumentBuilder().parse(it)
                parser.parse(document, this)
            }

            val end = getTimeMillis()
            val resName = path.removePrefix("static/game/data/xml/").removeSuffix(".gz")

            Logger.info { "ðŸ“¦ Finished parsing $resName in ${(end - start).milliseconds}" }
        }
        Logger.info("${Emoji.Gaming} Game resources loaded")
    }

    fun findItem(id: String): ItemResource? {
        return itemsById[id] ?: itemsByIdUppercased[id.uppercase()]
    }

    fun requireItem(idInXml: String): ItemResource {
        return requireNotNull(findItem(idInXml)) { "Items with ID in XML $idInXml is missing from index" }
    }

    fun isResourceItem(idInXml: String): Boolean {
        return requireItem(idInXml).type == "resource"
    }

    fun getMaxStackOfItem(idInXml: String): Int {
        val item = requireItem(idInXml)
        return item.stack
    }

    fun getResourceAmount(idInXml: String): GameResources? {
        val item = requireItem(idInXml)
        if (item.type != "resource") return null
        return item.resources
    }

    fun makeBuildingFromId(id: String): BuildingResource {
        return requireNotNull(buildingsById[id]) { "Building with ID $id is missing from index" }
    }

    fun findBuilding(id: String): BuildingResource? {
        return buildingsById[id]
    }

    fun requireBuilding(id: String): BuildingResource {
        return requireNotNull(findBuilding(id)) { "Building with ID $id is missing from index" }
    }

    fun findCraftingRecipe(id: String): CraftingResource? {
        return craftingRecipesById[id]
    }

    fun requireCraftingRecipe(id: String): CraftingResource {
        return requireNotNull(findCraftingRecipe(id)) { "Crafting recipe with ID $id is missing from index" }
    }

    fun findSkill(id: String): SkillResource? {
        return skillsById[id]
    }

    fun requireSkill(id: String): SkillResource {
        return requireNotNull(findSkill(id)) { "Skill with ID $id is missing from index" }
    }

    fun findEffect(id: String): EffectResource? {
        return effectsById[id]
    }

    fun requireEffect(id: String): EffectResource {
        return requireNotNull(findEffect(id)) { "Effect with ID $id is missing from index" }
    }
}



================================================================================
ðŸ“„ FICHIER : src\main\kotlin\core\data\PlayerLoginState.kt
================================================================================

package core.data

import core.model.game.data.GameResources
import core.model.game.data.Survivor
import kotlinx.serialization.Serializable

/**
 * Player login state is needed for [socket.handler.JoinHandler] result
 *
 * Structure still empty and assumption. See Network.as onGameReady and onPlayerDataLoaded
 */
@Serializable
data class PlayerLoginState(
    // from Network.as onGameReady
    val settings: Map<String, String> = emptyMap(),
    val news: Map<String, String> = emptyMap(), // NewsArticle object
    val sales: List<String> = emptyList(), // assigned to sales category
    val allianceWinnings: Map<String, String> = emptyMap(),
    val recentPVPList: List<String> = emptyList(),

    // From Network.as onPlayerDataLoaded
    val invsize: Int,
    val upgrades: String = "", // base64 encoded string
    val allianceId: String? = null,
    val allianceTag: String? = null,
    val longSession: Boolean = false, // if true: this will prompt captcha question in-game
    val leveledUp: Boolean = false,
    val promos: List<String> = emptyList(),
    val promoSale: String? = null,
    val dealItem: String? = null,
    val leaderResets: Int = 0,
    val unequipItemBinds: List<String> = emptyList(),
    val globalStats: Map<String, List<String>> = mapOf(
        "idList" to emptyList()
    ),

    // from PlayerData.as updateState
    // used to update PlayerData state when user was offline (e.g., depleting water or food)
    val resources: GameResources? = null,
    val survivors: List<Survivor>? = null,
    val tasks: List<String>? = null,    // likely task id
    val missions: List<String>? = null, // likely mission id
    val bountyCap: Int? = null,
    val bountyCapTimestamp: Long? = null,
    val research: Map<String, Int>? = null,
) {
    companion object {
        fun admin(): PlayerLoginState {
            return PlayerLoginState(
                invsize = 3000
            )
        }

    }
}



================================================================================
ðŸ“„ FICHIER : src\main\kotlin\core\data\parser\AlliancesParser.kt
================================================================================

package core.data.assets

import core.data.GameDefinition
import org.w3c.dom.Document

class AlliancesParser() : GameResourcesParser {
    override fun parse(doc: Document, gameDefinition: GameDefinition) {

    }
}



================================================================================
ðŸ“„ FICHIER : src\main\kotlin\core\data\parser\ArenasParser.kt
================================================================================

package core.data.assets

import core.data.GameDefinition
import org.w3c.dom.Document

class ArenasParser() : GameResourcesParser {
    override fun parse(doc: Document, gameDefinition: GameDefinition) {

    }
}



================================================================================
ðŸ“„ FICHIER : src\main\kotlin\core\data\parser\AttireParser.kt
================================================================================

package core.data.assets

import core.data.GameDefinition
import org.w3c.dom.Document

class AttireParser() : GameResourcesParser {
    override fun parse(doc: Document, gameDefinition: GameDefinition) {

    }
}



================================================================================
ðŸ“„ FICHIER : src\main\kotlin\core\data\parser\BadwordsParser.kt
================================================================================

package core.data.assets

import core.data.GameDefinition
import org.w3c.dom.Document

class BadwordsParser() : GameResourcesParser {
    override fun parse(doc: Document, gameDefinition: GameDefinition) {

    }
}



================================================================================
ðŸ“„ FICHIER : src\main\kotlin\core\data\parser\BuildingsParser.kt
================================================================================

package core.data.assets

import core.data.GameDefinition
import core.data.resources.*
import core.model.game.data.GameResources
import org.w3c.dom.Document
import org.w3c.dom.Element
import org.w3c.dom.NodeList

class BuildingsParser : GameResourcesParser {
    override fun parse(doc: Document, gameDefinition: GameDefinition) {
        val items = doc.getElementsByTagName("item")

        for (i in 0 until items.length) {
            val itemElement = items.item(i) as? Element ?: continue
            val building = parseBuilding(itemElement)

            gameDefinition.buildingsById[building.id] = building
            gameDefinition.buildingsByType.getOrPut(building.type) { mutableListOf() }.add(building)
        }
    }

    private fun parseBuilding(element: Element): BuildingResource {
        val id = element.getAttribute("id")
        val type = element.getAttribute("type")
        val max = element.getAttribute("max").toIntOrNull() ?: 1
        val indoor = element.getAttribute("indoor") == "1"
        val outdoor = element.getAttribute("outdoor") == "1"
        val scav = element.getAttribute("scav") == "1"
        val assignable = element.getAttribute("assignable") == "1"
        val destroy = element.getAttribute("destroy") == "1"
        val connect = element.getAttribute("connect") == "1"

        val size = parseBuildingSize(element)
        val model = getChildElementText(element, "mdl", "uri")
        val damagedModel = getChildElementText(element, "damaged_mdl", "uri")
        val image = getChildElementText(element, "img", "uri")
        val health = getChildElementText(element, "health")?.toIntOrNull()
        val sounds = parseBuildingSounds(element)
        val resources = parseBuildingResources(element)
        val resourceMultiplier = element.getElementsByTagName("res").let { resList ->
            if (resList.length > 0) {
                (resList.item(0) as? Element)?.getAttribute("m")?.toDoubleOrNull() ?: 1.0
            } else 1.0
        }
        val craft = parseList(element, "craft")
        val store = getChildElementText(element, "store")
        val cover = getChildElementText(element, "cover")?.toIntOrNull()
        val assignPositions = parseAssignPositions(element)
        val levels = parseBuildingLevels(element)

        return BuildingResource(
            id = id,
            type = type,
            max = max,
            indoor = indoor,
            outdoor = outdoor,
            scav = scav,
            assignable = assignable,
            destroy = destroy,
            connect = connect,
            size = size,
            model = model,
            damagedModel = damagedModel,
            image = image,
            health = health,
            sounds = sounds,
            resources = resources,
            resourceMultiplier = resourceMultiplier,
            craft = craft,
            store = store,
            cover = cover,
            assignPositions = assignPositions,
            levels = levels
        )
    }

    private fun parseBuildingSize(element: Element): BuildingSize {
        val sizeElements = element.getElementsByTagName("size")
        if (sizeElements.length > 0) {
            val sizeElement = sizeElements.item(0) as Element
            val x = sizeElement.getAttribute("x").toIntOrNull() ?: 1
            val y = sizeElement.getAttribute("y").toIntOrNull() ?: 1
            return BuildingSize(x, y)
        }
        return BuildingSize(1, 1)
    }

    private fun parseBuildingSounds(element: Element): BuildingSounds? {
        val sndElements = element.getElementsByTagName("snd")
        if (sndElements.length > 0) {
            val sndElement = sndElements.item(0) as Element
            val deaths = parseList(sndElement, "death")
            if (deaths.isNotEmpty()) {
                return BuildingSounds(death = deaths)
            }
        }
        return null
    }

    private fun parseBuildingResources(element: Element): GameResources? {
        val resElements = element.getElementsByTagName("res")
        if (resElements.length == 0) return null

        val resContainer = resElements.item(0) as? Element ?: return null
        val resourceChildren = resContainer.childNodes

        var wood = 0
        var metal = 0
        var cloth = 0
        var water = 0
        var food = 0
        var ammunition = 0
        var cash = 0

        for (i in 0 until resourceChildren.length) {
            val node = resourceChildren.item(i)
            if (node is Element && node.tagName == "res") {
                val resId = node.getAttribute("id")
                val amount = node.textContent.trim().toIntOrNull() ?: 0

                when (resId) {
                    "wood" -> wood = amount
                    "metal" -> metal = amount
                    "cloth" -> cloth = amount
                    "water" -> water = amount
                    "food" -> food = amount
                    "ammunition" -> ammunition = amount
                    "cash" -> cash = amount
                }
            }
        }

        if (wood == 0 && metal == 0 && cloth == 0 && water == 0 && food == 0 && ammunition == 0 && cash == 0) {
            return null
        }

        return GameResources(
            wood = wood,
            metal = metal,
            cloth = cloth,
            water = water,
            food = food,
            ammunition = ammunition,
            cash = cash
        )
    }

    private fun parseAssignPositions(element: Element): List<BuildingAssignPosition> {
        val positions = mutableListOf<BuildingAssignPosition>()
        val assignElements = element.getElementsByTagName("assign")

        for (i in 0 until assignElements.length) {
            val assignElement = assignElements.item(i) as? Element ?: continue
            val x = assignElement.getAttribute("x").toIntOrNull() ?: 0
            val y = assignElement.getAttribute("y").toIntOrNull() ?: 0
            positions.add(BuildingAssignPosition(x, y))
        }

        return positions
    }

    private fun parseBuildingLevels(element: Element): List<BuildingLevel> {
        val levels = mutableListOf<BuildingLevel>()
        val lvlElements = element.getElementsByTagName("lvl")

        for (i in 0 until lvlElements.length) {
            val lvlElement = lvlElements.item(i) as? Element ?: continue
            val number = lvlElement.getAttribute("n").toIntOrNull() ?: i

            val cover = getChildElementText(lvlElement, "cover")?.toIntOrNull()
            val xp = getChildElementText(lvlElement, "xp")?.toIntOrNull()
            val time = getChildElementText(lvlElement, "time")?.toIntOrNull()
            val model = getChildElementText(lvlElement, "mdl", "uri")
            val image = getChildElementText(lvlElement, "img", "uri")
            val comfort = getChildElementText(lvlElement, "comfort")?.toIntOrNull()
            val security = getChildElementText(lvlElement, "security")?.toIntOrNull()
            val capacity = getChildElementText(lvlElement, "cap")?.toIntOrNull()
            val maxUpgradeLevel = getChildElementText(lvlElement, "max_upgrade_level")?.toIntOrNull()
            val production = parseBuildingProduction(lvlElement)
            val requirements = parseBuildingRequirements(lvlElement)
            val items = parseBuildingLevelItems(lvlElement)

            levels.add(
                BuildingLevel(
                    number = number,
                    cover = cover,
                    xp = xp,
                    time = time,
                    model = model,
                    image = image,
                    comfort = comfort,
                    security = security,
                    capacity = capacity,
                    maxUpgradeLevel = maxUpgradeLevel,
                    production = production,
                    requirements = requirements,
                    items = items
                )
            )
        }

        return levels
    }

    private fun parseBuildingProduction(element: Element): BuildingProduction? {
        val prodElements = element.getElementsByTagName("prod")
        if (prodElements.length == 0) return null

        val prodElement = prodElements.item(0) as Element
        val rate = getChildElementText(prodElement, "rate")?.toDoubleOrNull()
        val cap = getChildElementText(prodElement, "cap")?.toIntOrNull()
        val capacity = getChildElementText(prodElement, "capacity")?.toIntOrNull()

        return BuildingProduction(rate, cap, capacity)
    }

    private fun parseBuildingRequirements(element: Element): BuildingRequirements? {
        val reqElements = element.getElementsByTagName("req")
        if (reqElements.length == 0) return null

        val reqElement = reqElements.item(0) as Element
        val buildings = mutableListOf<BuildingRequirement>()
        val items = mutableListOf<ItemRequirement>()
        var level: Int? = null

        val children = reqElement.childNodes
        for (i in 0 until children.length) {
            val child = children.item(i)
            if (child !is Element) continue

            when (child.tagName) {
                "bld" -> {
                    val id = child.getAttribute("id")
                    val lvl = child.getAttribute("lvl").toIntOrNull() ?: 0
                    val qty = child.textContent.trim().toIntOrNull() ?: 1
                    buildings.add(BuildingRequirement(id, lvl, qty))
                }
                "itm" -> {
                    val id = child.getAttribute("id")
                    val qty = child.textContent.trim().toIntOrNull() ?: 1
                    items.add(ItemRequirement(id, qty))
                }
                "lvl" -> {
                    level = child.textContent.trim().toIntOrNull()
                }
            }
        }

        if (buildings.isEmpty() && items.isEmpty() && level == null) return null

        return BuildingRequirements(buildings, items, level)
    }

    private fun parseBuildingLevelItems(element: Element): List<BuildingLevelItem> {
        val levelItems = mutableListOf<BuildingLevelItem>()
        val itemsElements = element.getElementsByTagName("items")

        if (itemsElements.length == 0) return levelItems

        val itemsElement = itemsElements.item(0) as Element
        val itmElements = itemsElement.getElementsByTagName("itm")

        for (i in 0 until itmElements.length) {
            val itmElement = itmElements.item(i) as? Element ?: continue
            val type = itmElement.getAttribute("type")
            val lvl = itmElement.getAttribute("l").toIntOrNull() ?: 0
            val qty = itmElement.getAttribute("q").toIntOrNull() ?: 1
            val mod1 = itmElement.getAttribute("m1").takeIf { it.isNotBlank() }

            levelItems.add(BuildingLevelItem(type, lvl, qty, mod1))
        }

        return levelItems
    }

    private fun parseList(element: Element, tagName: String): List<String> {
        val list = mutableListOf<String>()
        val elements = element.getElementsByTagName(tagName)

        for (i in 0 until elements.length) {
            val el = elements.item(i) as? Element ?: continue
            val text = el.textContent.trim()
            if (text.isNotBlank()) {
                list.add(text)
            }
        }

        return list
    }

    private fun getChildElementText(element: Element, tagName: String, attribute: String? = null): String? {
        val elements = element.getElementsByTagName(tagName)
        if (elements.length == 0) return null

        val el = elements.item(0) as? Element ?: return null

        return if (attribute != null) {
            el.getAttribute(attribute).takeIf { it.isNotBlank() }
        } else {
            el.textContent.trim().takeIf { it.isNotBlank() }
        }
    }
}



================================================================================
ðŸ“„ FICHIER : src\main\kotlin\core\data\parser\ConfigParser.kt
================================================================================

package core.data.assets

import core.data.GameDefinition
import org.w3c.dom.Document

class ConfigParser() : GameResourcesParser {
    override fun parse(doc: Document, gameDefinition: GameDefinition) {

    }
}



================================================================================
ðŸ“„ FICHIER : src\main\kotlin\core\data\parser\CraftingParser.kt
================================================================================

package core.data.assets

import core.data.GameDefinition
import core.data.resources.*
import org.w3c.dom.Document
import org.w3c.dom.Element

class CraftingParser : GameResourcesParser {
    override fun parse(doc: Document, gameDefinition: GameDefinition) {
        val schematics = doc.getElementsByTagName("schem")

        for (i in 0 until schematics.length) {
            val schemElement = schematics.item(i) as? Element ?: continue
            val recipe = parseCraftingRecipe(schemElement)

            gameDefinition.craftingRecipesById[recipe.id] = recipe
            gameDefinition.craftingRecipesByType.getOrPut(recipe.type) { mutableListOf() }.add(recipe)
        }
    }

    private fun parseCraftingRecipe(element: Element): CraftingResource {
        val id = element.getAttribute("id")
        val type = element.getAttribute("type")

        val limitElement = element.getElementsByTagName("limit").item(0) as? Element
        val limited = limitElement != null
        val limitStart = limitElement?.let { getChildElementText(it, "start") }
        val limitEnd = limitElement?.let { getChildElementText(it, "end") }

        val result = parseCraftingResult(element)
        val recipe = parseRecipe(element)
        val cost = getChildElementText(element, "cost")?.toIntOrNull() ?: 0

        return CraftingResource(id, type, limited, limitStart, limitEnd, result, recipe, cost)
    }

    private fun parseCraftingResult(element: Element): CraftingResult {
        val itmElements = element.getElementsByTagName("itm")
        if (itmElements.length > 0) {
            val itmElement = itmElements.item(0) as Element
            val type = itmElement.getAttribute("type")
            val level = itmElement.getAttribute("l").toIntOrNull() ?: 0
            return CraftingResult(type, level)
        }
        return CraftingResult("", 0)
    }

    private fun parseRecipe(element: Element): CraftingRecipe {
        val recipeElements = element.getElementsByTagName("recipe")
        if (recipeElements.length == 0) return CraftingRecipe()

        val recipeElement = recipeElements.item(0) as Element
        val items = mutableListOf<CraftingIngredient>()
        val buildings = mutableListOf<BuildingRequirement>()

        val children = recipeElement.childNodes
        for (i in 0 until children.length) {
            val child = children.item(i)
            if (child !is Element) continue

            when (child.tagName) {
                "itm" -> {
                    val id = child.getAttribute("id")
                    val qty = child.textContent.trim().toIntOrNull() ?: 1
                    items.add(CraftingIngredient(id, qty))
                }
                "bld" -> {
                    val id = child.getAttribute("id")
                    val lvl = child.getAttribute("lvl").toIntOrNull() ?: 0
                    buildings.add(BuildingRequirement(id, lvl))
                }
            }
        }

        return CraftingRecipe(items, buildings)
    }

    private fun getChildElementText(element: Element, tagName: String): String? {
        val elements = element.getElementsByTagName(tagName)
        if (elements.length == 0) return null

        val el = elements.item(0) as? Element ?: return null
        return el.textContent.trim().takeIf { it.isNotBlank() }
    }
}



================================================================================
ðŸ“„ FICHIER : src\main\kotlin\core\data\parser\EffectsParser.kt
================================================================================

package core.data.assets

import core.data.GameDefinition
import core.data.resources.EffectResource
import org.w3c.dom.Document
import org.w3c.dom.Element

class EffectsParser : GameResourcesParser {
    override fun parse(doc: Document, gameDefinition: GameDefinition) {
        val effects = doc.getElementsByTagName("effect")

        for (i in 0 until effects.length) {
            val effectElement = effects.item(i) as? Element ?: continue
            val effect = parseEffect(effectElement)

            gameDefinition.effectsById[effect.id] = effect
        }

        val types = doc.getElementsByTagName("types")
        if (types.length > 0) {
            val typesElement = types.item(0) as Element
            val typesList = typesElement.textContent.split(',').map { it.trim() }
            gameDefinition.effectTypes.addAll(typesList)
        }
    }

    private fun parseEffect(element: Element): EffectResource {
        val id = element.getAttribute("id")
        val icon = getChildElementText(element, "icon", "uri")
        val image = getChildElementText(element, "img", "uri")
        val group = getChildElementText(element, "group")
        val find = element.getAttribute("find").toIntOrNull() ?: 1

        return EffectResource(id, icon, image, group, find)
    }

    private fun getChildElementText(element: Element, tagName: String, attribute: String? = null): String? {
        val elements = element.getElementsByTagName(tagName)
        if (elements.length == 0) return null

        val el = elements.item(0) as? Element ?: return null

        return if (attribute != null) {
            el.getAttribute(attribute).takeIf { it.isNotBlank() }
        } else {
            el.textContent.trim().takeIf { it.isNotBlank() }
        }
    }
}



================================================================================
ðŸ“„ FICHIER : src\main\kotlin\core\data\parser\GameResourcesParser.kt
================================================================================

package core.data.assets

import core.data.GameDefinition
import org.w3c.dom.Document

/**
 * Parser for the game XML resources (e.g., `items.xml`, `zombies.xml`)
 *
 * This is used to create code level representation from the game's data.
 *
 * As an example, [ItemsParser] reads the `items.xml` and depending on the item type
 * (e.g., `type="weapon"`, `type="junk"`), it chooses subparser (i.e., [WeaponItemParser])
 * and creates the corresponding [core.items.model.Item] object.
 */
interface GameResourcesParser {
    fun parse(doc: Document, gameDefinition: GameDefinition)
}



================================================================================
ðŸ“„ FICHIER : src\main\kotlin\core\data\parser\HumanEnemiesParser.kt
================================================================================

package core.data.assets

import core.data.GameDefinition
import org.w3c.dom.Document

class HumanEnemiesParser() : GameResourcesParser {
    override fun parse(doc: Document, gameDefinition: GameDefinition) {

    }
}



================================================================================
ðŸ“„ FICHIER : src\main\kotlin\core\data\parser\InjuryParser.kt
================================================================================

package core.data.assets

import core.data.GameDefinition
import org.w3c.dom.Document

class InjuryParser() : GameResourcesParser {
    override fun parse(doc: Document, gameDefinition: GameDefinition) {

    }
}



================================================================================
ðŸ“„ FICHIER : src\main\kotlin\core\data\parser\ItemModsParser.kt
================================================================================

package core.data.assets

import core.data.GameDefinition
import org.w3c.dom.Document

class ItemModsParser() : GameResourcesParser {
    override fun parse(doc: Document, gameDefinition: GameDefinition) {

    }
}



================================================================================
ðŸ“„ FICHIER : src\main\kotlin\core\data\parser\ItemsParser.kt
================================================================================

package core.data.assets

import core.data.GameDefinition
import core.data.resources.*
import core.model.game.data.GameResources
import org.w3c.dom.Document
import org.w3c.dom.Element

class ItemsParser : GameResourcesParser {
    override fun parse(doc: Document, gameDefinition: GameDefinition) {
        val items = doc.getElementsByTagName("item")

        for (i in 0 until items.length) {
            val itemNode = items.item(i) as? Element ?: continue
            val item = parseItem(itemNode)

            gameDefinition.itemsById[item.id] = item
            gameDefinition.itemsByIdUppercased[item.id.uppercase()] = item
            gameDefinition.itemsByType.getOrPut(item.type) { mutableListOf() }.add(item)

            for (loc in item.lootLocations) {
                gameDefinition.itemsByLootable.getOrPut(loc) { mutableListOf() }.add(item)
            }
        }
    }

    private fun parseItem(element: Element): ItemResource {
        val id = element.getAttribute("id")
        val type = element.getAttribute("type")
        val quality = element.getAttribute("quality").takeIf { it.isNotBlank() }
        val rarity = element.getAttribute("rarity").toDoubleOrNull()
        val image = getChildElementText(element, "img", "uri")
        val model = getChildElementText(element, "mdl", "uri")
        val levelMin = getChildElementText(element, "lvl_min")?.toIntOrNull()
        val levelMax = getChildElementText(element, "lvl_max")?.toIntOrNull()
        val quantityMin = getChildElementText(element, "qnt_min")?.toIntOrNull()
        val quantityMax = getChildElementText(element, "qnt_max")?.toIntOrNull()
        val stack = getChildElementText(element, "stack")?.toIntOrNull() ?: 1
        val lootLocations = element.getAttribute("locs")
            .split(',')
            .map { it.trim() }
            .filter { it.isNotBlank() }
        val resources = parseItemResources(element)
        val kit = parseUpgradeKit(element)
        val weapon = parseWeapon(element)
        val gear = parseGear(element)

        return ItemResource(
            id = id,
            type = type,
            quality = quality,
            rarity = rarity,
            image = image,
            model = model,
            levelMin = levelMin,
            levelMax = levelMax,
            quantityMin = quantityMin,
            quantityMax = quantityMax,
            stack = stack,
            lootLocations = lootLocations,
            resources = resources,
            kit = kit,
            weapon = weapon,
            gear = gear
        )
    }

    private fun parseItemResources(element: Element): GameResources? {
        val resElements = element.getElementsByTagName("res")
        if (resElements.length == 0) return null

        val resContainer = resElements.item(0) as? Element ?: return null
        val resourceChildren = resContainer.childNodes

        var wood = 0
        var metal = 0
        var cloth = 0
        var water = 0
        var food = 0
        var ammunition = 0
        var cash = 0

        for (i in 0 until resourceChildren.length) {
            val node = resourceChildren.item(i)
            if (node is Element && node.tagName == "res") {
                val resId = node.getAttribute("id")
                val amount = node.textContent.trim().toIntOrNull() ?: 0

                when (resId) {
                    "wood" -> wood = amount
                    "metal" -> metal = amount
                    "cloth" -> cloth = amount
                    "water" -> water = amount
                    "food" -> food = amount
                    "ammunition" -> ammunition = amount
                    "cash" -> cash = amount
                }
            }
        }

        if (wood == 0 && metal == 0 && cloth == 0 && water == 0 && food == 0 && ammunition == 0 && cash == 0) {
            return null
        }

        return GameResources(
            wood = wood,
            metal = metal,
            cloth = cloth,
            water = water,
            food = food,
            ammunition = ammunition,
            cash = cash
        )
    }

    private fun parseUpgradeKit(element: Element): UpgradeKit? {
        val kitElements = element.getElementsByTagName("kit")
        if (kitElements.length == 0) return null

        val kitElement = kitElements.item(0) as Element
        val itemLevelMin = getChildElementText(kitElement, "itm_lvl_min")?.toIntOrNull() ?: 0
        val itemLevelMax = getChildElementText(kitElement, "itm_lvl_max")?.toIntOrNull() ?: 0
        val maxUpgradeChance = getChildElementText(kitElement, "max_upgrade_chance")?.toDoubleOrNull() ?: 0.0

        return UpgradeKit(itemLevelMin, itemLevelMax, maxUpgradeChance)
    }

    private fun parseWeapon(element: Element): WeaponData? {
        val weapElements = element.getElementsByTagName("weap")
        if (weapElements.length == 0) return null

        val weapElement = weapElements.item(0) as Element
        val weaponClass = getChildElementText(weapElement, "cls")
        val weaponType = parseList(weapElement, "type")
        val animation = getChildElementText(weapElement, "anim")
        val swingAnimations = parseSwingAnimations(weapElement)
        val damageMin = getChildElementText(weapElement, "dmg_min")?.toDoubleOrNull()
        val damageMax = getChildElementText(weapElement, "dmg_max")?.toDoubleOrNull()
        val damageLevelMultiplier = weapElement.getElementsByTagName("dmg_min").let { elements ->
            if (elements.length > 0) {
                (elements.item(0) as? Element)?.getAttribute("lvl")?.toDoubleOrNull()
            } else null
        }
        val rate = getChildElementText(weapElement, "rate")?.toDoubleOrNull()
        val range = getChildElementText(weapElement, "rng")?.toDoubleOrNull()
        val capacity = getChildElementText(weapElement, "cap")?.toIntOrNull()
        val accuracy = getChildElementText(weapElement, "acc")?.toDoubleOrNull()
        val reloadTime = getChildElementText(weapElement, "rldtime")?.toDoubleOrNull()
        val damageToBuild = getChildElementText(weapElement, "dmg_bld")?.toDoubleOrNull()
        val knockback = getChildElementText(weapElement, "knock")?.toDoubleOrNull()
        val sounds = parseWeaponSounds(weapElement)

        return WeaponData(
            weaponClass = weaponClass,
            weaponType = weaponType,
            animation = animation,
            swingAnimations = swingAnimations,
            damageMin = damageMin,
            damageMax = damageMax,
            damageLevelMultiplier = damageLevelMultiplier,
            rate = rate,
            range = range,
            capacity = capacity,
            accuracy = accuracy,
            reloadTime = reloadTime,
            damageToBuild = damageToBuild,
            knockback = knockback,
            sounds = sounds
        )
    }

    private fun parseSwingAnimations(element: Element): List<String> {
        val swingElements = element.getElementsByTagName("swing")
        if (swingElements.length == 0) return emptyList()

        val swingElement = swingElements.item(0) as Element
        return parseList(swingElement, "anim")
    }

    private fun parseWeaponSounds(element: Element): WeaponSounds? {
        val sndElements = element.getElementsByTagName("snd")
        if (sndElements.length == 0) return null

        val sndElement = sndElements.item(0) as Element
        val hit = parseList(sndElement, "hit")
        val fire = parseList(sndElement, "fire")
        val reload = parseList(sndElement, "reload")

        if (hit.isEmpty() && fire.isEmpty() && reload.isEmpty()) return null

        return WeaponSounds(hit, fire, reload)
    }

    private fun parseGear(element: Element): GearData? {
        val gearElements = element.getElementsByTagName("gear")
        if (gearElements.length == 0) return null

        val gearElement = gearElements.item(0) as Element
        val slot = getChildElementText(gearElement, "slot")
        val armor = getChildElementText(gearElement, "armor")?.toDoubleOrNull()
        val storage = getChildElementText(gearElement, "storage")?.toIntOrNull()

        return GearData(slot, armor, storage)
    }

    private fun parseList(element: Element, tagName: String): List<String> {
        val list = mutableListOf<String>()
        val elements = element.getElementsByTagName(tagName)

        for (i in 0 until elements.length) {
            val el = elements.item(i) as? Element ?: continue
            val text = el.textContent.trim()
            if (text.isNotBlank()) {
                list.add(text)
            }
        }

        return list
    }

    private fun getChildElementText(element: Element, tagName: String, attribute: String? = null): String? {
        val elements = element.getElementsByTagName(tagName)
        if (elements.length == 0) return null

        val el = elements.item(0) as? Element ?: return null

        return if (attribute != null) {
            el.getAttribute(attribute).takeIf { it.isNotBlank() }
        } else {
            el.textContent.trim().takeIf { it.isNotBlank() }
        }
    }
}



================================================================================
ðŸ“„ FICHIER : src\main\kotlin\core\data\parser\QuestsGlobalParser.kt
================================================================================

package core.data.assets

import core.data.GameDefinition
import org.w3c.dom.Document

class QuestsGlobalParser() : GameResourcesParser {
    override fun parse(doc: Document, gameDefinition: GameDefinition) {

    }
}



================================================================================
ðŸ“„ FICHIER : src\main\kotlin\core\data\parser\QuestsParser.kt
================================================================================

package core.data.assets

import core.data.GameDefinition
import org.w3c.dom.Document

class QuestsParser() : GameResourcesParser {
    override fun parse(doc: Document, gameDefinition: GameDefinition) {

    }
}



================================================================================
ðŸ“„ FICHIER : src\main\kotlin\core\data\parser\RaidsParser.kt
================================================================================

package core.data.assets

import core.data.GameDefinition
import org.w3c.dom.Document

class RaidsParser() : GameResourcesParser {
    override fun parse(doc: Document, gameDefinition: GameDefinition) {

    }
}



================================================================================
ðŸ“„ FICHIER : src\main\kotlin\core\data\parser\SkillsParser.kt
================================================================================

package core.data.assets

import core.data.GameDefinition
import core.data.resources.SkillLevel
import core.data.resources.SkillResource
import org.w3c.dom.Document
import org.w3c.dom.Element

class SkillsParser : GameResourcesParser {
    override fun parse(doc: Document, gameDefinition: GameDefinition) {
        val skills = doc.getElementsByTagName("skill")

        for (i in 0 until skills.length) {
            val skillElement = skills.item(i) as? Element ?: continue
            val skill = parseSkill(skillElement)

            gameDefinition.skillsById[skill.id] = skill
        }
    }

    private fun parseSkill(element: Element): SkillResource {
        val id = element.getAttribute("id")
        val levels = parseSkillLevels(element)

        return SkillResource(id, levels)
    }

    private fun parseSkillLevels(element: Element): List<SkillLevel> {
        val levels = mutableListOf<SkillLevel>()
        val lvlElements = element.getElementsByTagName("lvl")

        for (i in 0 until lvlElements.length) {
            val lvlElement = lvlElements.item(i) as? Element ?: continue
            val xp = lvlElement.getAttribute("xp").toIntOrNull() ?: 0
            val craftXp = getChildElementText(lvlElement, "craft_xp")?.toIntOrNull()
            val craftCost = getChildElementText(lvlElement, "craft_cost")?.toIntOrNull()

            levels.add(SkillLevel(i, xp, craftXp, craftCost))
        }

        return levels
    }

    private fun getChildElementText(element: Element, tagName: String): String? {
        val elements = element.getElementsByTagName(tagName)
        if (elements.length == 0) return null

        val el = elements.item(0) as? Element ?: return null
        return el.textContent.trim().takeIf { it.isNotBlank() }
    }
}



================================================================================
ðŸ“„ FICHIER : src\main\kotlin\core\data\parser\StreetStructsParser.kt
================================================================================

package core.data.assets

import core.data.GameDefinition
import org.w3c.dom.Document

class StreetStructsParser() : GameResourcesParser {
    override fun parse(doc: Document, gameDefinition: GameDefinition) {

    }
}



================================================================================
ðŸ“„ FICHIER : src\main\kotlin\core\data\parser\SurvivorParser.kt
================================================================================

package core.data.assets

import core.data.GameDefinition
import org.w3c.dom.Document

class SurvivorParser() : GameResourcesParser {
    override fun parse(doc: Document, gameDefinition: GameDefinition) {

    }
}



================================================================================
ðŸ“„ FICHIER : src\main\kotlin\core\data\parser\VehicleNamesParser.kt
================================================================================

package core.data.assets

import core.data.GameDefinition
import org.w3c.dom.Document

class VehicleNamesParser() : GameResourcesParser {
    override fun parse(doc: Document, gameDefinition: GameDefinition) {

    }
}



================================================================================
ðŸ“„ FICHIER : src\main\kotlin\core\data\parser\ZombiesParser.kt
================================================================================

package core.data.assets

import core.data.GameDefinition
import org.w3c.dom.Document

class ZombiesParser() : GameResourcesParser {
    override fun parse(doc: Document, gameDefinition: GameDefinition) {

    }
}



================================================================================
ðŸ“„ FICHIER : src\main\kotlin\core\data\resources\BuildingResource.kt
================================================================================

package core.data.resources

import core.model.game.data.GameResources

data class BuildingResource(
    val id: String,
    val type: String,
    val max: Int = 1,
    val indoor: Boolean = false,
    val outdoor: Boolean = false,
    val scav: Boolean = false,
    val assignable: Boolean = false,
    val destroy: Boolean = false,
    val connect: Boolean = false,
    val size: BuildingSize = BuildingSize(1, 1),
    val model: String? = null,
    val damagedModel: String? = null,
    val image: String? = null,
    val health: Int? = null,
    val sounds: BuildingSounds? = null,
    val resources: GameResources? = null,
    val resourceMultiplier: Double = 1.0,
    val craft: List<String> = emptyList(),
    val store: String? = null,
    val cover: Int? = null,
    val assignPositions: List<BuildingAssignPosition> = emptyList(),
    val levels: List<BuildingLevel> = emptyList()
) {
    fun getLevel(levelNumber: Int): BuildingLevel? = levels.getOrNull(levelNumber)

    fun requireLevel(levelNumber: Int): BuildingLevel =
        levels.getOrNull(levelNumber) ?: throw IllegalArgumentException("Level $levelNumber not found for building $id")
}

data class BuildingSize(
    val x: Int,
    val y: Int
)

data class BuildingSounds(
    val death: List<String> = emptyList()
)

data class BuildingAssignPosition(
    val x: Int,
    val y: Int
)

data class BuildingLevel(
    val number: Int,
    val cover: Int? = null,
    val xp: Int? = null,
    val time: Int? = null,
    val model: String? = null,
    val image: String? = null,
    val comfort: Int? = null,
    val security: Int? = null,
    val capacity: Int? = null,
    val maxUpgradeLevel: Int? = null,
    val production: BuildingProduction? = null,
    val requirements: BuildingRequirements? = null,
    val items: List<BuildingLevelItem> = emptyList()
)

data class BuildingProduction(
    val rate: Double? = null,
    val cap: Int? = null,
    val capacity: Int? = null
)

data class BuildingRequirements(
    val buildings: List<BuildingRequirement> = emptyList(),
    val items: List<ItemRequirement> = emptyList(),
    val level: Int? = null
)

data class BuildingRequirement(
    val id: String,
    val level: Int,
    val quantity: Int = 1
)

data class ItemRequirement(
    val id: String,
    val quantity: Int = 1
)

data class BuildingLevelItem(
    val type: String,
    val level: Int,
    val quantity: Int,
    val mod1: String? = null
)



================================================================================
ðŸ“„ FICHIER : src\main\kotlin\core\data\resources\ConfigResource.kt
================================================================================

package core.data.resources

data class ConfigResource(
    val security: SecurityConfig? = null,
    val playerio: PlayerIOConfig? = null,
    val paths: PathsConfig? = null
)

data class SecurityConfig(
    val policies: List<String> = emptyList(),
    val insecure: List<String> = emptyList()
)

data class PlayerIOConfig(
    val gameId: String,
    val connId: String
)

data class PathsConfig(
    val storageUrl: String? = null,
    val saveImageUrl: String? = null,
    val loggerUrl: String? = null,
    val stage3dInfoUrl: String? = null,
    val music: String? = null,
    val allianceUrl: String? = null
)



================================================================================
ðŸ“„ FICHIER : src\main\kotlin\core\data\resources\CraftingResource.kt
================================================================================

package core.data.resources

data class CraftingResource(
    val id: String,
    val type: String,
    val limited: Boolean = false,
    val limitStart: String? = null,
    val limitEnd: String? = null,
    val result: CraftingResult,
    val recipe: CraftingRecipe,
    val cost: Int
)

data class CraftingResult(
    val itemType: String,
    val level: Int
)

data class CraftingRecipe(
    val items: List<CraftingIngredient> = emptyList(),
    val buildings: List<BuildingRequirement> = emptyList()
)

data class CraftingIngredient(
    val id: String,
    val quantity: Int
)



================================================================================
ðŸ“„ FICHIER : src\main\kotlin\core\data\resources\EffectResource.kt
================================================================================

package core.data.resources

data class EffectResource(
    val id: String,
    val icon: String? = null,
    val image: String? = null,
    val group: String? = null,
    val find: Int = 1,
    val types: List<String> = emptyList()
)



================================================================================
ðŸ“„ FICHIER : src\main\kotlin\core\data\resources\InjuryResource.kt
================================================================================

package core.data.resources

data class InjuryResource(
    val type: String,
    val causes: List<String> = emptyList(),
    val rarity: Int,
    val locations: List<InjuryLocation> = emptyList()
)

data class InjuryLocation(
    val id: String,
    val severities: List<InjurySeverity> = emptyList()
)

data class InjurySeverity(
    val type: String,
    val combatMelee: Double? = null,
    val combatProjectile: Double? = null,
    val combatImprovised: Double? = null,
    val recipe: List<MedicalIngredient> = emptyList()
)

data class MedicalIngredient(
    val id: String,
    val grade: Int
)

data class SeverityConfig(
    val type: String,
    val max: Int,
    val severityLevels: List<SeverityLevel> = emptyList()
)

data class SeverityLevel(
    val type: String,
    val rarity: Int,
    val cost: Int,
    val level: Int,
    val damage: Double,
    val morale: Int,
    val time: Int
)



================================================================================
ðŸ“„ FICHIER : src\main\kotlin\core\data\resources\ItemResource.kt
================================================================================

package core.data.resources

import core.model.game.data.GameResources

data class ItemResource(
    val id: String,
    val type: String,
    val quality: String? = null,
    val rarity: Double? = null,
    val image: String? = null,
    val model: String? = null,
    val levelMin: Int? = null,
    val levelMax: Int? = null,
    val quantityMin: Int? = null,
    val quantityMax: Int? = null,
    val stack: Int = 1,
    val lootLocations: List<String> = emptyList(),
    val resources: GameResources? = null,
    val kit: UpgradeKit? = null,
    val weapon: WeaponData? = null,
    val gear: GearData? = null
)

data class UpgradeKit(
    val itemLevelMin: Int,
    val itemLevelMax: Int,
    val maxUpgradeChance: Double
)

data class WeaponData(
    val weaponClass: String? = null,
    val weaponType: List<String> = emptyList(),
    val animation: String? = null,
    val swingAnimations: List<String> = emptyList(),
    val damageMin: Double? = null,
    val damageMax: Double? = null,
    val damageLevelMultiplier: Double? = null,
    val rate: Double? = null,
    val range: Double? = null,
    val capacity: Int? = null,
    val accuracy: Double? = null,
    val reloadTime: Double? = null,
    val damageToBuild: Double? = null,
    val knockback: Double? = null,
    val sounds: WeaponSounds? = null
)

data class WeaponSounds(
    val hit: List<String> = emptyList(),
    val fire: List<String> = emptyList(),
    val reload: List<String> = emptyList()
)

data class GearData(
    val slot: String? = null,
    val armor: Double? = null,
    val storage: Int? = null
)



================================================================================
ðŸ“„ FICHIER : src\main\kotlin\core\data\resources\QuestResource.kt
================================================================================

package core.data.resources

data class QuestResource(
    val id: String,
    val type: String,
    val rarity: Int,
    val levelMin: Int,
    val levelMax: Int,
    val min: Int,
    val max: Int,
    val minLevelMultiplier: Double? = null,
    val maxLevelMultiplier: Double? = null,
    val xp: Double,
    val xpLevelMultiplier: Double? = null,
    val morale: Double,
    val moraleLevelMultiplier: Double? = null
)



================================================================================
ðŸ“„ FICHIER : src\main\kotlin\core\data\resources\SkillResource.kt
================================================================================

package core.data.resources

data class SkillResource(
    val id: String,
    val levels: List<SkillLevel> = emptyList()
) {
    fun getLevel(levelNumber: Int): SkillLevel? = levels.getOrNull(levelNumber)

    fun requireLevel(levelNumber: Int): SkillLevel =
        levels.getOrNull(levelNumber) ?: throw IllegalArgumentException("Level $levelNumber not found for skill $id")
}

data class SkillLevel(
    val number: Int,
    val xp: Int,
    val craftXp: Int? = null,
    val craftCost: Int? = null
)



================================================================================
ðŸ“„ FICHIER : src\main\kotlin\core\data\resources\SurvivorResource.kt
================================================================================

package core.data.resources

data class SurvivorArrivalRequirement(
    val food: Int,
    val water: Int,
    val comfort: Int,
    val security: Int,
    val morale: Int,
    val buildingRequirements: List<BuildingRequirement> = emptyList(),
    val cost: Int
)



================================================================================
ðŸ“„ FICHIER : src\main\kotlin\core\data\resources\ZombieResource.kt
================================================================================

package core.data.resources

data class ZombieResource(
    val id: String,
    val type: String,
    val weapon: WeaponData? = null
)

data class ZombieSounds(
    val male: ZombieVoiceSet? = null,
    val female: ZombieVoiceSet? = null,
    val dog: ZombieVoiceSet? = null
)

data class ZombieVoiceSet(
    val alert: List<String> = emptyList(),
    val idle: List<String> = emptyList(),
    val death: List<String> = emptyList(),
    val attack: List<String> = emptyList(),
    val hurt: List<String> = emptyList()
)

data class ZombieLimits(
    val tags: Map<Int, String> = emptyMap()
)



================================================================================
ðŸ“„ FICHIER : src\main\kotlin\core\items\InventoryRepository.kt
================================================================================

package core.items

import core.items.model.Item
import data.collection.Inventory

interface InventoryRepository {
    suspend fun getInventory(playerId: String): Result<Inventory>
    suspend fun updateInventory(playerId: String, updatedInventory: List<Item>): Result<Unit>
    suspend fun updateSchematics(playerId: String, updatedSchematics: ByteArray): Result<Unit>
}



================================================================================
ðŸ“„ FICHIER : src\main\kotlin\core\items\InventoryRepositoryMaria.kt
================================================================================

package core.items

import core.items.model.Item
import data.collection.Inventory
import data.db.InventoryTable
import data.db.suspendedTransactionResult
import org.jetbrains.exposed.sql.Database
import org.jetbrains.exposed.sql.selectAll
import org.jetbrains.exposed.sql.update
import utils.JSON

class InventoryRepositoryMaria(private val database: Database) : InventoryRepository {
    override suspend fun getInventory(playerId: String): Result<Inventory> {
        return database.suspendedTransactionResult {
            InventoryTable
                .selectAll()
                .where { InventoryTable.playerId eq playerId }
                .singleOrNull()
                ?.let { row ->
                    val inventory = JSON.decode(Inventory.serializer(), row[InventoryTable.dataJson])
                    inventory
                } ?: throw NoSuchElementException("getInventory: No Inventory found with id=$playerId")
        }
    }

    override suspend fun updateInventory(
        playerId: String,
        updatedInventory: List<Item>
    ): Result<Unit> {
        return database.suspendedTransactionResult {
            val currentData = InventoryTable
                .selectAll()
                .where { InventoryTable.playerId eq playerId }
                .singleOrNull()
                ?.let { row ->
                    JSON.decode(Inventory.serializer(), row[InventoryTable.dataJson])
                } ?: throw NoSuchElementException("updateInventory: No Inventory found with id=$playerId")

            val updatedData = currentData.copy(inventory = updatedInventory)

            val rowsUpdated = InventoryTable.update({ InventoryTable.playerId eq playerId }) {
                it[dataJson] = JSON.encode(Inventory.serializer(), updatedData)
            }
            if (rowsUpdated == 0) {
                throw IllegalStateException("Failed to update inventory in updateInventory for playerId=$playerId")
            }
        }
    }

    override suspend fun updateSchematics(
        playerId: String,
        updatedSchematics: ByteArray
    ): Result<Unit> {
        return database.suspendedTransactionResult {
            val currentData = InventoryTable
                .selectAll()
                .where { InventoryTable.playerId eq playerId }
                .singleOrNull()
                ?.let { row ->
                    JSON.decode(Inventory.serializer(), row[InventoryTable.dataJson])
                } ?: throw NoSuchElementException("updateSchematics: No Inventory found with id=$playerId")

            val updatedData = currentData.copy(schematics = updatedSchematics)

            val rowsUpdated = InventoryTable.update({ InventoryTable.playerId eq playerId }) {
                it[dataJson] = JSON.encode(Inventory.serializer(), updatedData)
            }
            if (rowsUpdated == 0) {
                throw IllegalStateException("Failed to update inventory in updateSchematics for playerId=$playerId")
            }
        }
    }
}



================================================================================
ðŸ“„ FICHIER : src\main\kotlin\core\items\InventoryService.kt
================================================================================

package core.items

import core.PlayerService
import core.items.model.Item
import utils.LogConfigSocketError
import utils.Logger

class InventoryService(
    private val inventoryRepository: InventoryRepository
) : PlayerService {
    private var inventory = listOf<Item>()
    private var schematics = byteArrayOf()
    private lateinit var playerId: String

    fun getInventory(): List<Item> {
        return inventory
    }

    fun getSchematics(): ByteArray {
        return schematics
    }

    suspend fun updateInventory(
        updateAction: suspend (List<Item>) -> List<Item>
    ): Result<Unit> {
        val updatedInventory = updateAction(this.inventory)
        val result = inventoryRepository.updateInventory(playerId, updatedInventory)
        result.onFailure {
            Logger.error(LogConfigSocketError) { "Error on updateInventory: ${it.message}" }
        }
        result.onSuccess {
            inventory = updatedInventory
        }
        return result
    }

    suspend fun updateSchematics(
        updateAction: suspend (ByteArray) -> ByteArray
    ): Result<Unit> {
        val updatedSchematics = updateAction(schematics)
        val result = inventoryRepository.updateSchematics(playerId, updatedSchematics)
        result.onFailure {
            Logger.error(LogConfigSocketError) { "Error on updateSchematics: ${it.message}" }
        }
        result.onSuccess {
            schematics = updatedSchematics
        }
        return result
    }

    override suspend fun init(playerId: String): Result<Unit> {
        return runCatching {
            this.playerId = playerId
            val inventoryObject = inventoryRepository.getInventory(playerId).getOrThrow()
            inventory = inventoryObject.inventory
            schematics = inventoryObject.schematics
        }
    }

    override suspend fun close(playerId: String): Result<Unit> {
        return Result.success(Unit)
    }
}



================================================================================
ðŸ“„ FICHIER : src\main\kotlin\core\items\ItemFactory.kt
================================================================================

package core.items

import core.data.GameDefinition
import core.data.resources.ItemResource
import core.items.model.Item
import core.items.model.ItemQualityType
import utils.UUID

object ItemFactory {
    fun getRandomItem(): Item {
        return createItemFromResource(res = GameDefinition.itemsById.values.random())
    }

    fun createItemFromId(itemId: String = UUID.new(), idInXML: String): Item {
        val res = GameDefinition.findItem(idInXML)
            ?: throw IllegalArgumentException("Failed creating Item id=$itemId from xml id=$idInXML (xml id not found)")
        return createItemFromResource(itemId, res)
    }

    fun createItemFromResource(itemId: String = UUID.new(), res: ItemResource): Item {
        val baseItem = Item(
            id = itemId,
            type = res.id,
            quality = ItemQualityType.fromString(res.quality ?: "")
        )

        when (res.type) {
            "gear" -> parseGear(res, baseItem)
            "weapon" -> parseWeapon(res, baseItem)
            "clothing" -> parseClothing(res, baseItem)
        }

        return baseItem
    }

    private fun parseGear(res: ItemResource, baseItem: Item) {}
    private fun parseWeapon(res: ItemResource, baseItem: Item) {}
    private fun parseClothing(res: ItemResource, baseItem: Item) {}
}



================================================================================
ðŸ“„ FICHIER : src\main\kotlin\core\items\model\CrateItem.kt
================================================================================

package core.items.model

import kotlinx.serialization.Serializable
import server.handler.save.crate.response.gachaPoolExample

@Serializable
data class CrateItem(
    val type: String,
    val id: String = "",  // uses GUID.create() by default
    val new: Boolean = false,
    val storeId: String = "",
    val level: Int = 0,
    val series: Int = 0,
    val version: Int = 0,
    val contents: List<Item> = gachaPoolExample
)



================================================================================
ðŸ“„ FICHIER : src\main\kotlin\core\items\model\EffectItem.kt
================================================================================

package core.items.model

import kotlinx.serialization.Serializable

@Serializable
data class EffectItem(
    val effect: ByteArray,  // see effect.as for bytearray specification
)



================================================================================
ðŸ“„ FICHIER : src\main\kotlin\core\items\model\Gear.kt
================================================================================

package core.items.model

import core.model.game.data.AttireData
import kotlinx.serialization.Serializable

@Serializable
data class Gear(
    val _attireXMLInvalid: Boolean = false,
    val animType: String = "",
    val attire: List<AttireData> = listOf(),
    val attireXMLList: List<String> = listOf(),  // List<XMLList> actually
    val gearType: UInt = 1u,
    val gearClass: String = "",
    val requiredSurvivorClass: String?,
    val carryLimit: Int = 0,
    val survivorClasses: List<String> = listOf(),
    val weaponClasses: List<String> = listOf(),
    val weaponTypes: UInt = 0u,
    val ammoTypes: UInt = 0u,
    val activeAttributes: ItemAttributes
)



================================================================================
ðŸ“„ FICHIER : src\main\kotlin\core\items\model\GearClass.kt
================================================================================

package core.items.model

import kotlinx.serialization.Serializable

@Serializable
data class GearClass(
    val GLOVES: String = "gloves",
    val GLASSES: String = "glasses",
    val SHOES: String = "shoes",
    val VEST: String = "vest",
    val GRENADE: String = "grenade",
    val EXPLOSIVE_CHARGE: String = "expcharge",
    val STIM: String = "stim"
)



================================================================================
ðŸ“„ FICHIER : src\main\kotlin\core\items\model\GearType.kt
================================================================================

package core.items.model

import kotlinx.serialization.Serializable

@Serializable
@JvmInline
value class GearType(val value: UInt)

object GearType_Constants {
    val UNKNOWN = GearType(0u)
    val PASSIVE = GearType(1u)
    val ACTIVE = GearType(2u)
    val CONSUMABLE = GearType(4u)
    val EXPLOSIVE = GearType(8u)
    val IMPROVISED = GearType(16u)
}



================================================================================
ðŸ“„ FICHIER : src\main\kotlin\core\items\model\Item.kt
================================================================================

@file:OptIn(ExperimentalSerializationApi::class)

package core.items.model

import core.data.GameDefinition
import core.model.game.data.CraftingInfo
import utils.UUID
import kotlinx.serialization.EncodeDefault
import kotlinx.serialization.ExperimentalSerializationApi
import kotlinx.serialization.Serializable
import kotlin.math.min

@Serializable
data class Item(
    // Item has many fields, many of these aren't needed; however,
    // In the client-side, item factory always check whether the fields are present or not
    // If they are, they will use it without checking null (silent NPE is very often here)
    // This is why we shouldn't encode them if we don't intend to specify the field
    @EncodeDefault(EncodeDefault.Mode.NEVER) val id: String = UUID.new(),
    @EncodeDefault(EncodeDefault.Mode.NEVER) val new: Boolean = false,
    @EncodeDefault(EncodeDefault.Mode.NEVER) val storeId: String? = null,
    @EncodeDefault(EncodeDefault.Mode.NEVER) val bought: Boolean = false,
    @EncodeDefault(EncodeDefault.Mode.NEVER) val mod1: String? = null,
    @EncodeDefault(EncodeDefault.Mode.NEVER) val mod2: String? = null,
    @EncodeDefault(EncodeDefault.Mode.NEVER) val mod3: String? = null,
    @EncodeDefault(EncodeDefault.Mode.NEVER) val type: String,
    @EncodeDefault(EncodeDefault.Mode.NEVER) val level: Int = 0,
    @EncodeDefault(EncodeDefault.Mode.NEVER) val qty: UInt = 1u,
    @EncodeDefault(EncodeDefault.Mode.NEVER) val quality: Int? = null,
    @EncodeDefault(EncodeDefault.Mode.NEVER) val bind: UInt? = null,
    @EncodeDefault(EncodeDefault.Mode.NEVER) val tradable: Boolean? = true,
    @EncodeDefault(EncodeDefault.Mode.NEVER) val disposable: Boolean? = true,
    @EncodeDefault(EncodeDefault.Mode.NEVER) val ctrType: UInt? = null,
    @EncodeDefault(EncodeDefault.Mode.NEVER) val ctrVal: Int? = null,
    @EncodeDefault(EncodeDefault.Mode.NEVER) val craft: CraftingInfo? = null,
    @EncodeDefault(EncodeDefault.Mode.NEVER) val name: String? = null,
    @EncodeDefault(EncodeDefault.Mode.NEVER) val specData: ItemBonusStats? = null,
    @EncodeDefault(EncodeDefault.Mode.NEVER) val duplicate: Boolean = false,  // added from deserialize of Inventory
)

fun Item.compactString(): String {
    return "Item(id=${this.id}, type=${this.type})"
}

fun Item.quantityString(): String {
    return "Item(type=${this.type}, qty=${this.qty})"
}

/**
 * Combine two list of items semantically (according to the game definition).
 *
 * It assumes that the [other] list of items are already semantically correct.
 */
fun List<Item>.combineItems(other: List<Item>, gameDefinition: GameDefinition): List<Item> {
    val result = mutableListOf<Item>()
    val alreadyCombined = mutableSetOf<String>()

    for (item in other) {
        val maxStack = gameDefinition.getMaxStackOfItem(item.type)

        // item already hit the max stack, add to result directly
        if (item.qty >= maxStack.toUInt()) {
            result.add(item)
            continue
        }

        // find item of same type and quantity still lower than maximum
        val existingItem = this.find { it.type == item.type && it.qty < maxStack.toUInt() }

        if (existingItem != null && existingItem.canStack(item)) {
            // both item's quantity are guaranteed to be lower than the max stack
            // adding two of them should only produce 2 unit maximum
            // (i.e., 99 + 99 = 198 (100, 98) if max stack = 100)
            val totalQty = existingItem.qty + item.qty

            // add first unit
            result.add(item.copy(qty = min(totalQty, maxStack.toUInt())))

            // add second unit if overflow
            val overflowCounts = totalQty.toInt() - maxStack
            if (overflowCounts > 0) {
                // regenerate UUID as it is a new item
                result.add(item.copy(id = UUID.new(), qty = overflowCounts.toUInt()))
            }
            alreadyCombined.add(existingItem.id)
        } else {
            // either no item is found, each of them are already at maximum amount, or they cannot stack
            // add to result directly
            result.add(item)
        }
    }

    for (item in this) {
        if (!alreadyCombined.contains(item.id)) {
            result.add(item)
        }
    }

    return result
}

fun List<Item>.stackOwnItems(def: GameDefinition): List<Item> {
    if (isEmpty()) return emptyList()

    val stacked = mutableListOf<Item>()

    // Group all items that can stack using a single pass
    val grouped = groupBy { item ->
        "${item.type}|${item.level}|${item.quality}|${item.mod1}|${item.mod2}|${item.mod3}|${item.bind}"
    }

    // For each group, merge and split according to maxStack
    for ((_, group) in grouped) {
        val base = group.first()
        val maxStack = def.getMaxStackOfItem(base.type).toUInt()

        if (maxStack <= 1u) {
            // Non-stackable item, each instance remains unique
            stacked.addAll(group)
            continue
        }

        // Sum quantities and create stacks in one pass
        var remaining = group.sumOf { it.qty.toLong() }.toUInt()
        while (remaining > 0u) {
            val stackQty = minOf(remaining, maxStack)
            stacked.add(base.copy(id = UUID.new(), qty = stackQty, new = true))
            remaining -= stackQty
        }
    }

    return stacked
}

/**
 * Check if two items can be stacked together
 */
fun Item.canStack(other: Item): Boolean {
    return this.type == other.type &&
            this.level == other.level &&
            this.quality == other.quality &&
            this.mod1 == other.mod1 &&
            this.mod2 == other.mod2 &&
            this.mod3 == other.mod3 &&
            this.bind == other.bind
}



================================================================================
ðŸ“„ FICHIER : src\main\kotlin\core\items\model\ItemAttributes.kt
================================================================================

package core.items.model

import kotlinx.serialization.Serializable

@Serializable
data class ItemAttributes(
    val baseValues: Map<String, Map<String, Double>> = mapOf(),
    val modValues: Map<String, Map<String, Double>> = mapOf(),
    val attCaps: Map<String, Map<String, Double>> = mapOf()
)



================================================================================
ðŸ“„ FICHIER : src\main\kotlin\core\items\model\ItemAttributesConstants.kt
================================================================================

package core.items.model

object ItemAttributesConstants {
    const val GEAR = "gear"
    const val SURVIVOR = "srv"
    const val WEAPON = "weap"
    const val CARRY = "carry"
    const val EQUIP = "equip"
    const val INFECTED_KILL_XP = "infected_kill_xp"
    const val SURVIVOR_KILL_XP = "survivor_kill_xp"
    const val HUMAN_KILL_XP = "human_kill_xp"
    const val CLS = "cls"
    const val TYPE = "type"
    const val AMMO = "ammo"
    const val ANIM = "anim"
    const val SND = "snd"
    const val SWING = "swing"
    const val PROJ = "proj"
    const val RLDANIM = "rldanim"
    const val EXP = "exp"
    const val NOISE = "noise"
    const val RATE = "rate"
    const val RLDTIME = "rldtime"
    const val AMMO_COST = "ammo_cost"
    const val INJURY_CHANCE = "injuryChance"
    const val RNG_MIN_EFF = "rng_min_eff"
    const val REVERSE_RATE = "rate"
    const val REVERSE_RLDTIME = "rldtime"
}



================================================================================
ðŸ“„ FICHIER : src\main\kotlin\core\items\model\ItemBindState.kt
================================================================================

package core.items.model

import kotlinx.serialization.Serializable

@Serializable
@JvmInline
value class ItemBindState(val value: UInt)

object ItemBindState_Constants {
    val NotBindable = ItemBindState(0u)
    val OnEquip = ItemBindState(1u)
    val Bound = ItemBindState(2u)
}



================================================================================
ðŸ“„ FICHIER : src\main\kotlin\core\items\model\ItemBonusStats.kt
================================================================================

package core.items.model

import kotlinx.serialization.Serializable

@Serializable
data class ItemBonusStats(
    val stat_srv: Map<String, Double>? = null,
    val stat_weap: Map<String, Double>? = null,
    val stat_gear: Map<String, Double>? = null
)



================================================================================
ðŸ“„ FICHIER : src\main\kotlin\core\items\model\ItemCounterType.kt
================================================================================

package core.items.model

import kotlinx.serialization.Serializable

@Serializable
@JvmInline
value class ItemCounterType(val value: UInt)

object ItemCounterType_Constants {
    val None = ItemCounterType(0u)
    val ZombieKills = ItemCounterType(1u)
    val HumanKills = ItemCounterType(2u)
    val SurvivorKills = ItemCounterType(3u)
}



================================================================================
ðŸ“„ FICHIER : src\main\kotlin\core\items\model\ItemQualityType.kt
================================================================================

package core.items.model

import kotlinx.serialization.Serializable

@Serializable
@JvmInline
value class ItemQualityType(val value: Int) {
    companion object {
        fun fromString(s: String): Int? {
            return when (s) {
                "none" -> -2147483648
                "grey" -> -1
                "white" -> 0
                "green" -> 1
                "blue" -> 2
                "purple" -> 3
                "rare" -> 50
                "unique" -> 51
                "infamous" -> 52
                "premium" -> 100
                else -> null
            }
        }

        fun fromInt(i: Int): String? {
            return when (i) {
                -2147483648 -> "none"
                -1 -> "grey"
                0 -> "white"
                1 -> "green"
                2 -> "blue"
                3 -> "purple"
                50 -> "rare"
                51 -> "unique"
                52 -> "infamous"
                100 -> "premium"
                else -> null
            }
        }
    }
}

object ItemQualityType_Constants {
    val NONE = ItemQualityType(-2147483648)
    val GREY = ItemQualityType(-1)
    val WHITE = ItemQualityType(0)
    val GREEN = ItemQualityType(1)
    val BLUE = ItemQualityType(2)
    val PURPLE = ItemQualityType(3)
    val RARE = ItemQualityType(50)
    val UNIQUE = ItemQualityType(51)
    val INFAMOUS = ItemQualityType(52)
    val PREMIUM = ItemQualityType(100)
}



================================================================================
ðŸ“„ FICHIER : src\main\kotlin\core\items\model\MedicalItem.kt
================================================================================

package core.items.model

import kotlinx.serialization.Serializable

@Serializable
data class MedicalItem(
    val item: Item
)



================================================================================
ðŸ“„ FICHIER : src\main\kotlin\core\items\model\MiscEffectItem.kt
================================================================================

package core.items.model

import kotlinx.serialization.Serializable

@Serializable
data class MiscEffectItem(
    val effectItem: EffectItem
)



================================================================================
ðŸ“„ FICHIER : src\main\kotlin\core\items\model\SchematicItem.kt
================================================================================

package core.items.model

import kotlinx.serialization.Serializable

@Serializable
data class SchematicItem(
    val type: String,
    val schem: String,
    val id: String = "",  // actually default a GUID.create()
    val new: Boolean = false,
    val storeId: String? = null
)



================================================================================
ðŸ“„ FICHIER : src\main\kotlin\core\metadata\PlayerObjectsMetadataRepository.kt
================================================================================

package core.metadata

/**
 * Repository for uncategorized fields in PlayerObjects like nickname, flags
 */
interface PlayerObjectsMetadataRepository {
    suspend fun getPlayerFlags(playerId: String): Result<ByteArray>
    suspend fun updatePlayerFlags(playerId: String, flags: ByteArray): Result<Unit>

    suspend fun getPlayerNickname(playerId: String): Result<String?>
    suspend fun updatePlayerNickname(playerId: String, nickname: String): Result<Unit>

    suspend fun clearNotifications(playerId: String): Result<Unit>
}



================================================================================
ðŸ“„ FICHIER : src\main\kotlin\core\metadata\PlayerObjectsMetadataRepositoryMaria.kt
================================================================================

package core.metadata

import data.collection.PlayerObjects
import data.db.PlayerObjectsTable
import data.db.suspendedTransactionResult
import org.jetbrains.exposed.sql.Database
import org.jetbrains.exposed.sql.selectAll
import org.jetbrains.exposed.sql.update
import utils.JSON

class PlayerObjectsMetadataRepositoryMaria(private val database: Database) : PlayerObjectsMetadataRepository {
    private suspend fun <T> getPlayerObjectsData(playerId: String, transform: (PlayerObjects) -> T): Result<T> {
        return database.suspendedTransactionResult {
            PlayerObjectsTable
                .selectAll()
                .where { PlayerObjectsTable.playerId eq playerId }
                .singleOrNull()
                ?.let { row ->
                    val playerObjects =
                        JSON.decode(PlayerObjects.serializer(), row[PlayerObjectsTable.dataJson])
                    transform(playerObjects)
                } ?: throw NoSuchElementException("getPlayerObjectsData: No PlayerObjects found with id=$playerId")
        }
    }

    private suspend fun updatePlayerObjectsData(
        playerId: String,
        updateAction: (PlayerObjects) -> PlayerObjects
    ): Result<Unit> {
        return database.suspendedTransactionResult {
            val currentRow = PlayerObjectsTable
                .selectAll()
                .where { PlayerObjectsTable.playerId eq playerId }
                .singleOrNull()
                ?: throw NoSuchElementException("updatePlayerObjectsData: No PlayerObjects found with id=$playerId")

            val currentData =
                JSON.decode(PlayerObjects.serializer(), currentRow[PlayerObjectsTable.dataJson])
            val updatedData = updateAction(currentData)

            val rowsUpdated = PlayerObjectsTable.update({ PlayerObjectsTable.playerId eq playerId }) {
                it[dataJson] = JSON.encode(PlayerObjects.serializer(), updatedData)
            }
            if (rowsUpdated == 0) {
                throw IllegalStateException("Failed to update player objects data for playerId=$playerId")
            }
        }
    }

    override suspend fun getPlayerFlags(playerId: String): Result<ByteArray> {
        return getPlayerObjectsData(playerId) { it.flags }
    }

    override suspend fun updatePlayerFlags(playerId: String, flags: ByteArray): Result<Unit> {
        return updatePlayerObjectsData(playerId) { it.copy(flags = flags) }
    }

    override suspend fun getPlayerNickname(playerId: String): Result<String?> {
        return getPlayerObjectsData(playerId) { it.nickname }
    }

    override suspend fun updatePlayerNickname(playerId: String, nickname: String): Result<Unit> {
        return updatePlayerObjectsData(playerId) { it.copy(nickname = nickname) }
    }

    override suspend fun clearNotifications(playerId: String): Result<Unit> {
        return updatePlayerObjectsData(playerId) { it.copy(notifications = emptyList()) }
    }
}



================================================================================
ðŸ“„ FICHIER : src\main\kotlin\core\metadata\PlayerObjectsMetadataService.kt
================================================================================

package core.metadata

import core.PlayerService
import core.metadata.model.PlayerFlags
import utils.LogConfigSocketToClient
import utils.Logger

class PlayerObjectsMetadataService(
    private val playerObjectsMetadataRepository: PlayerObjectsMetadataRepository
) : PlayerService {
    private var flags: ByteArray = PlayerFlags.newgame() // use newgame flags to avoid null
    private var nickname: String? = null // nickname null will prompt leader creation
    private lateinit var playerId: String

    suspend fun updatePlayerFlags(flags: ByteArray): Result<Unit> {
        val result = playerObjectsMetadataRepository.updatePlayerFlags(playerId, flags)
        result.onFailure {
            Logger.error(LogConfigSocketToClient) { "Error updatePlayerFlags: ${it.message}" }
        }
        result.onSuccess {
            this.flags = flags
        }
        return result
    }

    suspend fun updatePlayerNickname(nickname: String): Result<Unit> {
        val result = playerObjectsMetadataRepository.updatePlayerNickname(playerId, nickname)
        result.onFailure {
            Logger.error(LogConfigSocketToClient) { "Error updatePlayerNickname: ${it.message}" }
        }
        result.onSuccess {
            this.nickname = nickname
        }
        return result
    }

    suspend fun clearNotifications(): Result<Unit> {
        val result = playerObjectsMetadataRepository.clearNotifications(playerId)
        result.onFailure {
            Logger.error(LogConfigSocketToClient) { "Error clearNotifications: ${it.message}" }
        }
        return result
    }

    fun getPlayerFlags() = flags

    override suspend fun init(playerId: String): Result<Unit> {
        return runCatching {
            this.playerId = playerId
            val _flags = playerObjectsMetadataRepository.getPlayerFlags(playerId).getOrThrow()
            val _nickname = playerObjectsMetadataRepository.getPlayerNickname(playerId).getOrThrow()

            flags = _flags
            nickname = _nickname

            if (flags.isEmpty()) {
                Logger.warn(LogConfigSocketToClient) { "flags for playerId=$playerId is empty" }
            }
        }
    }

    override suspend fun close(playerId: String): Result<Unit> {
        return Result.success(Unit)
    }
}



================================================================================
ðŸ“„ FICHIER : src\main\kotlin\core\metadata\model\PlayerFlags.kt
================================================================================

package core.metadata.model
import kotlinx.serialization.KSerializer
import kotlinx.serialization.descriptors.PrimitiveKind
import kotlinx.serialization.descriptors.PrimitiveSerialDescriptor
import kotlinx.serialization.descriptors.SerialDescriptor
import kotlinx.serialization.encoding.Decoder
import kotlinx.serialization.encoding.Encoder
import kotlin.experimental.or
import kotlin.io.encoding.Base64
import kotlin.io.encoding.ExperimentalEncodingApi
object PlayerFlags {
    fun create(
        nicknameVerified: Boolean = false, refreshNeighbors: Boolean = false,
        tutorialComplete: Boolean = false, injurySustained: Boolean = false,
        injuryHelpComplete: Boolean = false, autoProtectionApplied: Boolean = false,
        tutorialCrateFound: Boolean = false, tutorialCrateUnlocked: Boolean = false,
        tutorialSchematicFound: Boolean = false, tutorialEffectFound: Boolean = false,
        tutorialPvPPractice: Boolean = false,
    ): ByteArray {
        val flags = listOf(
            nicknameVerified, refreshNeighbors, tutorialComplete,
            injurySustained, injuryHelpComplete, autoProtectionApplied,
            tutorialCrateFound, tutorialCrateUnlocked, tutorialSchematicFound,
            tutorialEffectFound, tutorialPvPPractice,
        )
        return flags.toByteArray()
    }
    fun newgame(
        nicknameVerified: Boolean = false, refreshNeighbors: Boolean = false,
        tutorialComplete: Boolean = false, injurySustained: Boolean = false,
        injuryHelpComplete: Boolean = false, autoProtectionApplied: Boolean = false,
        tutorialCrateFound: Boolean = false, tutorialCrateUnlocked: Boolean = false,
        tutorialSchematicFound: Boolean = false, tutorialEffectFound: Boolean = false,
        tutorialPvPPractice: Boolean = false,
    ): ByteArray {
        val flags = listOf(
            nicknameVerified, refreshNeighbors, tutorialComplete,
            injurySustained, injuryHelpComplete, autoProtectionApplied,
            tutorialCrateFound, tutorialCrateUnlocked, tutorialSchematicFound,
            tutorialEffectFound, tutorialPvPPractice,
        )
        return flags.toByteArray()
    }
    fun skipTutorial(
        nicknameVerified: Boolean = true, refreshNeighbors: Boolean = false,
        tutorialComplete: Boolean = true, injurySustained: Boolean = true,
        injuryHelpComplete: Boolean = true, autoProtectionApplied: Boolean = true,
        tutorialCrateFound: Boolean = true, tutorialCrateUnlocked: Boolean = true,
        tutorialSchematicFound: Boolean = true, tutorialEffectFound: Boolean = true,
        tutorialPvPPractice: Boolean = true,
    ): ByteArray {
        val flags = listOf(
            nicknameVerified, refreshNeighbors, tutorialComplete,
            injurySustained, injuryHelpComplete, autoProtectionApplied,
            tutorialCrateFound, tutorialCrateUnlocked, tutorialSchematicFound,
            tutorialEffectFound, tutorialPvPPractice,
        )
        return flags.toByteArray()
    }
}
fun List<Boolean>.toByteArray(): ByteArray {
    val bytes = ByteArray(this.size)
    for (i in this.indices) {
        if (this[i]) {
            val byteIndex = i / 8
            val bitIndex = i % 8
            bytes[byteIndex] = bytes[byteIndex] or (1 shl bitIndex).toByte()
        }
    }
    return bytes
}
@OptIn(ExperimentalEncodingApi::class)
object ByteArrayAsBase64Serializer : KSerializer<ByteArray> {
    override val descriptor: SerialDescriptor =
        PrimitiveSerialDescriptor("ByteArrayAsBase64", PrimitiveKind.STRING)
    override fun serialize(encoder: Encoder, value: ByteArray) {
        encoder.encodeString(Base64.encode(value))
    }
    override fun deserialize(decoder: Decoder): ByteArray {
        return Base64.decode(decoder.decodeString())
    }
}
object PlayerFlags_Constants {
    val TutorialComplete = 2u
}


================================================================================
ðŸ“„ FICHIER : src\main\kotlin\core\mission\LootService.kt
================================================================================

package core.mission

import core.data.resources.ItemResource
import core.data.GameDefinition
import core.mission.model.LootContent
import core.mission.model.LootParameter
import utils.UUID
import org.w3c.dom.Document
import org.w3c.dom.Element
import java.io.StringReader
import java.io.StringWriter
import javax.xml.parsers.DocumentBuilderFactory
import javax.xml.transform.OutputKeys
import javax.xml.transform.TransformerFactory
import javax.xml.transform.dom.DOMSource
import javax.xml.transform.stream.StreamResult
import javax.xml.parsers.DocumentBuilder
import org.xml.sax.InputSource
import java.util.TreeMap
import kotlin.random.Random

val ALL_LOCS = listOf(
    "crafting", "backpack", "kitchen", "lounge", "bedroom", "bathroom",
    "random", "office", "store", "military", "weapon", "resource", "police",
    "gear", "tutorial", "fuel", "food", "fridge", "water", "vending", "car",
    "body", "basement", "ammo", "wood", "metal", "cloth", "comms", "hospital",
    "island", "firstaid", "anything", "zmas", "tutorialfuel"
)

class LootService(
    private val sceneXML: String,
    private val parameter: LootParameter
) {
    val cumulativeLootsPerLoc: MutableMap<String, TreeMap<Double, LootContent>> = mutableMapOf()
    val totalWeightPerLoc: MutableMap<String, Double> = mutableMapOf()
    val insertedLoots: MutableList<LootContent> = mutableListOf()

    init {
        buildIndexOfLootableItems()
    }

    private fun buildIndexOfLootableItems() {
        ALL_LOCS.forEach { loc ->
            val lootableInLoc = GameDefinition.itemsByLootable[loc] ?: emptyList()
            // create a binary search tree whose key is cumulative weight and value is the loot
            // this will allow us to quickly search for an item based on a rolled double value just by seeing the cumulative weight
            val treeMap = TreeMap<Double, LootContent>()
            var cumulativeWeight = 0.0

            loop@ for (item in lootableInLoc) {
                val specialItemsKeyword = listOf(
                    "halloween", "spooky", "pumpkin", "ghost", "witch",
                    "christmas", "winter", "snow", "xmas", "santa", "holiday",
                    "easter", "bunny", "egg",
                    "valentine", "love", "heart",
                    "summer", "beach", "sun", "vacation",
                    "autumn", "fall", "harvest",
                    "spring", "blossom",
                    "4july", "july", "independence", "firework",
                    "birthday", "anniversary", "celebration", "cake",
                    "newyear", "ny", "countdown",
                    "thanksgiving", "turkey", "feast",
                    "event", "limited", "special", "exclusive", "festive",
                    "cache", "box", "gacha", "crate"
                )

                val isEventItem = specialItemsKeyword.any { keyword ->
                    item.id.contains(keyword, ignoreCase = true)
                }

                if (isEventItem) continue

                val lvlMin = item.levelMin ?: 0
                val lvlMax = item.levelMax ?: Int.MAX_VALUE
                if (parameter.areaLevel !in (lvlMin..lvlMax)) continue

                val rarity = item.rarity?.toInt() ?: 1
                val type = item.type
                val quality = item.quality ?: ""

                val baseWeight = parameter.itemWeightOverrides[item.id]
                    ?: (parameter.baseWeight / rarity.toDouble())

                val itemBoost = parameter.specificItemBoost[item.id] ?: 0.0
                val typeBoost = parameter.itemTypeBoost[type] ?: 0.0
                val qualityBoost = parameter.itemQualityBoost[quality] ?: 0.0

                val totalMultiplier = (1.0 + itemBoost) * (1.0 + typeBoost) * (1.0 + qualityBoost)

                val finalWeight = (baseWeight * totalMultiplier).coerceAtLeast(0.0001)

                cumulativeWeight += finalWeight
                treeMap[cumulativeWeight] = createLootContent(item)
            }

            if (treeMap.isNotEmpty()) {
                cumulativeLootsPerLoc[loc] = treeMap
                totalWeightPerLoc[loc] = cumulativeWeight
            }
        }
    }

    /**
     * Insert loots to the given scene XML from constructor.
     *
     * @return The updated XML with loots inserted and the list of [LootContent]s inserted.
     */
    fun insertLoots(): Pair<String, List<LootContent>> {
        val docBuilder: DocumentBuilder = DocumentBuilderFactory.newInstance().newDocumentBuilder()
        val doc: Document = docBuilder.parse(InputSource(StringReader(sceneXML)))

        val eList = doc.getElementsByTagName("e")
        for (i in 0 until eList.length) {
            val eNode = eList.item(i) as? Element ?: continue

            val optNode = eNode.getElementsByTagName("opt").item(0) as? Element ?: continue
            val srchNode = optNode.getElementsByTagName("srch").item(0) ?: continue

            // skip if the corresponding node has a predefined itms
            val hasItms = (0 until eNode.childNodes.length)
                .map { eNode.childNodes.item(it) }
                .any { it is Element && it.tagName == "itms" }

            if (!hasItms) {
                val itmsElement = doc.createElement("itms")

                val loots = getRollsFromLocs(srchNode.textContent.split(","))
                for ((lootId, type, q) in loots) {
                    val itm = doc.createElement("itm")
                    itm.setAttribute("id", lootId)
                    itm.setAttribute("type", type)
                    itm.setAttribute("q", q.toString())
                    itmsElement.appendChild(itm)
                }

                insertedLoots.addAll(loots)
                eNode.appendChild(itmsElement)
            }
        }

        // Transform back to string
        val transformer = TransformerFactory.newInstance().newTransformer().apply {
            setOutputProperty(OutputKeys.INDENT, "yes")
            setOutputProperty("{http://xml.apache.org/xslt}indent-amount", "2")
        }

        val writer = StringWriter()
        transformer.transform(DOMSource(doc), StreamResult(writer))
        return writer.toString() to insertedLoots
    }

    private fun getRollsFromLocs(locs: List<String>): List<LootContent> {
        // roll 0-6 items per container
        val lootsAmount = (0..6).random()
        val lootResults: MutableList<LootContent> = mutableListOf()

        // Filter to only locations that have loot available
        val availableLocs = locs.filter { cumulativeLootsPerLoc.containsKey(it) }
        
        if (availableLocs.isEmpty()) {
            return emptyList()
        }

        // shuffle the list of locs, and pick one item per loc
        // go back to start if still need more item
        val shuffledLocs = availableLocs.shuffled()
        var i = 0

        // upperbound for potential infinite loop
        val maxAttempts = lootsAmount * shuffledLocs.size + 10

        while (lootResults.size < lootsAmount && i < maxAttempts) {
            val loc = shuffledLocs[i % shuffledLocs.size]
            weightedRandomTree(loc)?.let { lootResults.add(it) }
            i += 1
        }

        return lootResults
    }

    private fun weightedRandomTree(loc: String): LootContent? {
        // use RNG to roll a double value within the total weight of a loc
        // quickly find the loot with cumulative weight lower or equal than the roll
        // e.g., for cumulative weight [1.5, 2.0, 3.0], or [0.0-1.5, 1.5-2.0, 2.0-3.0]
        // if roll is 1.4, pick the first
        val possibleLoots = cumulativeLootsPerLoc[loc] ?: return null
        val totalWeight = totalWeightPerLoc[loc] ?: return null
        val roll = Random.nextDouble(0.0, totalWeight)
        return possibleLoots.ceilingEntry(roll)?.value
    }

    private fun createLootContent(res: ItemResource): LootContent {
        val qntMin = res.quantityMin ?: 1
        val qntMax = res.quantityMax ?: 1
        val min = minOf(qntMin, qntMax)
        val max = maxOf(qntMin, qntMax)
        val qty = (min..max).random()

        return LootContent(
            lootId = UUID.new(),
            itemIdInXML = res.id,
            quantity = qty,
        )
    }
}



================================================================================
ðŸ“„ FICHIER : src\main\kotlin\core\mission\model\LootContent.kt
================================================================================

package core.mission.model

data class LootContent(
    val lootId: String,
    val itemIdInXML: String,
    val quantity: Int,
)



================================================================================
ðŸ“„ FICHIER : src\main\kotlin\core\mission\model\LootParameter.kt
================================================================================

package core.mission.model

// Loot system config, contains variables that affects loot
data class LootParameter(
    val areaLevel: Int,
    val playerLevel: Int, // not used yet
    val itemWeightOverrides: Map<String, Double> = emptyMap(), // absolute override if needed
    val specificItemBoost: Map<String, Double> = emptyMap(),   // e.g. "fuel" to 0.2 (+20%)
    val itemTypeBoost: Map<String, Double> = emptyMap(),       // e.g. "weapon" to 0.1 (+10%)
    val itemQualityBoost: Map<String, Double> = emptyMap(),    // e.g. "blue" to -0.4 (-40%)
    val baseWeight: Double = 1.0,
    val fuelLimit: Int = 0 // not used yet
)



================================================================================
ðŸ“„ FICHIER : src\main\kotlin\core\mission\model\MissionCollection.kt
================================================================================

package core.model.game.data

import kotlinx.serialization.Serializable
import core.model.game.data.MissionData

@Serializable
data class MissionCollection(
    val list: List<MissionData> = listOf()
)



================================================================================
ðŸ“„ FICHIER : src\main\kotlin\core\mission\model\MissionData.kt
================================================================================

package core.model.game.data

import kotlinx.serialization.Serializable
import core.items.model.Item
import dev.deadzone.core.model.game.data.TimerData

@Serializable
data class MissionData(
    val id: String,
    val player: SurvivorData,
    val stats: MissionStats? = null,
    val xpEarned: Int,
    val xp: Map<String, Int> = emptyMap(),
    val completed: Boolean,
    val assignmentId: String,
    val assignmentType: String,
    val playerId: String? = null,
    val compound: Boolean = false,
    val areaLevel: Int = 1,
    val areaId: String = "",
    val type: String = "",
    val suburb: String = "",
    val automated: Boolean = false,
    val survivors: List<Map<String, String>> = emptyList(), //survivor ids to mission ids
    val srvDown: List<Map<String, String>> = emptyList(), //survivor ids
    val buildingsDestroyed: List<String> = emptyList(), //building ids
    val returnTimer: TimerData? = null,
    val lockTimer: TimerData? = null,
    val loot: List<Item> = emptyList(),
    val highActivityIndex: Int? = null
) {
    companion object {
        fun dummy(srvId: String): MissionData {
            return MissionData(
                id = "mission001",
                player = SurvivorData.dummy(srvId),
                xpEarned = 50,
                xp = mapOf("mission" to 50),
                completed = false,
                assignmentId = "compoundTutorial",
                assignmentType = "tutorial",
                compound = true,
                type = "compound",
                survivors = listOf(mapOf("id" to srvId))
            )
        }
    }
}



================================================================================
ðŸ“„ FICHIER : src\main\kotlin\core\mission\model\MissionDataConstants.kt
================================================================================

package core.model.game.data

import kotlinx.serialization.Serializable

@Serializable
@JvmInline
value class MissionDataConstants(val value: Int)

object MissionDataConstants_Constants {
    val DANGER_NORMAL = MissionDataConstants(0)
    val DANGER_LOW = MissionDataConstants(0)
    val DANGER_MODERATE = MissionDataConstants(1)
    val DANGER_DANGEROUS = MissionDataConstants(2)
    val DANGER_HIGH = MissionDataConstants(3)
    val DANGER_EXTREME = MissionDataConstants(4)
}



================================================================================
ðŸ“„ FICHIER : src\main\kotlin\core\mission\model\MissionStats.kt
================================================================================

package core.model.game.data

import kotlinx.serialization.Serializable

@Serializable
data class MissionStats(
    val zombieSpawned: Int = 0,
    val levelUps: Int = 0,
    val damageOutput: Double = 0.0,
    val damageTaken: Double = 0.0,
    val containersSearched: Int = 0,
    val survivorKills: Int = 0,
    val survivorsDowned: Int = 0,
    val survivorExplosiveKills: Int = 0,
    val humanKills: Int = 0,
    val humanExplosiveKills: Int = 0,
    val zombieKills: Int = 0,
    val zombieExplosiveKills: Int = 0,
    val hpHealed: Int = 0,
    val explosivesPlaced: Int = 0,
    val grenadesThrown: Int = 0,
    val grenadesSmokeThrown: Int = 0,
    val allianceFlagCaptured: Int = 0,
    val buildingsDestroyed: Int = 0,
    val buildingsLost: Int = 0,
    val buildingsExplosiveDestroyed: Int = 0,
    val trapsTriggered: Int = 0,
    val trapDisarmTriggered: Int = 0,
    val cashFound: Int = 0,
    val woodFound: Int = 0,
    val metalFound: Int = 0,
    val clothFound: Int = 0,
    val foodFound: Int = 0,
    val waterFound: Int = 0,
    val ammunitionFound: Int = 0,
    val ammunitionUsed: Int = 0,
    val weaponsFound: Int = 0,
    val gearFound: Int = 0,
    val junkFound: Int = 0,
    val medicalFound: Int = 0,
    val craftingFound: Int = 0,
    val researchFound: Int = 0,
    val researchNoteFound: Int = 0,
    val clothingFound: Int = 0,
    val cratesFound: Int = 0,
    val schematicsFound: Int = 0,
    val effectFound: Int = 0,
    val rareWeaponFound: Int = 0,
    val rareGearFound: Int = 0,
    val uniqueWeaponFound: Int = 0,
    val uniqueGearFound: Int = 0,
    val greyWeaponFound: Int = 0,
    val greyGearFound: Int = 0,
    val whiteWeaponFound: Int = 0,
    val whiteGearFound: Int = 0,
    val greenWeaponFound: Int = 0,
    val greenGearFound: Int = 0,
    val blueWeaponFound: Int = 0,
    val blueGearFound: Int = 0,
    val purpleWeaponFound: Int = 0,
    val purpleGearFound: Int = 0,
    val premiumWeaponFound: Int = 0,
    val premiumGearFound: Int = 0,
    val killData: Map<String, Int> = mapOf(),
    val customData: Map<String, Int> = mapOf()
)



================================================================================
ðŸ“„ FICHIER : src\main\kotlin\core\mission\model\ZombieData.kt
================================================================================

package core.model.game.data

import kotlinx.serialization.Serializable

@Serializable
data class ZombieData(
    val id: Int,
    val type: String,
    val weapon: String
) {
    companion object {
        fun standardZombieWeakAttack(id: Int): ZombieData {
            return ZombieData(id = id, type = "standard", weapon = "zStrike")
        }

        fun dogStandard(id: Int): ZombieData {
            return ZombieData(id = id, type = "dog", weapon = "zDogBite")
        }

        fun fatWalkerStrongAttack(id: Int): ZombieData {
            return ZombieData(id = id, type = "fat-walker", weapon = "zStrongStrike")
        }

        fun police20ZWeakAttack(id: Int): ZombieData {
            return ZombieData(id = id, type = "police-20", weapon = "zStrike")
        }

        fun riotWalker37MediumAttack(id: Int): ZombieData {
            return ZombieData(id = id, type = "riot-walker-37", weapon = "zMediumStrike")
        }

        fun dogTank(id: Int): ZombieData {
            return ZombieData(id = id, type = "dog-tank", weapon = "zDogBite")
        }

        fun strongRunner(id: Int): ZombieData {
            return ZombieData(id = id, type = "strong-runner", weapon = "zKnockbackStrike")
        }
    }
}

fun ZombieData.toFlatList(): List<String> {
    return listOf("$id", type, weapon)
}



================================================================================
ðŸ“„ FICHIER : src\main\kotlin\core\model\data\AllianceDialogState.kt
================================================================================

package core.model.data

import kotlinx.serialization.Serializable

@Serializable
@JvmInline
value class AllianceDialogState(val value: Int)

object AllianceDialogState_Constants {
    val SHOW_NONE = AllianceDialogState(0)
    val SHOW_ALLIANCE_DIALOG = AllianceDialogState(1)
    val SHOW_INDIVIDUALS = AllianceDialogState(2)
    val SHOW_TOP_100 = AllianceDialogState(3)
}



================================================================================
ðŸ“„ FICHIER : src\main\kotlin\core\model\data\CostEntry.kt
================================================================================

package core.model.data

import kotlinx.serialization.Serializable

@Serializable
data class CostEntry(
    val key: String,
    val type: String?
)



================================================================================
ðŸ“„ FICHIER : src\main\kotlin\core\model\data\CostTable.kt
================================================================================

package core.model.data

import kotlinx.serialization.Serializable
import core.model.data.CostEntry

@Serializable
data class CostTable(
    val objectsByKey: Map<String, CostEntry> = mapOf(),
    val categories: Map<String, Map<String, CostEntry>> = mapOf()
)



================================================================================
ðŸ“„ FICHIER : src\main\kotlin\core\model\data\Currency.kt
================================================================================

package core.model.data

import kotlinx.serialization.Serializable

@Serializable
@JvmInline
value class Currency(val value: String)

object Currency_Constants {
    val FUEL = Currency("Coins")
    val FACEBOOK_CREDITS = Currency("FBC")
    val US_DOLLARS = Currency("USD")
    val KONGREGATE_KREDS = Currency("KKR")
    val ALLIANCE_TOKENS = Currency("ATK")
}



================================================================================
ðŸ“„ FICHIER : src\main\kotlin\core\model\data\FlagSet.kt
================================================================================

package core.model.data

import kotlinx.serialization.Serializable

/**
 * Bytearray of booleans
 *
 * Content of booleans depend on [core.metadata.model.PlayerFlags]
 */
@Serializable
data class FlagSet(
    val byteArray: ByteArray = byteArrayOf()
) {
    companion object {
        fun mockFlagSetByteArray(bitCount: Int = 256): ByteArray {
            val byteSize = (bitCount + 7) / 8 // round up
            val data = ByteArray(byteSize)

            // For example, just set first few flags
            for (i in 0 until byteSize) {
                data[i] = 0b00000001 // only first bit set
            }

            return data
        }
    }
}



================================================================================
ðŸ“„ FICHIER : src\main\kotlin\core\model\data\HighActivity.kt
================================================================================

package core.model.data

import kotlinx.serialization.Serializable

@Serializable
data class HighActivity(
    val buildings: List<String>,  // building ids
)



================================================================================
ðŸ“„ FICHIER : src\main\kotlin\core\model\data\KeyFlags.kt
================================================================================

package core.model.data

import kotlinx.serialization.Serializable

@Serializable
@JvmInline
value class KeyFlags(val value: UInt)

object KeyFlags_Constants {
    val NONE = KeyFlags(0u)
    val CONTROL = KeyFlags(1u)
    val SHIFT = KeyFlags(2u)
}



================================================================================
ðŸ“„ FICHIER : src\main\kotlin\core\model\data\NavigationLocation.kt
================================================================================

package core.model.data

import kotlinx.serialization.Serializable

@Serializable
@JvmInline
value class NavigationLocation(val value: String)

object NavigationLocation_Constants {
    val PLAYER_COMPOUND = NavigationLocation("playerCompound")
    val NEIGHBOR_COMPOUND = NavigationLocation("neighborCompound")
    val MISSION = NavigationLocation("mission")
    val MISSION_PLANNING = NavigationLocation("missionPlanning")
    val WORLD_MAP = NavigationLocation("worldmap")
}



================================================================================
ðŸ“„ FICHIER : src\main\kotlin\core\model\data\NewsArticle.kt
================================================================================

package core.model.data

import kotlinx.serialization.Serializable

@Serializable
data class NewsArticle(
    val date: Long,
    val body: String
)



================================================================================
ðŸ“„ FICHIER : src\main\kotlin\core\model\data\Notification.kt
================================================================================

package core.model.data

import kotlinx.serialization.Serializable

@Serializable
data class Notification(
    val type: String?, // notification: type
    val data: String?,
)



================================================================================
ðŸ“„ FICHIER : src\main\kotlin\core\model\data\PlayerUpgrades.kt
================================================================================

package core.model.data

import kotlinx.serialization.Serializable

@Serializable
@JvmInline
value class PlayerUpgrades(val value: Int)

object PlayerUpgrades_Constants {
    val DeathMobileUpgrade = PlayerUpgrades(0)
    val TradeSlotUpgrade = PlayerUpgrades(1)
    val InventoryUpgrade1_UNUSED = PlayerUpgrades(2)
}



================================================================================
ðŸ“„ FICHIER : src\main\kotlin\core\model\data\PrevLogin.kt
================================================================================

package core.model.data

import kotlinx.serialization.Serializable

@Serializable
data class PrevLogin(
    val date: Long
)



================================================================================
ðŸ“„ FICHIER : src\main\kotlin\core\model\data\RequirementTypes.kt
================================================================================

package core.model.data

import kotlinx.serialization.Serializable

@Serializable
@JvmInline
value class RequirementTypes(val value: UInt)

object RequirementTypes_Constants {
    val None = RequirementTypes(0u)
    val PlayerLevel = RequirementTypes(2u)
    val Buildings = RequirementTypes(4u)
    val Survivors = RequirementTypes(8u)
    val Items = RequirementTypes(16u)
    val Resources = RequirementTypes(32u)
    val Skills = RequirementTypes(64u)
    val All = RequirementTypes(16777215u)
    val NotItemsResources = RequirementTypes(16777167u)
    val ItemsResources = RequirementTypes(48u)
}



================================================================================
ðŸ“„ FICHIER : src\main\kotlin\core\model\data\user\AbstractUser.kt
================================================================================

package core.model.data.user

import kotlinx.serialization.Serializable
import core.model.data.Currency
import core.model.data.user.UserData

@Serializable
data class AbstractUser(
    val data: UserData,
    val email: String,
    val time: Long,
    val defaultCurrency: String // Currency constants
)



================================================================================
ðŸ“„ FICHIER : src\main\kotlin\core\model\data\user\PlayerIOUser.kt
================================================================================

package core.model.data.user

import kotlinx.serialization.Serializable
import core.model.data.user.AbstractUser
import core.model.data.user.PublishingNetworkProfile

@Serializable
data class PlayerIOUser(
    val abstractUser: AbstractUser,
    val profile: PublishingNetworkProfile
)



================================================================================
ðŸ“„ FICHIER : src\main\kotlin\core\model\data\user\PublishingNetworkProfile.kt
================================================================================

package core.model.data.user

import kotlinx.serialization.Serializable

@Serializable
data class PublishingNetworkProfile(
    val userId: String,
    val displayName: String,
    val avatarUrl: String,
    val lastOnline: Long,
    val countryCode: String
)



================================================================================
ðŸ“„ FICHIER : src\main\kotlin\core\model\data\user\UserData.kt
================================================================================

package core.model.data.user

import kotlinx.serialization.Serializable

@Serializable
data class UserData(
    val email: String
)



================================================================================
ðŸ“„ FICHIER : src\main\kotlin\core\model\game\data\AmmoType.kt
================================================================================

package core.model.game.data

import kotlinx.serialization.Serializable

@Serializable
data class AmmoType(
    val NONE: UInt = 0u,
    val ARROW: UInt = 1u,
    val ASSAULT_RIFLE: UInt = 2u,
    val BOLT: UInt = 4u,
    val LONG_RIFLE: UInt = 8u,
    val PISTOL: UInt = 16u,
    val SHOTGUN: UInt = 32u,
    val SMG: UInt = 64u
)



================================================================================
ðŸ“„ FICHIER : src\main\kotlin\core\model\game\data\BatchRecycleJob.kt
================================================================================

package core.model.game.data

import kotlinx.serialization.Serializable
import core.items.model.Item

@Serializable
data class BatchRecycleJob(
    val id: String,
    val items: List<Item>,
    val start: Long,
    val end: Int
)



================================================================================
ðŸ“„ FICHIER : src\main\kotlin\core\model\game\data\BatchRecycleJobCollection.kt
================================================================================

package core.model.game.data

import kotlinx.serialization.Serializable
import core.model.game.data.BatchRecycleJob

@Serializable
data class BatchRecycleJobCollection(
    val list: List<BatchRecycleJob> = listOf()
)



================================================================================
ðŸ“„ FICHIER : src\main\kotlin\core\model\game\data\CooldownCollection.kt
================================================================================

package core.model.game.data

import kotlinx.serialization.Serializable

@Serializable
data class CooldownCollection(
    val byteArray: Map<String, ByteArray> = mapOf(),  // will be parsed to Cooldown
)



================================================================================
ðŸ“„ FICHIER : src\main\kotlin\core\model\game\data\CraftingInfo.kt
================================================================================

package core.model.game.data

import kotlinx.serialization.Serializable

@Serializable
data class CraftingInfo(
    val user_id: String,
    val user_name: String,
    val date: Long
)



================================================================================
ðŸ“„ FICHIER : src\main\kotlin\core\model\game\data\DamageType.kt
================================================================================

package core.model.game.data

import kotlinx.serialization.Serializable

@Serializable
data class DamageType(
    val UNKNOWN: UInt = 0u,
    val MELEE: UInt = 1u,
    val PROJECTILE: UInt = 2u,
    val EXPLOSIVE: UInt = 3u
)



================================================================================
ðŸ“„ FICHIER : src\main\kotlin\core\model\game\data\EffectCollection.kt
================================================================================

package core.model.game.data

import kotlinx.serialization.Serializable
import core.model.game.data.effects.Effect

@Serializable
data class EffectCollection(
    val list: List<ByteArray> = listOf()
) {
    fun dummy(): EffectCollection {
        return EffectCollection(
            list = listOf(byteArrayOf())
        )
    }
}



================================================================================
ðŸ“„ FICHIER : src\main\kotlin\core\model\game\data\EnemyResults.kt
================================================================================

package core.model.game.data

import kotlinx.serialization.Serializable
import core.items.model.Item

@Serializable
data class EnemyResults(
    val attackerId: String,
    val attackerNickname: String,
    val numSrvDown: Int = 0,
    val survivors: List<String> = listOf(),  // survivor ids
    val srvDown: List<String> = listOf(),  // survivor ids
    val loot: List<Item> = listOf(),
    val prodBuildingsRaided: List<String> = listOf(),  // building ids
    val buildingsDestroyed: List<String> = listOf(),  // building ids
    val trapsTriggered: List<String> = listOf(),  // building ids
    val trapsDisarmed: List<String> = listOf(),  // building ids
    val totalBuildingsLooted: Int?
)



================================================================================
ðŸ“„ FICHIER : src\main\kotlin\core\model\game\data\Task.kt
================================================================================

package core.model.game.data

import kotlinx.serialization.Serializable
import core.items.model.Item

@Serializable
data class Task(
    val id: String,
    val type: String,
    val length: Int,
    val time: Double,
    val items: List<Item>?,
    val completed: Boolean,
    val survivors: List<String>,  // survivor ids
)



================================================================================
ðŸ“„ FICHIER : src\main\kotlin\core\model\game\data\TaskCollection.kt
================================================================================

package core.model.game.data

import kotlinx.serialization.Serializable
import core.model.game.data.Task

@Serializable
data class TaskCollection(
    val list: List<Task> = listOf()
)



================================================================================
ðŸ“„ FICHIER : src\main\kotlin\core\model\game\data\TaskStatus.kt
================================================================================

package core.model.game.data

import kotlinx.serialization.Serializable

@Serializable
@JvmInline
value class TaskStatus(val value: String)

object TaskStatus_Constants {
    val ACTIVE = TaskStatus("active")
    val INACTIVE = TaskStatus("inactive")
    val COMPLETE = TaskStatus("complete")
}



================================================================================
ðŸ“„ FICHIER : src\main\kotlin\core\model\game\data\TaskType.kt
================================================================================

package core.model.game.data

import kotlinx.serialization.Serializable

@Serializable
@JvmInline
value class TaskType(val value: String)

object TaskType_Constants {
    val JUNK_REMOVAL = TaskType("junk_removal")
    val ITEM_CRAFTING = TaskType("item_crafting")
}



================================================================================
ðŸ“„ FICHIER : src\main\kotlin\core\model\game\data\TimerData.kt
================================================================================

package dev.deadzone.core.model.game.data

import dev.deadzone.utils.AnyMapSerializer
import io.ktor.util.date.*
import kotlinx.serialization.Serializable
import kotlin.time.Duration
import kotlin.time.Duration.Companion.milliseconds
import kotlin.time.Duration.Companion.seconds
import kotlin.time.DurationUnit
import kotlin.time.toDuration

@Serializable
data class TimerData(
    val start: Long, // epoch millis
    val length: Long, // length in seconds!
    // If sending this via API, the value should be JSONElement. Use Json.encodeToJsonElement()
    @Serializable(with = AnyMapSerializer::class)
    val data: Map<String, Any>? // this depends on each response. e.g., building upgrade need level
) {
    companion object {
        fun runForDuration(
            duration: Duration,
            data: Map<String, Any>? = emptyMap()
        ): TimerData {
            return TimerData(
                start = getTimeMillis(),
                length = duration.inWholeSeconds,
                data = data
            )
        }
    }
}

/**
 * Reduce the timer data length by [hours].
 *
 * **This will first calculate the remaining time before subtracting**
 *
 * @return `null` if the timer has finished after the reduction.
 */
fun TimerData.reduceBy(hours: Duration): TimerData? {
    if (this.hasEnded()) return null

    val remainingSeconds = this.secondsLeftToEnd().toDuration(DurationUnit.SECONDS)
    val reducedLength = remainingSeconds - hours
    if (reducedLength <= Duration.ZERO) return null

    return this.copy(length = reducedLength.toLong(DurationUnit.SECONDS))
}

/**
 * Reduce the timer data length by half.
 *
 * **This will first calculate the remaining time before subtracting**
 *
 * @return `null` if the timer has finished after the reduction.
 */
fun TimerData.reduceByHalf(): TimerData? {
    if (this.hasEnded()) return null

    val remainingSeconds = this.secondsLeftToEnd().toDuration(DurationUnit.SECONDS)
    val reducedLength = remainingSeconds / 2
    if (reducedLength <= 1.seconds) return null

    return this.copy(length = reducedLength.toLong(DurationUnit.SECONDS))
}

fun TimerData.hasEnded(): Boolean {
    return getTimeMillis() >= this.start + this.length.seconds.inWholeMilliseconds
}

fun TimerData.secondsLeftToEnd(): Int {
    if (this.hasEnded()) return 0
    return ((start.milliseconds + this.length.seconds) - getTimeMillis().milliseconds).toInt(DurationUnit.SECONDS)
}

/**
 * Change the length of the timer using the provided block.
 *
 * A `null` timer represent no timer is set or the timer has finished.
 *
 * @return `null` if timer was already `null`.
 */
fun TimerData?.changeLength(updateLength: (Duration?) -> Duration): TimerData? {
    if (this == null) return null
    return this.copy(length = updateLength(this.length.seconds).toLong(DurationUnit.SECONDS))
}

/**
 * Return `null` if time has finished (or less than 1 seconds).
 */
fun TimerData?.removeIfFinished(): TimerData? {
    if (this == null) return null
    return if (this.hasEnded() || this.secondsLeftToEnd() < 1) null else this
}



================================================================================
ðŸ“„ FICHIER : src\main\kotlin\core\model\game\data\Weapon.kt
================================================================================

package core.model.game.data

import kotlinx.serialization.Serializable
import core.survivor.model.injury.InjuryCause

@Serializable
data class Weapon(
    val attachments: List<String>,
    val burstFire: Boolean,
    val injuryCause: InjuryCause,
    val weaponClass: WeaponClass,
    val animType: String,
    val reloadAnim: String,
    val swingAnims: List<String>,
    val playSwingExertionSound: Boolean = true,
    val flags: UInt = 0u,
    val weaponType: UInt = 0u,
    val ammoType: UInt = 0u,
    val survivorClasses: List<String> = listOf()
)



================================================================================
ðŸ“„ FICHIER : src\main\kotlin\core\model\game\data\WeaponClass.kt
================================================================================

package core.model.game.data

import kotlinx.serialization.Serializable

@Serializable
@JvmInline
value class WeaponClass(val value: String)

object WeaponClass_Constants {
    val ASSAULT_RIFLE = WeaponClass("assault_rifle")
    val BOW = WeaponClass("bow")
    val LAUNCHER = WeaponClass("launcher")
    val LONG_RIFLE = WeaponClass("long_rifle")
    val MELEE = WeaponClass("melee")
    val PISTOL = WeaponClass("pistol")
    val SHOTGUN = WeaponClass("shotgun")
    val SMG = WeaponClass("smg")
    val LMG = WeaponClass("lmg")
    val THROWN = WeaponClass("thrown")
    val HEAVY = WeaponClass("heavy")
}



================================================================================
ðŸ“„ FICHIER : src\main\kotlin\core\model\game\data\WeaponData.kt
================================================================================

package core.model.game.data

import kotlinx.serialization.Serializable

@Serializable
data class WeaponData(
    val minRange: Double = 0.0,
    val minEffectiveRange: Double = 0.0,
    val range: Double = 0.0,
    val minRangeMod: Double = 0.0,
    val maxRangeMod: Double = 0.0,
    val burstAvg: Int = 0,
    val roundsInMagazine: Int = 0,
    val ammoCost: Double = 0.0,
    val damageMax: Double = 0.0,
    val damageMin: Double = 0.0,
    val damageMult: Double = 1.0,
    val damageMultVsBuilding: Double = 1.0,
    val accuracy: Double = 0.0,
    val capacity: Int = 0,
    val reloadTime: Double = 0.0,
    val fireRate: Double = 0.0,
    val noise: Double = 0.0,
    val idleNoise: Double = 0.0,
    val criticalChance: Double = 0.0,
    val knockbackChance: Double = 0.0,
    val dodgeChance: Double = 0.0,
    val isMelee: Boolean = false,
    val isExplosive: Boolean = false,
    val attackArcCosine: Double = 0.0,
    val suppressionRate: Double = 0.0,
    val goreMultiplier: Double = 1.0,
    val readyTime: Double = 0.0
)



================================================================================
ðŸ“„ FICHIER : src\main\kotlin\core\model\game\data\WeaponFlags.kt
================================================================================

package core.model.game.data

import kotlinx.serialization.Serializable

@Serializable
@JvmInline
value class WeaponFlags(val value: UInt)

object WeaponFlags_Constants {
    val NONE = WeaponFlags(0u)
    val SUPPRESSED = WeaponFlags(1u)
}



================================================================================
ðŸ“„ FICHIER : src\main\kotlin\core\model\game\data\WeaponType.kt
================================================================================

package core.model.game.data

import kotlinx.serialization.Serializable

@Serializable
@JvmInline
value class WeaponType(val value: UInt)

object WeaponType_Constants {
    val NONE = WeaponType(0u)
    val AUTO = WeaponType(1u)
    val SEMI_AUTO = WeaponType(2u)
    val ONE_HANDED = WeaponType(4u)
    val TWO_HANDED = WeaponType(8u)
    val IMPROVISED = WeaponType(16u)
    val EXPLOSIVE = WeaponType(32u)
    val BLADE = WeaponType(64u)
    val BLUNT = WeaponType(128u)
    val AXE = WeaponType(256u)
    val SPECIAL = WeaponType(512u)
}



================================================================================
ðŸ“„ FICHIER : src\main\kotlin\core\model\game\data\alliance\AllianceBannerData.kt
================================================================================

package core.model.game.data.alliance

import kotlinx.serialization.Serializable

@Serializable
@JvmInline
value class AllianceBannerData(val value: Int)

object AllianceBannerData_Constants {
    val BASE_COLOR = AllianceBannerData(0)
    val DECAL_1 = AllianceBannerData(1)
    val DECAL_1_COLOR = AllianceBannerData(2)
    val DECAL_2 = AllianceBannerData(3)
    val DECAL_2_COLOR = AllianceBannerData(4)
    val DECAL_3 = AllianceBannerData(5)
    val DECAL_3_COLOR = AllianceBannerData(6)
}



================================================================================
ðŸ“„ FICHIER : src\main\kotlin\core\model\game\data\alliance\AllianceData.kt
================================================================================

package core.model.game.data.alliance

import kotlinx.serialization.Serializable
import core.model.game.data.alliance.AllianceDataSummary
import core.model.game.data.alliance.AllianceList
import core.model.game.data.alliance.AllianceMemberList
import core.model.game.data.alliance.AllianceMessageList
import core.model.game.data.effects.Effect
import core.model.game.data.alliance.TargetRecord

@Serializable
data class AllianceData(
    val allianceDataSummary: AllianceDataSummary,
    val members: AllianceMemberList?,
    val messages: AllianceMessageList?,
    val enemies: AllianceList?,
    val ranks: Map<String, Int>?,
    val bannerEdits: Int,
    val effects: List<Effect>?,
    val tokens: Int?,
    val taskSet: Int?,
    val tasks: Map<String, Int>?, // string as key, but parsed to int
    val attackedTargets: Map<String, TargetRecord>?,
    val scoutedTargets: Map<String, TargetRecord>?
)



================================================================================
ðŸ“„ FICHIER : src\main\kotlin\core\model\game\data\alliance\AllianceDataSummary.kt
================================================================================

package core.model.game.data.alliance

import kotlinx.serialization.Serializable

@Serializable
data class AllianceDataSummary(
    val allianceId: String?,
    val name: String?,
    val tag: String?,
    val banner: String?,  // can also be bytearray. if a string, will try to decodeToByteArray
    val thumbURI: String?,
    val memberCount: Int?,
    val efficiency: Double?,
    val points: Int?
)



================================================================================
ðŸ“„ FICHIER : src\main\kotlin\core\model\game\data\alliance\AllianceLifetimeStats.kt
================================================================================

package core.model.game.data.alliance

import kotlinx.serialization.Serializable

@Serializable
data class AllianceLifetimeStats(
    val userName: String?,
    val points: Int,
    val wins: Int,
    val losses: Int,
    val abandons: Int,
    val defWins: Int,
    val defLosses: Int,
    val pointsAttack: Int,
    val pointsDefend: Int,
    val missionSuccess: Int,
    val missionFail: Int,
    val missionAbandon: Int,
    val pointsMission: Int
)



================================================================================
ðŸ“„ FICHIER : src\main\kotlin\core\model\game\data\alliance\AllianceList.kt
================================================================================

package core.model.game.data.alliance

import kotlinx.serialization.Serializable
import core.model.game.data.alliance.AllianceDataSummary

@Serializable
data class AllianceList(
    val list: List<AllianceDataSummary> = listOf()
)



================================================================================
ðŸ“„ FICHIER : src\main\kotlin\core\model\game\data\alliance\AllianceMember.kt
================================================================================

package core.model.game.data.alliance

import kotlinx.serialization.Serializable

@Serializable
data class AllianceMember(
    val playerId: String,
    val nickname: String,
    val level: Int,
    val joindate: Long,
    val rank: UInt,
    val tokens: UInt,
    val online: Boolean,
    val points: UInt,
    val pointsAttack: UInt,
    val pointsDefend: UInt,
    val pointsMission: UInt,
    val efficiency: Double,
    val wins: Int,
    val losses: Int,
    val abandons: Int,
    val defWins: Int,
    val defLosses: Int,
    val missionSuccess: Int,
    val missionFail: Int,
    val missionAbandon: Int,
    val missionEfficiency: Double,
    val raidWinPts: UInt,
    val raidLosePts: UInt
)



================================================================================
ðŸ“„ FICHIER : src\main\kotlin\core\model\game\data\alliance\AllianceMemberList.kt
================================================================================

package core.model.game.data.alliance

import kotlinx.serialization.Serializable
import core.model.game.data.alliance.AllianceMember

@Serializable
data class AllianceMemberList(
    val list: List<AllianceMember>
)



================================================================================
ðŸ“„ FICHIER : src\main\kotlin\core\model\game\data\alliance\AllianceMessage.kt
================================================================================

package core.model.game.data.alliance

import kotlinx.serialization.Serializable

@Serializable
data class AllianceMessage(
    val id: String,
    val date: Long,
    val playerId: String,
    val author: String,
    val title: String,
    val message: String
)



================================================================================
ðŸ“„ FICHIER : src\main\kotlin\core\model\game\data\alliance\AllianceMessageList.kt
================================================================================

package core.model.game.data.alliance

import kotlinx.serialization.Serializable
import core.model.game.data.alliance.AllianceMessage

@Serializable
data class AllianceMessageList(
    val list: List<AllianceMessage> = listOf()
)



================================================================================
ðŸ“„ FICHIER : src\main\kotlin\core\model\game\data\alliance\AllianceRank.kt
================================================================================

package core.model.game.data.alliance

import kotlinx.serialization.Serializable

@Serializable
data class AllianceRank(
    val maps: Map<UInt, UInt> = mapOf()
)



================================================================================
ðŸ“„ FICHIER : src\main\kotlin\core\model\game\data\alliance\AllianceRankConstants.kt
================================================================================

package core.model.game.data.alliance

import kotlinx.serialization.Serializable

@Serializable
@JvmInline
value class AllianceRankConstants(val value: UInt)

object AllianceRankConstants_Constants {
    val RANK_1 = AllianceRankConstants(1u)
    val RANK_2 = AllianceRankConstants(2u)
    val RANK_3 = AllianceRankConstants(3u)
    val RANK_4 = AllianceRankConstants(4u)
    val RANK_5 = AllianceRankConstants(5u)
    val RANK_6 = AllianceRankConstants(6u)
    val RANK_7 = AllianceRankConstants(7u)
    val RANK_8 = AllianceRankConstants(8u)
    val RANK_9 = AllianceRankConstants(9u)
    val RANK_10 = AllianceRankConstants(10u)
    val FOUNDER = AllianceRankConstants(10u)
    val TWO_IC = AllianceRankConstants(9u)
}



================================================================================
ðŸ“„ FICHIER : src\main\kotlin\core\model\game\data\alliance\AllianceRankPrivilege.kt
================================================================================

package core.model.game.data.alliance

import kotlinx.serialization.Serializable

@Serializable
@JvmInline
value class AllianceRankPrivilege(val value: UInt)

object AllianceRankPrivilege_Constants {
    val None = AllianceRankPrivilege(0u)
    val ChangeLeadership = AllianceRankPrivilege(1u)
    val Disband = AllianceRankPrivilege(2u)
    val PostMessages = AllianceRankPrivilege(4u)
    val DeleteMessages = AllianceRankPrivilege(8u)
    val InviteMembers = AllianceRankPrivilege(16u)
    val RemoveMembers = AllianceRankPrivilege(32u)
    val PromoteMembers = AllianceRankPrivilege(64u)
    val DemoteMembers = AllianceRankPrivilege(128u)
    val SpendTokens = AllianceRankPrivilege(256u)
    val EditRankNames = AllianceRankPrivilege(512u)
    val EditBanner = AllianceRankPrivilege(1024u)
    val All = AllianceRankPrivilege(1048575u)
}



================================================================================
ðŸ“„ FICHIER : src\main\kotlin\core\model\game\data\alliance\AllianceRound.kt
================================================================================

package core.model.game.data.alliance

import kotlinx.serialization.Serializable
import core.model.game.data.effects.Effect

@Serializable
data class AllianceRound(
    val roundNum: Int?,
    val roundActive: Long?,
    val roundEnd: Long?,
    val roundEffects: List<Effect>?,
    val roundMembers: Int?
)



================================================================================
ðŸ“„ FICHIER : src\main\kotlin\core\model\game\data\alliance\AllianceTask.kt
================================================================================

package core.model.game.data.alliance

import kotlinx.serialization.Serializable

@Serializable
data class AllianceTask(
    val id: String,
    val imageURI: String,
    val iconType: String,
    val goalType: String,
    val goalId: String,
    val goalPerMember: Int,
    val tokensPerMember: Int
)



================================================================================
ðŸ“„ FICHIER : src\main\kotlin\core\model\game\data\alliance\TargetRecord.kt
================================================================================

package core.model.game.data.alliance

import kotlinx.serialization.Serializable

@Serializable
data class TargetRecord(
    val user: String,
    val time: Long
)



================================================================================
ðŸ“„ FICHIER : src\main\kotlin\core\model\game\data\arena\ArenaSession.kt
================================================================================

package core.model.game.data.arena

import kotlinx.serialization.Serializable
import core.model.game.data.assignment.AssignmentStageState

@Serializable
data class ArenaSession(
    val points: Int,
    val state: Map<String, AssignmentStageState> = mapOf()
)



================================================================================
ðŸ“„ FICHIER : src\main\kotlin\core\model\game\data\arena\ArenaStageData.kt
================================================================================

package core.model.game.data.arena

import kotlinx.serialization.Serializable

@Serializable
data class ArenaStageData(
    val srvpoints: Int,
    val objpoints: Int
)



================================================================================
ðŸ“„ FICHIER : src\main\kotlin\core\model\game\data\arena\ArenaSystem.kt
================================================================================

package core.model.game.data.arena

import kotlinx.serialization.Serializable
import core.model.game.data.CooldownCollection
import core.items.model.Item

@Serializable
data class ArenaSystem(
    val id: String,  // cased to ArenaSession, so must be one of the AssignmentType enum
    val srvcount: Int,
    val srvpoints: Int,
    val objpoints: Int,
    val completed: Boolean,
    val points: Int,
    val stage: Int,
    val returnsurvivors: List<String> = listOf(),  // survivor ids
    val cooldown: CooldownCollection = CooldownCollection(),
    val assignsuccess: Boolean,
    val items: List<Item> = listOf()
)



================================================================================
ðŸ“„ FICHIER : src\main\kotlin\core\model\game\data\assignment\AssignmentCollection.kt
================================================================================

package core.model.game.data.assignment

import kotlinx.serialization.Serializable
import core.model.game.data.assignment.AssignmentData

@Serializable
data class AssignmentCollection(
    val list: List<AssignmentData> = listOf()
)



================================================================================
ðŸ“„ FICHIER : src\main\kotlin\core\model\game\data\assignment\AssignmentData.kt
================================================================================

package core.model.game.data.assignment

import kotlinx.serialization.Serializable
import core.model.game.data.assignment.AssignmentStageData

@Serializable
data class AssignmentData(
    val name: String,
    val id: String,
    val started: Boolean,
    val competed: Boolean,
    val stageindex: Int,
    val survivors: List<String> = listOf(),  // survivor ids
    val stagelist: List<AssignmentStageData> = listOf()
)



================================================================================
ðŸ“„ FICHIER : src\main\kotlin\core\model\game\data\assignment\AssignmentResult.kt
================================================================================

package core.model.game.data.assignment

import kotlinx.serialization.Serializable

@Serializable
data class AssignmentResult(
    val id: String,
    val type: String = AssignmentType_Constants.None.value
)



================================================================================
ðŸ“„ FICHIER : src\main\kotlin\core\model\game\data\assignment\AssignmentStageData.kt
================================================================================

package core.model.game.data.assignment

import kotlinx.serialization.Serializable

@Serializable
data class AssignmentStageData(
    val level: Int,
    val time: Int,
    val state: Int,
    val srvcount: Int
)



================================================================================
ðŸ“„ FICHIER : src\main\kotlin\core\model\game\data\assignment\AssignmentStageState.kt
================================================================================

package core.model.game.data.assignment

import kotlinx.serialization.Serializable

@Serializable
@JvmInline
value class AssignmentStageState(val value: UInt)

object AssignmentStageState_Constants {
    val LOCKED = AssignmentStageState(0u)
    val ACTIVE = AssignmentStageState(1u)
    val COMPLETE = AssignmentStageState(2u)
}



================================================================================
ðŸ“„ FICHIER : src\main\kotlin\core\model\game\data\assignment\AssignmentType.kt
================================================================================

package core.model.game.data.assignment

import kotlinx.serialization.Serializable

@Serializable
@JvmInline
value class AssignmentType(val value: String)

object AssignmentType_Constants {
    val None = AssignmentType("None")
    val Raid = AssignmentType("Raid")
    val Arena = AssignmentType("Arena")
}



================================================================================
ðŸ“„ FICHIER : src\main\kotlin\core\model\game\data\bounty\InfectedBounty.kt
================================================================================

package core.model.game.data.bounty

import kotlinx.serialization.Serializable
import core.model.game.data.bounty.InfectedBountyTask

@Serializable
data class InfectedBounty(
    val id: String,
    val completed: Boolean,
    val abandoned: Boolean,
    val viewed: Boolean,
    val rewardItemId: String,
    val issueTime: Long,
    val tasks: List<InfectedBountyTask> = listOf()
)



================================================================================
ðŸ“„ FICHIER : src\main\kotlin\core\model\game\data\bounty\InfectedBountyTask.kt
================================================================================

package core.model.game.data.bounty

import kotlinx.serialization.Serializable
import core.model.game.data.bounty.InfectedBountyTaskCondition

@Serializable
data class InfectedBountyTask(
    val suburb: String,
    val conditions: List<InfectedBountyTaskCondition> = listOf()
)



================================================================================
ðŸ“„ FICHIER : src\main\kotlin\core\model\game\data\bounty\InfectedBountyTaskCondition.kt
================================================================================

package core.model.game.data.bounty

import kotlinx.serialization.Serializable

@Serializable
data class InfectedBountyTaskCondition(
    val zombieType: String,
    val killsRequired: Int,
    val kills: Int
)



================================================================================
ðŸ“„ FICHIER : src\main\kotlin\core\model\game\data\effects\Cooldown.kt
================================================================================

package core.model.game.data.effects

import kotlinx.serialization.Serializable
import dev.deadzone.core.model.game.data.TimerData

@Serializable
data class Cooldown(
    val raw: ByteArray,  // see readObject of Cooldown
    val id: String,
    val type: UInt,
    val subType: String,
    val timer: TimerData
)



================================================================================
ðŸ“„ FICHIER : src\main\kotlin\core\model\game\data\effects\CooldownType.kt
================================================================================

package core.model.game.data.effects

import kotlinx.serialization.Serializable

@Serializable
@JvmInline
value class CooldownType(val value: UInt)

object CooldownType_Constants {
    val Unknown = CooldownType(0u)
    val DisablePvP = CooldownType(1u)
    val Purchase = CooldownType(2u)
    val ResetLeaderAttributes = CooldownType(3u)
    val Raid = CooldownType(4u)
    val Arena = CooldownType(5u)
}



================================================================================
ðŸ“„ FICHIER : src\main\kotlin\core\model\game\data\effects\Effect.kt
================================================================================

package core.model.game.data.effects

import kotlinx.serialization.Serializable
import core.model.game.data.effects.EffectData
import dev.deadzone.core.model.game.data.TimerData
import java.io.ByteArrayOutputStream
import java.io.DataOutputStream

@Serializable
data class Effect(
    val raw: ByteArray = byteArrayOf(),
    val type: String,
    val id: String,
    val lockTime: Int,
    val cooldownTime: Int,
    val started: Boolean = false,
    val timer: TimerData?,
    val lockoutTimer: TimerData?,
    val effectList: List<EffectData> = listOf(),
    val itemId: String?
) {
    companion object {
        fun dummyEffectByteArray(): ByteArray {
            val output = ByteArrayOutputStream()
            val data = DataOutputStream(output)

            // Write header values required before effect list (optional placeholder):
            data.writeUTF("VacationMode") // _type
            data.writeUTF("vacation")  // _id
            data.writeByte(0)         // unused byte
            data.writeInt(0)          // _lockTime
            data.writeInt(0)          // _cooldownTime

            // Timer not present
            data.writeByte(0) // No _timer

            // Lockout timer not present
            data.writeByte(0) // No _lockoutTimer

            // Now the effect list
            val effects = listOf(
                EffectData(100u, 10.0), // BarricadeHealth
                EffectData(101u, 5.0),  // BarricadeCover
                EffectData(102u, 8.0),  // etc...
                EffectData(103u, 4.0)
            )
            data.writeByte(effects.size) // number of effects

            for (effect in effects) {
                data.writeInt(effect.type.toInt())   // short
                data.writeDouble(effect.value)    // float
            }

            // Optional itemId (not present)
            data.writeByte(0) // No itemId

            return output.toByteArray()
        }

        /**
         * Halloween trick pumpkin zombie effect is needed for starting mission
         */
        fun halloweenTrickPumpkinZombie(): ByteArray {
            val effectType = "HalloweenTrickPumpkinZombie"
            val effectId = "halloween-pumpkinzombies"

            val output = ByteArrayOutputStream()
            val data = DataOutputStream(output)

            // Write header
            data.writeUTF(effectType)
            data.writeUTF(effectId)
            data.writeByte(0)         // unused byte
            data.writeInt(0)          // _lockTime
            data.writeInt(0)          // _cooldownTime

            data.writeByte(0)         // No _timer
            data.writeByte(0)         // No _lockoutTimer

            // Write the single Halloween effect
            val effects = listOf(
                // Enable effect to BarricadeHealth for example
                // this is probably actually used to modify zombie health or something
                EffectData(100u, 1.0)
            )

            data.writeByte(effects.size) // number of effects
            for (effect in effects) {
                data.writeInt(effect.type.toInt())   // int (not short)
                data.writeDouble(effect.value)       // double (not float)
            }

            data.writeByte(0) // No itemId

            return output.toByteArray()
        }

        /**
         * Halloween trick pew pew effect is needed for starting mission
         *
         * This is what it should do before checking pewVal > 0
         * pewVal = Network.getInstance().playerData.compound.getEffectValue(EffectType.getTypeValue("HalloweenTrickPewPew"));
         */
        fun halloweenTrickPewPew(): ByteArray {
            val effectType = "HalloweenTrickPewPew"
            val effectId = "halloween-pewpew"

            val output = ByteArrayOutputStream()
            val data = DataOutputStream(output)

            // Write header
            data.writeUTF(effectType)
            data.writeUTF(effectId)
            data.writeByte(0)         // unused byte
            data.writeInt(0)          // _lockTime
            data.writeInt(0)          // _cooldownTime

            data.writeByte(0)         // No _timer
            data.writeByte(0)         // No _lockoutTimer

            // Write the single Halloween effect
            val effects:List<EffectData> = listOf(
                // Enable effect to BarricadeCover for example
                // this is probably actually used to modify gun sound or something
                EffectData(207u, 1.0)
            )

            data.writeByte(effects.size) // number of effects
            for (effect in effects) {
                data.writeInt(effect.type.toInt())   // int (not short)
                data.writeDouble(effect.value)       // double (not float)
            }

            data.writeByte(0) // No itemId

            return output.toByteArray()
        }
    }
}



================================================================================
ðŸ“„ FICHIER : src\main\kotlin\core\model\game\data\effects\EffectData.kt
================================================================================

package core.model.game.data.effects

import kotlinx.serialization.Serializable

@Serializable
data class EffectData(
    val type: UInt,
    val value: Double
)



================================================================================
ðŸ“„ FICHIER : src\main\kotlin\core\model\game\data\effects\EffectSaveFlags.kt
================================================================================

package core.model.game.data.effects

import kotlinx.serialization.Serializable

@Serializable
@JvmInline
value class EffectSaveFlags(val value: UInt)

object EffectSaveFlags_Constants {
    val NONE = EffectSaveFlags(0u)
    val CONSUMABLE = EffectSaveFlags(1u)
    val PERMANENT = EffectSaveFlags(2u)
    val LINKED_ITEM = EffectSaveFlags(4u)
}



================================================================================
ðŸ“„ FICHIER : src\main\kotlin\core\model\game\data\effects\EffectType.kt
================================================================================

package core.model.game.data.effects

import kotlinx.serialization.Serializable

@Serializable
@JvmInline
value class EffectType(val value: String)

object EffectType_Constants {
    val WOOD_PRODUCTION = EffectType("WoodProduction")
    val METAL_PRODUCTION = EffectType("MetalProduction")
    val CLOTH_PRODUCTION = EffectType("ClothProduction")
    val AMMO_PRODUCTION = EffectType("AmmoProduction")
    val FOOD_PRODUCTION = EffectType("FoodProduction")
    val WATER_PRODUCTION = EffectType("WaterProduction")
}



================================================================================
ðŸ“„ FICHIER : src\main\kotlin\core\model\game\data\enemies\EnemyEliteType.kt
================================================================================

package core.model.game.data.enemies

import kotlinx.serialization.Serializable

@Serializable
@JvmInline
value class EnemyEliteType(val value: UInt)

object EnemyEliteType_Constants {
    val NONE = EnemyEliteType(0u)
    val RARE = EnemyEliteType(1u)
    val UNIQUE = EnemyEliteType(2u)
}



================================================================================
ðŸ“„ FICHIER : src\main\kotlin\core\model\game\data\quests\DynamicQuest.kt
================================================================================

package core.model.game.data.quests

import core.model.game.data.MoraleConstants_Constants
import kotlinx.serialization.Serializable
import core.model.game.data.quests.DynamicQuestGoal
import core.model.game.data.quests.DynamicQuestPenalty
import core.model.game.data.quests.DynamicQuestReward
import core.model.game.data.quests.Quest
import io.ktor.util.date.getTimeMillis
import java.io.ByteArrayOutputStream
import java.io.DataOutputStream
import java.nio.ByteBuffer
import java.nio.ByteOrder

@Serializable
data class DynamicQuest(
    val raw: ByteArray,  // see DynamicQuest.as for detail of structure
    val quest: Quest,  // inherited
    val questType: Int,
    val accepted: Boolean,
    val goals: List<DynamicQuestGoal> = listOf(),
    val rewards: List<DynamicQuestReward> = listOf(),
    val failurePenalties: List<DynamicQuestPenalty> = listOf()
) {
    companion object {
        // Still wrong! EOF error
        fun dummy(): ByteArray {
            val buffer = ByteBuffer.allocate(2048).order(ByteOrder.LITTLE_ENDIAN)

            // Version and quest type
            buffer.putShort(2)      // version
            buffer.putShort(1)      // quest type

            // Quest ID
            val questIdBytes = ByteArrayOutputStream()
            DataOutputStream(questIdBytes).writeUTF("comfortQuest")
            buffer.put(questIdBytes.toByteArray())

            // Booleans
            buffer.put(0) // accepted
            buffer.put(0) // complete
            buffer.put(0) // collected
            buffer.put(0) // failed

            // End Time
            buffer.putDouble(getTimeMillis().toDouble())

            // ----- Goals -----
            buffer.putShort(1) // 1 goal
            val goalData = ByteArrayOutputStream()
            val goalOut = DataOutputStream(goalData)
            goalOut.writeUTF("statInc")
            goalOut.writeUTF("zombieKills")
            goalOut.writeInt(10)
            val goalBytes = goalData.toByteArray()
            buffer.putShort(goalBytes.size.toShort())
            buffer.put(goalBytes)

            // ----- Rewards -----
            buffer.putShort(1) // 1 reward
            val rewardData = ByteArrayOutputStream()
            val rewardOut = DataOutputStream(rewardData)
            rewardOut.writeShort(0)      // type = xp
            rewardOut.writeInt(500)      // xp amount
            val rewardBytes = rewardData.toByteArray()
            buffer.putShort(rewardBytes.size.toShort())
            buffer.put(rewardBytes)

            // ----- Failure Penalties -----
            buffer.putShort(1) // 1 penalty
            val penaltyData = ByteArrayOutputStream()
            val penaltyOut = DataOutputStream(penaltyData)
            penaltyOut.writeShort(2)         // type = morale
            penaltyOut.writeUTF("comfort")      // morale type
            penaltyOut.writeDouble(5.0)      // morale amount
            val penaltyBytes = penaltyData.toByteArray()
            buffer.putShort(penaltyBytes.size.toShort())
            buffer.put(penaltyBytes)

            // ----- Version-specific field (v2+) -----
            buffer.putInt(12345678)

            return buffer.array().sliceArray(0 until buffer.position())
        }
    }
}



================================================================================
ðŸ“„ FICHIER : src\main\kotlin\core\model\game\data\quests\DynamicQuestGoal.kt
================================================================================

package core.model.game.data.quests

import kotlinx.serialization.Serializable
import core.model.game.data.quests.DynamicQuestGoalEnum

@Serializable
data class DynamicQuestGoal(
    val type: DynamicQuestGoalEnum,
    val stat: String?,
    val survivor: String?,
    val goal: Int
)



================================================================================
ðŸ“„ FICHIER : src\main\kotlin\core\model\game\data\quests\DynamicQuestGoalEnum.kt
================================================================================

package core.model.game.data.quests

import kotlinx.serialization.Serializable

@Serializable
@JvmInline
value class DynamicQuestGoalEnum(val value: String)

object DynamicQuestGoalEnum_Constants {
    val statInc = DynamicQuestGoalEnum("statInc")
    val xpInc = DynamicQuestGoalEnum("xpInc")
}



================================================================================
ðŸ“„ FICHIER : src\main\kotlin\core\model\game\data\quests\DynamicQuestPenalty.kt
================================================================================

package core.model.game.data.quests

import kotlinx.serialization.Serializable
import core.model.game.data.quests.DynamicQuestPenaltyEnum
import core.model.game.data.MoraleConstants

@Serializable
data class DynamicQuestPenalty(
    val type: DynamicQuestPenaltyEnum,
    val value: String, // actually string and int
    val moraleType: MoraleConstants?,  // Only if type == "morale"
)



================================================================================
ðŸ“„ FICHIER : src\main\kotlin\core\model\game\data\quests\DynamicQuestPenaltyEnum.kt
================================================================================

package core.model.game.data.quests

import kotlinx.serialization.Serializable

@Serializable
@JvmInline
value class DynamicQuestPenaltyEnum(val value: String)

object DynamicQuestPenaltyEnum_Constants {
    val morale = DynamicQuestPenaltyEnum("morale")
}



================================================================================
ðŸ“„ FICHIER : src\main\kotlin\core\model\game\data\quests\DynamicQuestReward.kt
================================================================================

package core.model.game.data.quests

import kotlinx.serialization.Serializable
import core.model.game.data.quests.DynamicQuestRewardEnum
import core.model.game.data.MoraleConstants

@Serializable
data class DynamicQuestReward(
    val type: DynamicQuestRewardEnum,
    val value: String, // actually string and integer
    val moraleType: MoraleConstants?,  // Only if type == "morale"
)



================================================================================
ðŸ“„ FICHIER : src\main\kotlin\core\model\game\data\quests\DynamicQuestRewardEnum.kt
================================================================================

package core.model.game.data.quests

import kotlinx.serialization.Serializable

@Serializable
@JvmInline
value class DynamicQuestRewardEnum(val value: String)

object DynamicQuestRewardEnum_Constants {
    val xp = DynamicQuestRewardEnum("xp")
    val itm = DynamicQuestRewardEnum("itm")
    val morale = DynamicQuestRewardEnum("morale")
}



================================================================================
ðŸ“„ FICHIER : src\main\kotlin\core\model\game\data\quests\DynamicQuestType.kt
================================================================================

package core.model.game.data.quests

import kotlinx.serialization.Serializable

@Serializable
@JvmInline
value class DynamicQuestType(val value: Int)

object DynamicQuestType_Constants {
    val SURVIVOR_REQUEST = DynamicQuestType(0)
}



================================================================================
ðŸ“„ FICHIER : src\main\kotlin\core\model\game\data\quests\GlobalQuestData.kt
================================================================================

package core.model.game.data.quests

import kotlinx.serialization.Serializable
import core.model.game.data.quests.GQDataObj

@Serializable
data class GlobalQuestData(
    val raw: ByteArray,
    val map: Map<String, GQDataObj> = mapOf()
)



================================================================================
ðŸ“„ FICHIER : src\main\kotlin\core\model\game\data\quests\GQDataObj.kt
================================================================================

package core.model.game.data.quests

import kotlinx.serialization.Serializable

@Serializable
data class GQDataObj(
    val id: String,
    val collected: Boolean,
    val contributed: Boolean,
    val contributedLevel: Int,
    val statValues: List<UInt> = listOf()
)



================================================================================
ðŸ“„ FICHIER : src\main\kotlin\core\model\game\data\quests\Quest.kt
================================================================================

package core.model.game.data.quests

import kotlinx.serialization.Serializable

@Serializable
data class Quest(
    val id: String,
    val started: Boolean,
    val complete: Boolean,
    val conditionProgress: List<Int> = listOf(),
    val collected: Boolean,
    val index: Int,
    val important: Boolean,
    val startImageURI: String?,
    val completeImageURI: String?,
    val isAchievement: Boolean,
    val level: Int,
    val secretLevel: UInt = 0u,
    val type: String,
    val xml: String?,  // uses XML type actually
    val new: Boolean,
    val children: List<Quest> = listOf(),
    val startTime: Long?,
    val endTime: Long?,
    val failed: Boolean,
    val timeBased: Boolean,
    val visible: Boolean = true
)



================================================================================
ðŸ“„ FICHIER : src\main\kotlin\core\model\game\data\quests\QuestConstants.kt
================================================================================

import kotlinx.serialization.Serializable

@Serializable
@JvmInline
value class QuestSecret(val value: UInt)

@Serializable
@JvmInline
value class QuestType(val value: String)

@Serializable
@JvmInline
value class QuestTracking(val value: String)

object QuestConstants {
    val SECRET_NONE = QuestSecret(0u)
    val SECRET_TITLE_ONLY = QuestSecret(1u)
    val SECRET_HIDDEN = QuestSecret(2u)

    val TYPE_ACHIEVEMENT = QuestType("achievement")
    val TYPE_GENERAL = QuestType("general")
    val TYPE_COMBAT = QuestType("combat")
    val TYPE_SCAVENGE = QuestType("scavenge")
    val TYPE_CONSTRUCTION = QuestType("construct")
    val TYPE_COMMUNITY = QuestType("community")
    val TYPE_WORLD = QuestType("world")
    val TYPE_DYNAMIC = QuestType("dynamic")

    val TRACKING_TRACKED = QuestTracking("tracked")
    val TRACKING_UNTRACKED = QuestTracking("untracked")
    val TRACKING_MAX_TRACKED = QuestTracking("maxTracked")
}



================================================================================
ðŸ“„ FICHIER : src\main\kotlin\core\model\game\data\raid\RaidData.kt
================================================================================

package core.model.game.data.raid

import kotlinx.serialization.Serializable
import core.model.game.data.assignment.AssignmentData

@Serializable
data class RaidData(
    val assignmentData: AssignmentData,
    val ptsPerSurvivor: Int,
    val maxSurvivorMissionPoints: Int,
    val points: Int
)



================================================================================
ðŸ“„ FICHIER : src\main\kotlin\core\model\game\data\raid\RaidStageData.kt
================================================================================

package core.model.game.data.raid

import kotlinx.serialization.Serializable
import core.model.game.data.assignment.AssignmentStageData

@Serializable
data class RaidStageData(
    val assignmentStageData: AssignmentStageData,
    val objectiveIndex: Int,
    val objectiveState: RaidStageObjectiveState = RaidStageObjectiveState_Constants.INCOMPLETE,
    val objectiveXML: String?,  // actually an XML type
    val imageURI: String
)



================================================================================
ðŸ“„ FICHIER : src\main\kotlin\core\model\game\data\raid\RaidStageObjectiveState.kt
================================================================================

package core.model.game.data.raid

import kotlinx.serialization.Serializable

@Serializable
@JvmInline
value class RaidStageObjectiveState(val value: UInt)

object RaidStageObjectiveState_Constants {
    val INCOMPLETE = RaidStageObjectiveState(0u)
    val COMPLETE = RaidStageObjectiveState(1u)
    val FAILED = RaidStageObjectiveState(2u)
}



================================================================================
ðŸ“„ FICHIER : src\main\kotlin\core\model\game\data\research\ResearchEffect.kt
================================================================================

package core.model.game.data.research

import kotlinx.serialization.Serializable

@Serializable
@JvmInline
value class ResearchEffect(val value: String)

object ResearchEffect_Constants {
    val Unknown = ResearchEffect("Unknown")
    val FoodWaterProductionRate = ResearchEffect("FoodWaterProductionRate")
    val FoodWaterProductionCapacity = ResearchEffect("FoodWaterProductionCapacity")
    val BuildingMaterialProductionRate = ResearchEffect("BuildingMaterialProductionRate")
    val BuildingMaterialProductionCapacity = ResearchEffect("BuildingMaterialProductionCapac")
    val AmmoProductionRate = ResearchEffect("AmmoProductionRate")
    val AmmoProductionCapacity = ResearchEffect("AmmoProductionCapacity")
    val FuelProductionRate = ResearchEffect("FuelProductionRate")
    val FuelProductionCapacity = ResearchEffect("FuelProductionCapacity")
    val ExplosiveTrapDamage = ResearchEffect("ExplosiveTrapDamage")
    val ExplosiveTrapDisarmChance = ResearchEffect("ExplosiveTrapDisarmChance")
    val ExplosiveTrapDisarmTime = ResearchEffect("ExplosiveTrapDisarmTime")
    val ExplosiveTrapDetectRange = ResearchEffect("ExplosiveTrapDetectRange")
    val ExplosiveTrapHealth = ResearchEffect("ExplosiveTrapHealth")
    val WireTrapDamage = ResearchEffect("WireTrapDamage")
    val WireTrapDisarmChance = ResearchEffect("WireTrapDisarmChance")
    val WireTrapDisarmTime = ResearchEffect("WireTrapDisarmTime")
    val WireTrapDetectRange = ResearchEffect("WireTrapDetectRange")
    val WireTrapHealth = ResearchEffect("WireTrapHealth")
    val BallisticTrapDamage = ResearchEffect("BallisticTrapDamage")
    val BallisticTrapDisarmChance = ResearchEffect("BallisticTrapDisarmChance")
    val BallisticTrapDisarmTime = ResearchEffect("BallisticTrapDisarmTime")
    val BallisticTrapDetectRange = ResearchEffect("BallisticTrapDetectRange")
    val BallisticTrapHealth = ResearchEffect("BallisticTrapHealth")
    val BarricadeHealth = ResearchEffect("BarricadeHealth")
    val BarricadeCover = ResearchEffect("BarricadeCover")
    val BarricadeSecurity = ResearchEffect("BarricadeSecurity")
    val DoorHealth = ResearchEffect("DoorHealth")
    val DoorCover = ResearchEffect("DoorCover")
    val DoorSecurity = ResearchEffect("DoorSecurity")
    val WatchtowerHealth = ResearchEffect("WatchtowerHealth")
    val WatchtowerCover = ResearchEffect("WatchtowerCover")
    val WatchtowerSecurity = ResearchEffect("WatchtowerSecurity")
    val BarrierHealth = ResearchEffect("BarrierHealth")
    val BarrierCover = ResearchEffect("BarrierCover")
    val BarrierSecurity = ResearchEffect("BarrierSecurity")
    val FoodWaterStorageCapacity = ResearchEffect("FoodWaterStorageCapacity")
    val BuildingMaterialStorageCapacity = ResearchEffect("BuildingMaterialStorageCapacity")
    val AmmoStorageCapacity = ResearchEffect("AmmoStorageCapacity")
    val IndoorComfort = ResearchEffect("IndoorComfort")
    val OutdoorComfort = ResearchEffect("OutdoorComfort")
    val MoralePenalty = ResearchEffect("MoralePenalty")
    val FirearmDamage = ResearchEffect("FirearmDamage")
    val MeleeDamage = ResearchEffect("MeleeDamage")
    val GearHealth = ResearchEffect("GearHealth")
    val BuildingRepairCost = ResearchEffect("BuildingRepairCost")
    val CraftingQuality = ResearchEffect("CraftingQuality")
    val CraftingCost = ResearchEffect("CraftingCost")
    val MissionReturnTime = ResearchEffect("MissionReturnTime")
    val MissionAutoSuccess = ResearchEffect("MissionAutoSuccess")
    val MissionXP = ResearchEffect("MissionXP")
    val LootFindJunk = ResearchEffect("LootFindJunk")
    val LootFindQuality = ResearchEffect("LootFindQuality")
    val InjuryRecoveryTime = ResearchEffect("InjuryRecoveryTime")
}



================================================================================
ðŸ“„ FICHIER : src\main\kotlin\core\model\game\data\research\ResearchState.kt
================================================================================

package core.model.game.data.research

import kotlinx.serialization.Serializable

@Serializable
data class ResearchState(
    val active: List<ResearchTask>,
    val levels: Map<String, Int>,
)



================================================================================
ðŸ“„ FICHIER : src\main\kotlin\core\model\game\data\research\ResearchTask.kt
================================================================================

package core.model.game.data.research

import kotlinx.serialization.Serializable

@Serializable
data class ResearchTask(
    val start: Long,
    val id: String,
    val length: Int,
    val category: String,
    val group: String,
    val level: Int,
    val completed: Boolean,
)



================================================================================
ðŸ“„ FICHIER : src\main\kotlin\core\model\game\data\skills\SkillCollection.kt
================================================================================

package core.model.game.data.skills

import kotlinx.serialization.Serializable
import core.model.game.data.skills.SkillState

@Serializable
data class SkillCollection(
    val map: Map<String, SkillState>? = mapOf()
)



================================================================================
ðŸ“„ FICHIER : src\main\kotlin\core\model\game\data\skills\SkillState.kt
================================================================================

package core.model.game.data.skills

import kotlinx.serialization.Serializable

@Serializable
data class SkillState(
    val xp: Int,
    val level: Int
)



================================================================================
ðŸ“„ FICHIER : src\main\kotlin\core\model\game\data\store\StoreCollection.kt
================================================================================

package core.model.game.data.store

import kotlinx.serialization.Serializable

@Serializable
data class StoreCollection(
    val key: String,
    val admin: Boolean = false,
    val new: Boolean = false,
    val individualPurchases: Boolean = true,
    val levelMin: Int = 0,
    val levelMax: Int = 2147483647,
    val start: Long?,
    val end: Long?,
    val items: List<String> = listOf(),
    val PriceCoins: Int = 0,
    val PriceUSD: Int = 0,
    val PriceKKR: Int = 0
)



================================================================================
ðŸ“„ FICHIER : src\main\kotlin\core\model\game\data\store\StoreItem.kt
================================================================================

package core.model.game.data.store

import kotlinx.serialization.Serializable
import core.items.model.Item

@Serializable
data class StoreItem(
    val key: String,
    val item: Item,
    val new: Boolean,
    val deal: Boolean,
    val promo: Boolean,
    val collectionOnly: Boolean,
    val admin: Boolean,
    val sale: String?,
    val priority: Int,
    val levelMin: Int = 0,
    val levelMax: Int = 2147483647,
    val start: Long?,
    val end: Long?,
    val PriceCoins: Int?,  // pricecoins else usd or kkr
    val priceUSD: Double?,
    val priceKKR: Int?,
    val orgPriceFUEL: Int?,
    val orgPriceUSD: Int?,
    val orgPriceKKR: Int?,
    val showOrgPrice: Boolean
)



================================================================================
ðŸ“„ FICHIER : src\main\kotlin\core\model\game\data\store\StoreSale.kt
================================================================================

package core.model.game.data.store

import kotlinx.serialization.Serializable

@Serializable
data class StoreSale(
    val admin: Boolean,
    val savingPerc: Double,
    val levelMin: Int = 0,
    val levelMax: Int = 2147483647,
    val start: Long,
    val end: Long,
    val items: List<String>?,  // assigned to itemKeys, a list of string
)



================================================================================
ðŸ“„ FICHIER : src\main\kotlin\core\model\network\RemotePlayerData.kt
================================================================================

package core.model.network

import kotlinx.serialization.Serializable

@Serializable
data class RemotePlayerData(
    val name: String?,
    val nickname: String?,
    val level: Int?,
    val serviceUserId: String?,
    val serviceAvatar: String?,
    val serviceAvatarURL: String?,
    val lastLogin: Long?,
    val allianceId: String?,
    val allianceTag: String?,
    val allianceName: String?,
    val bounty: Int?,
    val bountyAllTime: Int?,
    val bountyAllTimeCount: Int?,
    val bountyEarnings: Int?,
    val bountyCollectCount: Int?,
    val bountyDate: Long?,
    val online: Boolean?,
    val onlineTimestamp: Long?,
    val raidLockout: Long?,
    val underAttack: Boolean?,
    val protected: Boolean?,
    val protected_start: Long?,
    val protected_length: Int?,
    val banned: Boolean?
)



================================================================================
ðŸ“„ FICHIER : src\main\kotlin\core\model\network\RemotePlayerDataConstants.kt
================================================================================

package core.model.network

import kotlinx.serialization.Serializable

@Serializable
@JvmInline
value class RemotePlayerDataConstants(val value: String)

object RemotePlayerDataConstants_Constants {
    val RELATIONSHIP_FRIEND = RemotePlayerDataConstants("friend")
    val RELATIONSHIP_NEUTRAL = RemotePlayerDataConstants("neutral")
    val RELATIONSHIP_ENEMY = RemotePlayerDataConstants("enemy")
}



================================================================================
ðŸ“„ FICHIER : src\main\kotlin\core\survivor\SurvivorRepository.kt
================================================================================

package core.survivor

import core.model.game.data.Survivor

interface SurvivorRepository {
    suspend fun getSurvivors(playerId: String): Result<List<Survivor>>
    suspend fun addSurvivor(playerId: String, survivor: Survivor): Result<Unit>
    suspend fun updateSurvivor(playerId: String, srvId: String, updatedSurvivor: Survivor): Result<Unit>
    suspend fun updateSurvivors(playerId: String, survivors: List<Survivor>): Result<Unit>
}



================================================================================
ðŸ“„ FICHIER : src\main\kotlin\core\survivor\SurvivorRepositoryMaria.kt
================================================================================

package core.survivor

import core.model.game.data.Survivor
import data.collection.PlayerObjects
import data.db.PlayerObjectsTable
import data.db.suspendedTransactionResult
import org.jetbrains.exposed.sql.Database
import org.jetbrains.exposed.sql.selectAll
import org.jetbrains.exposed.sql.update
import utils.JSON

class SurvivorRepositoryMaria(private val database: Database) : SurvivorRepository {
    override suspend fun getSurvivors(playerId: String): Result<List<Survivor>> {
        return database.suspendedTransactionResult {
            PlayerObjectsTable
                .selectAll()
                .where { PlayerObjectsTable.playerId eq playerId }
                .singleOrNull()
                ?.let { row ->
                    val playerObjects =
                        JSON.decode(PlayerObjects.serializer(), row[PlayerObjectsTable.dataJson])
                    playerObjects.survivors
                } ?: throw NoSuchElementException("getSurvivors: No PlayerObjects found with id=$playerId")
        }
    }

    override suspend fun addSurvivor(playerId: String, survivor: Survivor): Result<Unit> {
        return database.suspendedTransactionResult {
            val currentData = PlayerObjectsTable
                .selectAll()
                .where { PlayerObjectsTable.playerId eq playerId }
                .singleOrNull()
                ?.let { row ->
                    JSON.decode(PlayerObjects.serializer(), row[PlayerObjectsTable.dataJson])
                } ?: throw NoSuchElementException("addSurvivor: No PlayerObjects found with id=$playerId")

            val survivors = currentData.survivors.toMutableList()
            val updatedData = currentData.copy(survivors = survivors + survivor)

            val rowsUpdated = PlayerObjectsTable.update({ PlayerObjectsTable.playerId eq playerId }) {
                it[dataJson] = JSON.encode(PlayerObjects.serializer(), updatedData)
            }
            if (rowsUpdated == 0) {
                throw IllegalStateException("Failed to update survivors in addSurvivor for playerId=$playerId")
            }
        }
    }

    override suspend fun updateSurvivor(playerId: String, srvId: String, updatedSurvivor: Survivor): Result<Unit> {
        return database.suspendedTransactionResult {
            val currentData = PlayerObjectsTable
                .selectAll()
                .where { PlayerObjectsTable.playerId eq playerId }
                .singleOrNull()
                ?.let { row ->
                    JSON.decode(PlayerObjects.serializer(), row[PlayerObjectsTable.dataJson])
                } ?: throw NoSuchElementException("updateSurvivor: No PlayerObjects found with id=$playerId")

            val survivors = currentData.survivors.toMutableList()
            val survivorIndex = survivors.indexOfFirst { it.id == srvId }
            if (survivorIndex == -1) {
                throw NoSuchElementException("Survivor for playerId=$playerId srvId=$srvId not found")
            }

            survivors[survivorIndex] = updatedSurvivor
            val updatedData = currentData.copy(survivors = survivors)

            val rowsUpdated = PlayerObjectsTable.update({ PlayerObjectsTable.playerId eq playerId }) {
                it[dataJson] = JSON.encode(PlayerObjects.serializer(), updatedData)
            }
            if (rowsUpdated == 0) {
                throw IllegalStateException("Failed to update survivors in updateSurvivor for playerId=$playerId")
            }
        }
    }

    override suspend fun updateSurvivors(playerId: String, survivors: List<Survivor>): Result<Unit> {
        return database.suspendedTransactionResult {
            val currentData = PlayerObjectsTable
                .selectAll()
                .where { PlayerObjectsTable.playerId eq playerId }
                .singleOrNull()
                ?.let { row ->
                    JSON.decode(PlayerObjects.serializer(), row[PlayerObjectsTable.dataJson])
                } ?: throw NoSuchElementException("updateSurvivors: No PlayerObjects with id=$playerId")

            val updatedData = currentData.copy(survivors = survivors)

            val rowsUpdated = PlayerObjectsTable.update({ PlayerObjectsTable.playerId eq playerId }) {
                it[dataJson] = JSON.encode(PlayerObjects.serializer(), updatedData)
            }
            if (rowsUpdated == 0) {
                throw IllegalStateException("Failed to update survivors in updateSurvivors for playerId=$playerId")
            }
        }
    }
}



================================================================================
ðŸ“„ FICHIER : src\main\kotlin\core\survivor\SurvivorService.kt
================================================================================

package core.survivor

import core.PlayerService
import core.model.game.data.Survivor
import utils.LogConfigSocketError
import utils.Logger
import kotlin.Result.Companion.failure

class SurvivorService(
    val survivorLeaderId: String,
    private val survivorRepository: SurvivorRepository
) : PlayerService {
    private val survivors = mutableListOf<Survivor>()
    private lateinit var playerId: String

    fun getSurvivorLeader(): Survivor {
        return survivors.find { it.id == survivorLeaderId }
            ?: throw NoSuchElementException("Survivor leader is missing for playerId=$playerId")
    }

    fun getAllSurvivors(): List<Survivor> {
        return survivors
    }

    suspend fun addNewSurvivor(survivor: Survivor): Result<Unit> {
        val result = survivorRepository.addSurvivor(playerId, survivor)
        result.onFailure {
            Logger.error(LogConfigSocketError) { "Error on addNewSurvivor: ${it.message}" }
        }
        result.onSuccess {
            survivors.add(survivor)
        }
        return result
    }

    suspend fun updateSurvivor(
        srvId: String,
        updateAction: suspend (Survivor) -> Survivor
    ): Result<Unit> {
        val idx = survivors.indexOfFirst { it.id == srvId }
        if (idx == -1) {
            Logger.error(LogConfigSocketError) { "Survivor with id $srvId not found" }
            return failure(NoSuchElementException("Survivor with id $srvId not found"))
        }
        val currentSurvivor = survivors[idx]
        val updatedSurvivor = updateAction(currentSurvivor)
        val result = survivorRepository.updateSurvivor(playerId, srvId, updatedSurvivor)
        result.onFailure {
            Logger.error(LogConfigSocketError) { "Error on updateSurvivor: ${it.message}" }
        }
        result.onSuccess {
            survivors[idx] = updatedSurvivor
        }
        return result
    }

    suspend fun updateSurvivors(
        survivors: List<Survivor>
    ): Result<Unit> {
        val result = survivorRepository.updateSurvivors(playerId, survivors)
        result.onFailure {
            Logger.error(LogConfigSocketError) { "Error on updateSurvivors: ${it.message}" }
        }
        result.onSuccess {
            this.survivors.clear()
            this.survivors.addAll(survivors)
        }
        return result
    }

    override suspend fun init(playerId: String): Result<Unit> {
        return runCatching {
            this.playerId = playerId
            val loadedSurvivors = survivorRepository.getSurvivors(playerId).getOrThrow()
            if (loadedSurvivors.isEmpty()) {
                Logger.warn(LogConfigSocketError) { "Survivors for playerId=$playerId is empty" }
            }
            survivors.addAll(loadedSurvivors.map { srv ->
                srv.copy(
                    lastName = srv.lastName.takeIf { it.isNotEmpty() } ?: "DZ",
                )
            })
        }
    }

    override suspend fun close(playerId: String): Result<Unit> {
        return Result.success(Unit)
    }
}


================================================================================
ðŸ“„ FICHIER : src\main\kotlin\core\survivor\model\AttireData.kt
================================================================================

package core.model.game.data

import kotlinx.serialization.Serializable
import core.model.game.data.AttireOverlay

@Serializable
data class AttireData(
    val id: String = "",
    val type: String = "",
    val model: String = "",
    val texture: String = "",
    val tint: Double = 0.0,
    val hue: Double = 0.0,
    val brightness: Double = 0.0,
    val modifiedTextureURI: String = "",
    val modifiedTexture: Boolean = false,
    val uniqueTexture: Boolean = false,
    val overlays: List<AttireOverlay> = listOf(),
    val children: List<AttireData> = listOf(),
    val flags: Int = 0
)



================================================================================
ðŸ“„ FICHIER : src\main\kotlin\core\survivor\model\AttireFlags.kt
================================================================================

package core.model.game.data

import kotlinx.serialization.Serializable

@Serializable
@JvmInline
value class AttireFlags(val value: UInt)

object AttireFlags_Constants {
    val NONE = AttireFlags(0u)
    val NO_HAIR = AttireFlags(1u)
    val NO_FACIAL_HAIR = AttireFlags(2u)
    val MOUTH = AttireFlags(4u)
    val EYES = AttireFlags(8u)
    val HEAD = AttireFlags(16u)
    val BACK = AttireFlags(32u)
    val CHEST = AttireFlags(64u)
    val NECK = AttireFlags(128u)
    val WAIST_FRONT = AttireFlags(256u)
    val WAIST_BACK = AttireFlags(512u)
    val LEFT_SHOULDER = AttireFlags(1024u)
    val LEFT_UPPER_ARM = AttireFlags(2048u)
    val LEFT_LOWER_ARM = AttireFlags(4096u)
    val LEFT_UPPER_LEG = AttireFlags(8192u)
    val LEFT_LOWER_LEG = AttireFlags(16384u)
    val RIGHT_SHOULDER = AttireFlags(32768u)
    val RIGHT_UPPER_ARM = AttireFlags(65536u)
    val RIGHT_LOWER_ARM = AttireFlags(131072u)
    val RIGHT_UPPER_LEG = AttireFlags(262144u)
    val RIGHT_LOWER_LEG = AttireFlags(524288u)
    val UPPER_BODY = AttireFlags(1048576u)
    val LOWER_BODY = AttireFlags(2097152u)
    val ALL = AttireFlags(16777215u)
    val CLOTHING = AttireFlags(3145728u)
    val ACCESSORIES = AttireFlags(13631487u)
}



================================================================================
ðŸ“„ FICHIER : src\main\kotlin\core\survivor\model\AttireOverlay.kt
================================================================================

package core.model.game.data

import kotlinx.serialization.Serializable

@Serializable
data class AttireOverlay(
    val type: String,
    val texture: String
)



================================================================================
ðŸ“„ FICHIER : src\main\kotlin\core\survivor\model\AttributeClass.kt
================================================================================

package core.model.game.data

import kotlinx.serialization.Serializable

@Serializable
@JvmInline
value class AttributeClass(val value: String)

object AttributeClass_Constants {
    val FIGHTING_1 = AttributeClass("combatProjectile")
    val FIGHTING_2 = AttributeClass("combatMelee")
    val SCAVENGING_1 = AttributeClass("scavenge")
    val ENGINEERING_1 = AttributeClass("combatImprovised")
    val ENGINEERING_2 = AttributeClass("trapDisarming")
    val MEDIC_1 = AttributeClass("healing")
    val RECON_1 = AttributeClass("movement")
    val RECON_2 = AttributeClass("trapSpotting")
}



================================================================================
ðŸ“„ FICHIER : src\main\kotlin\core\survivor\model\AttributeOptions.kt
================================================================================

package core.model.game.data

import kotlinx.serialization.Serializable

@Serializable
data class AttributeOptions(
    val INCLUDE_NONE: Int = 0,
    val INCLUDE_INJURIES: Int = 1,
    val INCLUDE_MORALE: Int = 2,
    val INCLUDE_AI_EFFECTS: Int = 4,
    val INCLUDE_RESEARCH: Int = 8,
    val INCLUDE_EFFECTS: Int = 16,
    val INCLUDE_ALL: Int = 31,
    val NO_MORALE: Int = 29,
    val NO_INJURY: Int = 30
)



================================================================================
ðŸ“„ FICHIER : src\main\kotlin\core\survivor\model\Attributes.kt
================================================================================

package core.model.game.data

import kotlinx.serialization.Serializable

@Serializable
data class Attributes(
    val health: Double = 0.0,
    val combatProjectile: Double = 0.0,
    val combatMelee: Double = 0.0,
    val combatImprovised: Double = 0.0,
    val movement: Double = 0.0,
    val scavenge: Double = 0.0,
    val healing: Double = 0.0,
    val trapSpotting: Double = 0.0,
    val trapDisarming: Double = 0.0,
    val injuryChance: Double = 0.0
) {
    companion object {
        fun dummy(): Attributes {
            return Attributes(
                health = 100.0,
                combatProjectile = 2.0,
                combatMelee = 2.0,
                combatImprovised = 2.0,
                movement = 2.0,
                scavenge = 2.0,
                healing = 2.0,
                trapSpotting = 2.0,
                trapDisarming = 2.0,
                injuryChance = 2.0,
            )
        }
    }
}



================================================================================
ðŸ“„ FICHIER : src\main\kotlin\core\survivor\model\AttributesConstants.kt
================================================================================

package core.model.game.data

import kotlinx.serialization.Serializable

@Serializable
@JvmInline
value class AttributesConstants(val value: String)

object AttributesConstants_Constants {
    val COMBAT_IMPROVISED = AttributesConstants("combatImprovised")
    val COMBAT_PROJECTILE = AttributesConstants("combatProjectile")
    val COMBAT_MELEE = AttributesConstants("combatMelee")
    val MOVEMENT_SPEED = AttributesConstants("movement")
    val SCAVENGE_SPEED = AttributesConstants("scavenge")
    val HEALING = AttributesConstants("healing")
    val TRAP_SPOTTING = AttributesConstants("trapSpotting")
    val TRAP_DISARMING = AttributesConstants("trapDisarming")
    val HEALTH = AttributesConstants("health")
    val INJURY_CHANCE = AttributesConstants("injuryChance")
}



================================================================================
ðŸ“„ FICHIER : src\main\kotlin\core\survivor\model\Gender.kt
================================================================================

package core.model.game.data

import kotlinx.serialization.Serializable

@Serializable
@JvmInline
value class Gender(val value: String)

object Gender_Constants {
    val MALE = Gender("male")
    val FEMALE = Gender("female")
    val UNKNOWN = Gender("unknown")
}



================================================================================
ðŸ“„ FICHIER : src\main\kotlin\core\survivor\model\HumanAppearance.kt
================================================================================

package core.model.game.data

import kotlinx.serialization.Serializable

// Humanapppearance is the base class of Survivorapppearance
// the game can't take both, because Survivorapppearance doesn't have deserialize method
// and it delegates deserialize to Humanapppearance itself
// The difference between Humanapppearance and Survivorapppearance is within clothing_upper/lower
// and accessories field
@Serializable
data class HumanAppearance(
    val forceHair: Boolean = false,
    val hideGear: Boolean = false,
    val hairColor: String = "black",
    val skinColor: String? = null,
    val hair: String? = null,
    val facialHair: String? = null,
    val clothing_upper: String? = null,
    val clothing_lower: String? = null,
    val accessories: List<String>? = null
) {
    companion object {
        fun parse(app: Map<*, *>): HumanAppearance {
            return HumanAppearance(
                forceHair = app["forceHair"] as? Boolean ?: false,
                hideGear = app["hideGear"] as? Boolean ?: false,
                hairColor = app["hairColor"] as? String ?: "black",
                skinColor = app["skinColor"] as? String,
                hair = app["hair"] as? String,
                facialHair = app["facialHair"] as? String,
                clothing_upper = app["upper"] as? String,
                clothing_lower = app["lower"] as? String,
                accessories = (app["accessories"] as? List<*>)?.mapNotNull { it as? String }
            )
        }
    }
}



================================================================================
ðŸ“„ FICHIER : src\main\kotlin\core\survivor\model\Morale.kt
================================================================================

package core.model.game.data

import kotlinx.serialization.Serializable

@Serializable
data class Morale(
    val maps: Map<String, Double> = mapOf()
)



================================================================================
ðŸ“„ FICHIER : src\main\kotlin\core\survivor\model\MoraleConstants.kt
================================================================================

package core.model.game.data

import kotlinx.serialization.Serializable

@Serializable
@JvmInline
value class MoraleConstants(val value: String)

object MoraleConstants_Constants {
    val EFFECT_INJURY = MoraleConstants("injury")
    val EFFECT_MISSION_COMPLETE = MoraleConstants("missionComplete")
    val EFFECT_FOOD = MoraleConstants("food")
    val EFFECT_WATER = MoraleConstants("water")
    val EFFECT_SECURITY = MoraleConstants("security")
    val EFFECT_COMFORT = MoraleConstants("comfort")
    val EFFECT_AVERAGE_SURVIVOR = MoraleConstants("avgSurvivor")
    val EFFECT_DAILY_QUEST_COMPLETED = MoraleConstants("dailyQuestCompleted")
    val EFFECT_DAILY_QUEST_FAILED = MoraleConstants("dailyQuestFailed")
}



================================================================================
ðŸ“„ FICHIER : src\main\kotlin\core\survivor\model\Survivor.kt
================================================================================

package core.model.game.data

import core.data.AdminData
import core.model.game.data.SurvivorAppearance.Companion.toHumanAppearance
import core.survivor.model.injury.Injury
import core.survivor.model.injury.InjuryList
import dev.deadzone.core.model.game.data.TimerData
import utils.UUID
import kotlinx.serialization.Serializable

@Serializable
data class Survivor(
    val id: String = UUID.new(),
    val title: String,
    val firstName: String = "",
    val lastName: String = "DZ",
    val gender: String,
    val portrait: String? = null,
    val classId: String,
    val morale: Map<String, Double> = emptyMap(),
    val injuries: List<Injury> = emptyList(),
    val level: Int = 0,
    val xp: Int = 0,
    val missionId: String? = null,
    val assignmentId: String? = null,
    val reassignTimer: TimerData? = null,
    val appearance: HumanAppearance? = null, // HumanAppearance > SurvivorAppearance
    val scale: Double = 1.22,
    val voice: String,
    val accessories: Map<String, String> = emptyMap(),  // key is parsed to int, string is accessory id
    val maxClothingAccessories: Int = 1
) {
    companion object {
        fun playerM(): Survivor {
            return Survivor(
                id = AdminData.PLAYER_SRV_ID,
                title = "MercifulLeader",
                firstName = "Merciful",
                lastName = "Leader",
                gender = Gender_Constants.MALE.value,
                portrait = null,
                classId = SurvivorClassConstants_Constants.PLAYER.value,
                morale = Morale().maps,
                injuries = InjuryList().list,
                level = 59,
                xp = 1000,
                missionId = null,
                assignmentId = null,
                reassignTimer = null,
                appearance = SurvivorAppearance.playerM().toHumanAppearance(),
                scale = 1.22,
                voice = "asian-m",
                accessories = mapOf(),
                maxClothingAccessories = 10
            )
        }

        fun reconF(): Survivor {
            return Survivor(
                id = AdminData.RECON_SRV_ID,
                title = "NoisyRecon",
                firstName = "Noisy",
                lastName = "Recon",
                gender = Gender_Constants.FEMALE.value,
                portrait = null,
                classId = SurvivorClassConstants_Constants.RECON.value,
                morale = Morale().maps,
                injuries = InjuryList().list,
                level = 59,
                xp = 1000,
                missionId = null,
                assignmentId = null,
                reassignTimer = null,
                appearance = SurvivorAppearance.reconF().toHumanAppearance(),
                scale = 1.22,
                voice = "white-f",
                accessories = mapOf(),
                maxClothingAccessories = 10
            )
        }

        fun fighterM(): Survivor {
            return Survivor(
                id = AdminData.FIGHTER_SRV_ID,
                title = "AngryFighter",
                firstName = "Angry",
                lastName = "Fighter",
                gender = Gender_Constants.MALE.value,
                portrait = null,
                classId = SurvivorClassConstants_Constants.FIGHTER.value,
                morale = Morale().maps,
                injuries = InjuryList().list,
                level = 59,
                xp = 1000,
                missionId = null,
                assignmentId = null,
                reassignTimer = null,
                appearance = SurvivorAppearance.fighterM().toHumanAppearance(),
                scale = 1.18,
                voice = "asian-m",
                accessories = mapOf(),
                maxClothingAccessories = 10
            )
        }
    }
}



================================================================================
ðŸ“„ FICHIER : src\main\kotlin\core\survivor\model\SurvivorAppearance.kt
================================================================================

package core.model.game.data

import kotlinx.serialization.Serializable

// subclass of HumanAppearance though its deserialize don't work
@Serializable
data class SurvivorAppearance(
    val skinColor: String?,
    val upper: String?,
    val lower: String?,
    val hair: String?,
    val facialHair: String?,
    val hairColor: String?,
    val forceHair: Boolean = false,
    val hideGear: Boolean = false
) {
    companion object {
        fun SurvivorAppearance.toHumanAppearance(): HumanAppearance {
            return HumanAppearance(
                skinColor = this.skinColor,
                hair = this.hair,
                facialHair = this.facialHair,
                clothing_upper = this.upper,
                clothing_lower = this.lower,
                hairColor = this.hairColor ?: "black",
                forceHair = this.forceHair,
                hideGear = this.hideGear,
                accessories = emptyList()
            )
        }

        fun playerM(): SurvivorAppearance {
            return SurvivorAppearance(
                skinColor = "light1",
                upper = "hoodie",
                lower = "pants",
                hair = "hair1",
                facialHair = "facialHair0",
                hairColor = "darkBrown",
                forceHair = false,
                hideGear = false
            )
        }

        fun fighterM(): SurvivorAppearance {
            return SurvivorAppearance(
                skinColor = "light1",
                upper = "class_fighter",
                lower = "class_fighter",
                hair = "hair1",
                facialHair = "facialHair0",
                hairColor = "darkBrown",
                forceHair = false,
                hideGear = false
            )
        }

        fun reconF(): SurvivorAppearance {
            return SurvivorAppearance(
                skinColor = "light1",
                upper = "class_recon",
                lower = "class_recon",
                hair = "hair1",
                facialHair = null,
                hairColor = "darkBrown",
                forceHair = false,
                hideGear = false
            )
        }
    }
}



================================================================================
ðŸ“„ FICHIER : src\main\kotlin\core\survivor\model\SurvivorAppearanceConstants.kt
================================================================================

package core.model.game.data

import kotlinx.serialization.Serializable

@Serializable
@JvmInline
value class SurvivorAppearanceConstants(val value: String)

object SurvivorAppearanceConstants_Constants {
    val SLOT_UPPER_BODY = SurvivorAppearanceConstants("clothing_upper")
    val SLOT_LOWER_BODY = SurvivorAppearanceConstants("clothing_lower")
}



================================================================================
ðŸ“„ FICHIER : src\main\kotlin\core\survivor\model\SurvivorClass.kt
================================================================================

package core.model.game.data

import kotlinx.serialization.Serializable
import core.model.game.data.Attributes
import core.model.game.data.SurvivorClassWeapons

@Serializable
data class SurvivorClass(
    val id: String,
    val maleUpper: String,
    val maleLower: String,
    val maleSkinOverlay: String?,
    val femaleUpper: String,
    val femaleLower: String,
    val femaleSkinOverlay: String?,
    val baseAttributes: Attributes,
    val levelAttributes: Attributes,
    val hideHair: Boolean = false,
    val weapons: List<SurvivorClassWeapons>
)



================================================================================
ðŸ“„ FICHIER : src\main\kotlin\core\survivor\model\SurvivorClassConstants.kt
================================================================================

package core.model.game.data

import kotlinx.serialization.Serializable

@Serializable
@JvmInline
value class SurvivorClassConstants(val value: String)

object SurvivorClassConstants_Constants {
    val FIGHTER = SurvivorClassConstants("fighter")
    val MEDIC = SurvivorClassConstants("medic")
    val SCAVENGER = SurvivorClassConstants("scavenger")
    val ENGINEER = SurvivorClassConstants("engineer")
    val RECON = SurvivorClassConstants("recon")
    val PLAYER = SurvivorClassConstants("player")
    val UNASSIGNED = SurvivorClassConstants("unassigned")
}



================================================================================
ðŸ“„ FICHIER : src\main\kotlin\core\survivor\model\SurvivorClassWeapons.kt
================================================================================

package core.model.game.data

import kotlinx.serialization.Serializable
import core.model.game.data.WeaponClass
import core.model.game.data.WeaponType

@Serializable
data class SurvivorClassWeapons(
    val classes: List<WeaponClass> = listOf(),
    val types: List<WeaponType> = listOf()
)



================================================================================
ðŸ“„ FICHIER : src\main\kotlin\core\survivor\model\SurvivorCollection.kt
================================================================================

package core.model.game.data

import kotlinx.serialization.Serializable
import core.model.game.data.Survivor

@Serializable
data class SurvivorCollection(
    val list: List<Survivor> = listOf()
) {
    companion object {
        fun playerOnly(): List<Survivor> {
            return listOf(
                Survivor.playerM(),
            )
        }

        fun threeSurvivors(): List<Survivor> {
            return listOf(
                Survivor.playerM(),
                Survivor.fighterM(),
                Survivor.reconF(),
            )
        }
    }
}



================================================================================
ðŸ“„ FICHIER : src\main\kotlin\core\survivor\model\SurvivorData.kt
================================================================================

package core.model.game.data

import kotlinx.serialization.Serializable

@Serializable
data class SurvivorData(
    val id: String,
    val startXP: Int,
    val startLevel: Int,
    val endXP: Int,
    val endLevel: Int
) {
    companion object {
        fun dummy(id: String): SurvivorData {
            return SurvivorData(
                id = id,
                startXP = 0,
                startLevel = 2,
                endXP = 1000,
                endLevel = 4,
            )
        }
    }
}



================================================================================
ðŸ“„ FICHIER : src\main\kotlin\core\survivor\model\SurvivorLoadout.kt
================================================================================

package core.model.game.data

import kotlinx.serialization.Serializable
import core.model.game.data.Survivor
import core.model.game.data.SurvivorLoadoutData

@Serializable
data class SurvivorLoadout(
    val type: String,
    val survivor: Survivor,
    val weapon: SurvivorLoadoutData,
    val gearPassive: SurvivorLoadoutData,
    val gearActive: SurvivorLoadoutData,
    val supressChanges: Boolean = false
)



================================================================================
ðŸ“„ FICHIER : src\main\kotlin\core\survivor\model\SurvivorLoadoutConstants.kt
================================================================================

package core.model.game.data

import kotlinx.serialization.Serializable

@Serializable
@JvmInline
value class SurvivorLoadoutConstants(val value: String)

object SurvivorLoadoutConstants_Constants {
    val SLOT_WEAPON = SurvivorLoadoutConstants("weapon")
    val SLOT_GEAR_PASSIVE = SurvivorLoadoutConstants("gearPassive")
    val SLOT_GEAR_ACTIVE = SurvivorLoadoutConstants("gearActive")
    val TYPE_OFFENCE = SurvivorLoadoutConstants("offence")
    val TYPE_DEFENCE = SurvivorLoadoutConstants("defence")
}



================================================================================
ðŸ“„ FICHIER : src\main\kotlin\core\survivor\model\SurvivorLoadoutData.kt
================================================================================

package core.model.game.data

import kotlinx.serialization.Serializable
import core.items.model.Item

@Serializable
data class SurvivorLoadoutData(
    val type: String,
    val item: Item,
    val quantity: Int,
    val loadout: SurvivorLoadout
)



================================================================================
ðŸ“„ FICHIER : src\main\kotlin\core\survivor\model\SurvivorLoadoutEntry.kt
================================================================================

package core.model.game.data

import core.data.AdminData
import kotlinx.serialization.Serializable

@Serializable
data class SurvivorLoadoutEntry(
    val weapon: String,  // weapon id
    val gear1: String,  // gear id
    val gear2: String,  // gear id
) {
    companion object {
        fun playerLoudout(): SurvivorLoadoutEntry {
            return SurvivorLoadoutEntry(
                weapon = AdminData.PLAYER_WEP_ID,
                gear1 = "",
                gear2 = "",
            )
        }

        fun fighterLoadout(): SurvivorLoadoutEntry {
            return SurvivorLoadoutEntry(
                weapon = AdminData.FIGHTER_WEP_ID,
                gear1 = "",
                gear2 = "",
            )
        }

        fun reconLoadout(): SurvivorLoadoutEntry {
            return SurvivorLoadoutEntry(
                weapon = AdminData.RECON_WEP_ID,
                gear1 = "",
                gear2 = "",
            )
        }
    }
}



================================================================================
ðŸ“„ FICHIER : src\main\kotlin\core\survivor\model\SurvivorState.kt
================================================================================

package core.model.game.data

import kotlinx.serialization.Serializable

@Serializable
@JvmInline
value class SurvivorState(val value: UInt)

object SurvivorState_Constants {
    val AVAILABLE = SurvivorState(0u)
    val ON_MISSION = SurvivorState(1u)
    val ON_TASK = SurvivorState(2u)
    val REASSIGNING = SurvivorState(4u)
    val ON_ASSIGNMENT = SurvivorState(8u)
}



================================================================================
ðŸ“„ FICHIER : src\main\kotlin\core\survivor\model\injury\Injury.kt
================================================================================

package core.survivor.model.injury

import kotlinx.serialization.Serializable
import dev.deadzone.core.model.game.data.TimerData

@Serializable
data class Injury(
    val id: String,
    val type: String,
    val location: String,
    val severity: String,
    val damage: Double,
    val morale: Double,
    val timer: TimerData?
)



================================================================================
ðŸ“„ FICHIER : src\main\kotlin\core\survivor\model\injury\InjuryCause.kt
================================================================================

package core.survivor.model.injury

import kotlinx.serialization.Serializable

@Serializable
@JvmInline
value class InjuryCause(val value: String)

object InjuryCause_Constants {
    val UNKNOWN = InjuryCause("unknown")
    val BLUNT = InjuryCause("blunt")
    val SHARP = InjuryCause("sharp")
    val HEAT = InjuryCause("heat")
    val BULLET = InjuryCause("bullet")
    val ILLNESS = InjuryCause("illness")
}



================================================================================
ðŸ“„ FICHIER : src\main\kotlin\core\survivor\model\injury\InjuryList.kt
================================================================================

package core.survivor.model.injury

import kotlinx.serialization.Serializable

@Serializable
data class InjuryList(
    val list: List<Injury> = listOf(),  // casted to array in code
)



================================================================================
ðŸ“„ FICHIER : src\main\kotlin\core\survivor\model\injury\InjurySeverity.kt
================================================================================

package core.survivor.model.injury

import kotlinx.serialization.Serializable

@Serializable
@JvmInline
value class InjurySeverity(val value: String)

object InjurySeverity_Constants {
    val MINOR = InjurySeverity("minor")
    val MODERATE = InjurySeverity("moderate")
    val SERIOUS = InjurySeverity("serious")
    val SEVERE = InjurySeverity("severe")
    val CRITICAL = InjurySeverity("critical")
}



================================================================================
ðŸ“„ FICHIER : src\main\kotlin\data\collection\Inventory.kt
================================================================================

package data.collection

import core.data.AdminData
import core.data.GameDefinition
import core.items.ItemFactory
import core.items.model.Item
import core.items.model.combineItems
import kotlinx.serialization.Serializable

/**
 * Inventory table
 */
@Serializable
data class Inventory(
    val playerId: String, // reference to UserDocument
    val inventory: List<Item> = emptyList(),
    val schematics: ByteArray = byteArrayOf(),  // see line 643 of Inventory.as
) {
    companion object {
        fun admin(): Inventory {
            val items = listOf(
                ItemFactory.createItemFromId(idInXML = "crate-tutorial"),
                ItemFactory.createItemFromId(idInXML = "crate-tutorial"),
                ItemFactory.createItemFromId(idInXML = "crate-tutorial"),
                ItemFactory.createItemFromId(idInXML = "crate-tutorial"),
                ItemFactory.createItemFromId(idInXML = "crate-tutorial"),
                ItemFactory.createItemFromId(idInXML = "crate-tutorial"),
                ItemFactory.createItemFromId(idInXML = "crate-tutorial"),
                ItemFactory.createItemFromId(idInXML = "crate-tutorial"),
                ItemFactory.createItemFromId(idInXML = "crate-tutorial"),
                ItemFactory.createItemFromId(idInXML = "crate-tutorial"),
                ItemFactory.createItemFromId(idInXML = "key-herc-level-1").copy(new = false, qty = 10u),
                ItemFactory.createItemFromId(idInXML = "grenade-christmas-2"),
                ItemFactory.createItemFromId(idInXML = "p90").copy(level = 37, quality = 3),
                ItemFactory.createItemFromId(idInXML = "sword-unique").copy(level = 49, quality = 51),
                ItemFactory.createItemFromId(itemId = AdminData.FIGHTER_WEP_ID, "bladesaw")
                    .copy(level = 58, quality = 50),
                ItemFactory.createItemFromId(itemId = AdminData.PLAYER_WEP_ID, "freedom-desert-eagle-2-replica")
                    .copy(level = 49, quality = 100),
                ItemFactory.createItemFromId(itemId = AdminData.RECON_WEP_ID, "fal-winter-2017-3")
                    .copy(level = 59, quality = 100),
                ItemFactory.createItemFromId(idInXML = "goldAK47-special").copy(level = 19, quality = 100, bind = 1u),
                ItemFactory.createItemFromId(idInXML = "helmet-wasteland-knight").copy(level = 50, quality = 100),
                ItemFactory.createItemFromId(idInXML = "christmas-canned-meat")
            )

            return Inventory(
                playerId = AdminData.PLAYER_ID,
                inventory = items,
                schematics = byteArrayOf()
            )
        }

        fun newgame(pid: String): Inventory {
            // give good weapon to do tutorial easier
            val free = setOf(
                "morningStar-2",
                "PKP",
                "an94",
                "goldAK47-special",
                "fal-winter-2017-3",
                "M249",
                "m107cq-arctic",
                "shotgun",
                "axe-halloween-2015-birthday-2017",
                "polehammer-halloween-2015-birthday-2017",
            )
            val items = listOf(
                Item(type = "pocketKnife"),
                Item(type = "lawson22"),
                Item(type = free.random())
            )
            return Inventory(
                playerId = pid,
                inventory = items,
                schematics = byteArrayOf()
            )
        }
    }

    override fun equals(other: Any?): Boolean {
        if (this === other) return true
        if (javaClass != other?.javaClass) return false

        other as Inventory

        if (inventory != other.inventory) return false
        if (!schematics.contentEquals(other.schematics)) return false

        return true
    }

    override fun hashCode(): Int {
        var result = inventory.hashCode()
        result = 31 * result + schematics.contentHashCode()
        return result
    }
}

/**
 * Combine two inventory semantically (according to the game definition).
 */
fun Inventory.combineItems(other: Inventory, gameDefinition: GameDefinition): Inventory {
    return this.copy(inventory = this.inventory.combineItems(other.inventory, gameDefinition))
}



================================================================================
ðŸ“„ FICHIER : src\main\kotlin\data\collection\NeighborHistory.kt
================================================================================

package data.collection

import core.model.network.RemotePlayerData
import kotlinx.serialization.Serializable

/**
 * Neighbor history table
 */
@Serializable
data class NeighborHistory(
    val playerId: String, // reference to UserDocument
    val map: Map<String, @Serializable RemotePlayerData>? = emptyMap()
) {
    companion object {
        fun empty(pid: String): NeighborHistory {
            return NeighborHistory(
                playerId = pid,
                map = emptyMap()
            )
        }
    }
}


================================================================================
ðŸ“„ FICHIER : src\main\kotlin\data\collection\PlayerAccount.kt
================================================================================

package data.collection

import core.data.AdminData
import io.ktor.util.date.getTimeMillis
import kotlinx.serialization.Serializable

@Serializable
data class PlayerAccount(
    val playerId: String,
    val hashedPassword: String,
    val email: String = "",
    val displayName: String,
    val avatarUrl: String,
    val createdAt: Long,
    val lastLogin: Long,
    val countryCode: String? = null,
    val serverMetadata: ServerMetadata,
) {
    companion object {
        fun admin(): PlayerAccount {
            return PlayerAccount(
                playerId = AdminData.PLAYER_ID,
                hashedPassword = AdminData.PASSWORD,
                email = AdminData.EMAIL,
                displayName = AdminData.DISPLAY_NAME,
                avatarUrl = AdminData.AVATAR_URL,
                createdAt = getTimeMillis(),
                lastLogin = getTimeMillis(),
                countryCode = AdminData.COUNTRY_CODE,
                serverMetadata = ServerMetadata()
            )
        }
    }
}

@Serializable
data class ServerMetadata(
    val notes: String? = null,
    val flags: Map<String, Boolean> = emptyMap(),
    val extra: Map<String, String> = emptyMap(),
)


================================================================================
ðŸ“„ FICHIER : src\main\kotlin\data\collection\PlayerObjects.kt
================================================================================

package data.collection

import core.data.AdminData
import core.metadata.model.ByteArrayAsBase64Serializer
import core.model.data.HighActivity
import core.model.data.Notification
import core.metadata.model.PlayerFlags
import core.metadata.model.toByteArray
import core.model.data.user.AbstractUser
import core.model.game.data.Attributes
import core.model.game.data.BatchRecycleJob
import core.model.game.data.BuildingCollection
import core.model.game.data.BuildingLike
import core.model.game.data.GameResources
import core.model.game.data.Gender_Constants
import core.model.game.data.MissionData
import core.model.game.data.Survivor
import core.model.game.data.SurvivorAppearance
import core.model.game.data.SurvivorAppearance.Companion.toHumanAppearance
import core.model.game.data.SurvivorClassConstants_Constants
import core.model.game.data.SurvivorCollection
import core.model.game.data.SurvivorLoadoutEntry
import core.model.game.data.Task
import core.model.game.data.TaskCollection
import core.model.game.data.assignment.AssignmentData
import core.model.game.data.bounty.InfectedBounty
import core.model.game.data.effects.Effect
import core.model.game.data.quests.GQDataObj
import core.model.game.data.research.ResearchState
import core.model.game.data.skills.SkillState
import core.model.network.RemotePlayerData
import io.ktor.util.date.getTimeMillis
import kotlinx.serialization.Serializable

@Serializable
data class PlayerObjects(
    val playerId: String,
    val key: String,
    val user: Map<String, AbstractUser> = emptyMap(),
    val admin: Boolean,
    @Serializable(with = ByteArrayAsBase64Serializer::class)
    val flags: ByteArray = PlayerFlags.newgame(),
    val nickname: String?,
    val playerSurvivor: String?,
    val levelPts: UInt = 0u,
    val restXP: Int = 0,
    val oneTimePurchases: List<String> = emptyList(),
    val neighbors: Map<String, RemotePlayerData>?,
    val friends: Map<String, RemotePlayerData>?,
    val research: ResearchState?,
    val skills: Map<String, SkillState>?,
    val resources: GameResources,
    val survivors: List<Survivor>,
    val playerAttributes: Attributes,
    val buildings: List<BuildingLike>,
    val rally: Map<String, List<String>>?,
    val tasks: List<Task>,
    val missions: List<MissionData>?,
    val assignments: List<AssignmentData>?,
    val effects: List<ByteArray>?,
    val globalEffects: List<ByteArray>?,
    val cooldowns: Map<String, ByteArray>?,
    val batchRecycles: List<BatchRecycleJob>?,
    val offenceLoadout: Map<String, SurvivorLoadoutEntry>?,
    val defenceLoadout: Map<String, SurvivorLoadoutEntry>?,
    val quests: ByteArray?,
    val questsCollected: ByteArray?,
    val achievements: ByteArray?,
    val dailyQuest: ByteArray?,
    val questsTracked: String?,
    val gQuestsV2: Map<String, GQDataObj>?,
    val bountyCap: Int,
    val lastLogout: Long?,
    val dzBounty: InfectedBounty?,
    val nextDZBountyIssue: Long,
    val highActivity: HighActivity?,
    val notifications: List<Notification?>?,
) {
    companion object {
        fun admin(): PlayerObjects {
            val mockFlags = IntRange(0, 8).map { false }.toByteArray()

            return PlayerObjects(
                playerId = AdminData.PLAYER_ID,
                key = AdminData.PLAYER_DATA_KEY,
                admin = true,
                flags = PlayerFlags.skipTutorial(),
                nickname = AdminData.DISPLAY_NAME,
                playerSurvivor = AdminData.PLAYER_SRV_ID,
                neighbors = null,
                friends = null,
                research = ResearchState(active = listOf(), mapOf()),
                skills = null,
                resources = GameResources(
                    cash = 100000,
                    wood = 99999,
                    metal = 99999,
                    cloth = 99999,
                    food = 200,
                    water = 200,
                    ammunition = 99999
                ),
                survivors = SurvivorCollection.threeSurvivors(),
                playerAttributes = Attributes.dummy(),
                buildings = BuildingCollection.starterBase(),
                rally = mapOf(),
                tasks = TaskCollection().list,
                missions = listOf(MissionData.dummy(AdminData.PLAYER_SRV_ID)),
                assignments = null,
                effects = listOf(Effect.halloweenTrickPumpkinZombie(), Effect.halloweenTrickPewPew()),
                globalEffects = listOf(Effect.halloweenTrickPumpkinZombie(), Effect.halloweenTrickPewPew()),
                cooldowns = null,
                batchRecycles = null,
                offenceLoadout = mapOf(
                    AdminData.PLAYER_SRV_ID to SurvivorLoadoutEntry.playerLoudout(),
                    AdminData.FIGHTER_SRV_ID to SurvivorLoadoutEntry.fighterLoadout(),
                    AdminData.RECON_SRV_ID to SurvivorLoadoutEntry.reconLoadout(),
                ),
                defenceLoadout = mapOf(
                    AdminData.PLAYER_SRV_ID to SurvivorLoadoutEntry.playerLoudout(),
                    AdminData.FIGHTER_SRV_ID to SurvivorLoadoutEntry.fighterLoadout(),
                    AdminData.RECON_SRV_ID to SurvivorLoadoutEntry.reconLoadout(),
                ),
                quests = mockFlags,
                questsCollected = mockFlags,
                achievements = mockFlags,
                dailyQuest = null,
                questsTracked = null,
                gQuestsV2 = null,
                bountyCap = 0,
                lastLogout = getTimeMillis() - 100000,
                dzBounty = null,
                nextDZBountyIssue = 1230768000000,
                highActivity = null,
                notifications = null,
            )
        }

        fun newgame(pid: String, nickname: String, playerSrvId: String): PlayerObjects {
            val mockFlags = IntRange(0, 8).map { false }.toByteArray()
            val playerSrv = Survivor(
                id = playerSrvId,
                title = nickname,
                firstName = nickname,
                lastName = "DZ",
                gender = Gender_Constants.MALE.value,
                portrait = null,
                classId = SurvivorClassConstants_Constants.PLAYER.value,
                morale = emptyMap(),
                injuries = emptyList(),
                level = 1,
                xp = 0,
                missionId = null,
                assignmentId = null,
                reassignTimer = null,
                appearance = SurvivorAppearance.playerM().toHumanAppearance(),
                voice = "asian-m",
                accessories = emptyMap(),
                maxClothingAccessories = 4
            )

            return PlayerObjects(
                playerId = pid,
                key = pid,
                admin = false,
                flags = PlayerFlags.create(nicknameVerified = false),
                nickname = null,
                playerSurvivor = playerSrvId,
                neighbors = null,
                friends = null,
                research = ResearchState(active = emptyList(), levels = emptyMap()),
                skills = null,
                resources = GameResources(
                    // cash should be 100, ammo should be 150
                    cash = 1000, wood = 300, metal = 300,
                    cloth = 300, food = 25, water = 25, ammunition = 1000
                ),
                survivors = listOf(playerSrv),
                playerAttributes = Attributes.dummy(),
                buildings = BuildingCollection.starterBase(),
                rally = emptyMap(),
                tasks = TaskCollection().list,
                missions = listOf(MissionData.dummy(AdminData.PLAYER_SRV_ID)),
                assignments = null,
                effects = listOf(Effect.halloweenTrickPumpkinZombie(), Effect.halloweenTrickPewPew()),
                globalEffects = listOf(Effect.halloweenTrickPumpkinZombie(), Effect.halloweenTrickPewPew()),
                cooldowns = null,
                batchRecycles = null,
                offenceLoadout = emptyMap(),
                defenceLoadout = emptyMap(),
                quests = mockFlags,
                questsCollected = mockFlags,
                achievements = mockFlags,
                dailyQuest = null,
                questsTracked = null,
                gQuestsV2 = null,
                bountyCap = 0,
                lastLogout = null,
                dzBounty = null,
                nextDZBountyIssue = 1765074185294,
                highActivity = null,
                notifications = null,
            )
        }
    }

    override fun equals(other: Any?): Boolean {
        if (this === other) return true
        if (javaClass != other?.javaClass) return false

        other as PlayerObjects

        if (admin != other.admin) return false
        if (restXP != other.restXP) return false
        if (bountyCap != other.bountyCap) return false
        if (lastLogout != other.lastLogout) return false
        if (nextDZBountyIssue != other.nextDZBountyIssue) return false
        if (key != other.key) return false
        if (user != other.user) return false
        if (!flags.contentEquals(other.flags)) return false
        if (nickname != other.nickname) return false
        if (playerSurvivor != other.playerSurvivor) return false
        if (levelPts != other.levelPts) return false
        if (oneTimePurchases != other.oneTimePurchases) return false
        if (neighbors != other.neighbors) return false
        if (friends != other.friends) return false
        if (research != other.research) return false
        if (skills != other.skills) return false
        if (resources != other.resources) return false
        if (survivors != other.survivors) return false
        if (playerAttributes != other.playerAttributes) return false
        if (buildings != other.buildings) return false
        if (rally != other.rally) return false
        if (tasks != other.tasks) return false
        if (missions != other.missions) return false
        if (assignments != other.assignments) return false
        if (effects != other.effects) return false
        if (globalEffects != other.globalEffects) return false
        if (cooldowns != other.cooldowns) return false
        if (batchRecycles != other.batchRecycles) return false
        if (offenceLoadout != other.offenceLoadout) return false
        if (defenceLoadout != other.defenceLoadout) return false
        if (!quests.contentEquals(other.quests)) return false
        if (!questsCollected.contentEquals(other.questsCollected)) return false
        if (!achievements.contentEquals(other.achievements)) return false
        if (!dailyQuest.contentEquals(other.dailyQuest)) return false
        if (questsTracked != other.questsTracked) return false
        if (gQuestsV2 != other.gQuestsV2) return false
        if (dzBounty != other.dzBounty) return false
        if (highActivity != other.highActivity) return false
        if (notifications != other.notifications) return false

        return true
    }

    override fun hashCode(): Int {
        var result = admin.hashCode()
        result = 31 * result + restXP
        result = 31 * result + bountyCap
        result = 31 * result + (lastLogout?.hashCode() ?: 0)
        result = 31 * result + nextDZBountyIssue.hashCode()
        result = 31 * result + key.hashCode()
        result = 31 * result + user.hashCode()
        result = 31 * result + flags.contentHashCode()
        result = 31 * result + nickname.hashCode()
        result = 31 * result + playerSurvivor.hashCode()
        result = 31 * result + levelPts.hashCode()
        result = 31 * result + oneTimePurchases.hashCode()
        result = 31 * result + (neighbors?.hashCode() ?: 0)
        result = 31 * result + (friends?.hashCode() ?: 0)
        result = 31 * result + (research?.hashCode() ?: 0)
        result = 31 * result + (skills?.hashCode() ?: 0)
        result = 31 * result + resources.hashCode()
        result = 31 * result + survivors.hashCode()
        result = 31 * result + playerAttributes.hashCode()
        result = 31 * result + buildings.hashCode()
        result = 31 * result + (rally?.hashCode() ?: 0)
        result = 31 * result + tasks.hashCode()
        result = 31 * result + (missions?.hashCode() ?: 0)
        result = 31 * result + (assignments?.hashCode() ?: 0)
        result = 31 * result + (effects?.hashCode() ?: 0)
        result = 31 * result + (globalEffects?.hashCode() ?: 0)
        result = 31 * result + (cooldowns?.hashCode() ?: 0)
        result = 31 * result + (batchRecycles?.hashCode() ?: 0)
        result = 31 * result + (offenceLoadout?.hashCode() ?: 0)
        result = 31 * result + (defenceLoadout?.hashCode() ?: 0)
        result = 31 * result + (quests?.contentHashCode() ?: 0)
        result = 31 * result + (questsCollected?.contentHashCode() ?: 0)
        result = 31 * result + (achievements?.contentHashCode() ?: 0)
        result = 31 * result + (dailyQuest?.hashCode() ?: 0)
        result = 31 * result + (questsTracked?.hashCode() ?: 0)
        result = 31 * result + (gQuestsV2?.hashCode() ?: 0)
        result = 31 * result + (dzBounty?.hashCode() ?: 0)
        result = 31 * result + (highActivity?.hashCode() ?: 0)
        result = 31 * result + (notifications?.hashCode() ?: 0)
        return result
    }
}


================================================================================
ðŸ“„ FICHIER : src\main\kotlin\data\db\BigDB.kt
================================================================================

package data.db

import data.collection.Inventory
import data.collection.NeighborHistory
import data.collection.PlayerAccount
import data.collection.PlayerObjects

enum class CollectionName {
    PLAYER_ACCOUNT_COLLECTION, PLAYER_OBJECTS_COLLECTION,
    NEIGHBOR_HISTORY_COLLECTION, INVENTORY_COLLECTION,
}

/**
 * Representation of PlayerIO BigDB
 */
interface BigDB {
    // each method load the corresponding collection
    suspend fun loadPlayerAccount(playerId: String): PlayerAccount?
    suspend fun loadPlayerObjects(playerId: String): PlayerObjects?
    suspend fun loadNeighborHistory(playerId: String): NeighborHistory?
    suspend fun loadInventory(playerId: String): Inventory?

    /**
     * A cheat solution to update [PlayerObjects] without relying on repository CRUD methods.
     *
     * This updates the entire JSON with the given [updatedPlayerObjects].
     */
    suspend fun updatePlayerObjectsJson(playerId: String, updatedPlayerObjects: PlayerObjects)

    /**
     * Get a particular collection without type safety.
     *
     * Typically used when repository independent of DB implementation needs
     * to its implementor collection.
     */
    fun <T> getCollection(name: CollectionName): T

    /**
     * Create a user with the provided username and password.
     *
     * This method is defined in BigDB because it require access to all 5 collections,
     * in which a focused repository do not own.
     *
     * @return playerId (UUID) of the newly created user.
     */
    suspend fun createUser(username: String, password: String): String

    suspend fun shutdown()
}



================================================================================
ðŸ“„ FICHIER : src\main\kotlin\data\db\BigDBMariaImpl.kt
================================================================================

package data.db

import com.toxicbakery.bcrypt.Bcrypt
import core.data.AdminData
import data.collection.*
import io.ktor.util.date.*
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.launch
import org.jetbrains.exposed.sql.*
import org.jetbrains.exposed.sql.transactions.experimental.newSuspendedTransaction
import utils.Emoji
import utils.JSON
import utils.Logger
import utils.UUID
import kotlin.io.encoding.Base64
import kotlin.let

object PlayerAccounts : Table("player_accounts") {
    val playerId = varchar("player_id", 36).uniqueIndex()
    val hashedPassword = text("hashed_password")
    val email = varchar("email", 255)
    val displayName = varchar("display_name", 100)
    val avatarUrl = varchar("avatar_url", 500)
    val createdAt = long("created_at")
    val lastLogin = long("last_login")
    val countryCode = varchar("country_code", 10).nullable()
    val serverMetadataJson = text("server_metadata_json")
    override val primaryKey = PrimaryKey(playerId)
}

object PlayerObjectsTable : Table("player_objects") {
    val playerId = varchar("player_id", 36).uniqueIndex()
    val dataJson = text("data_json")
    override val primaryKey = PrimaryKey(playerId)
}

object NeighborHistoryTable : Table("neighbor_history") {
    val playerId = varchar("player_id", 36).uniqueIndex()
    val dataJson = text("data_json")
    override val primaryKey = PrimaryKey(playerId)
}

object InventoryTable : Table("inventory") {
    val playerId = varchar("player_id", 36).uniqueIndex()
    val dataJson = text("data_json")
    override val primaryKey = PrimaryKey(playerId)
}

class BigDBMariaImpl(val database: Database, private val adminEnabled: Boolean) : BigDB {
    init {
        CoroutineScope(Dispatchers.IO).launch {
            setupDatabase()
        }
    }

    private suspend fun setupDatabase() {
        try {
            database.suspendedTransaction {
                SchemaUtils.create(PlayerAccounts, PlayerObjectsTable, NeighborHistoryTable, InventoryTable)
            }
            val count = database.suspendedTransaction {
                PlayerAccounts.selectAll().count()
            }
            Logger.info { "${Emoji.Database} MariaDB: User table ready, contains $count users." }
            if (adminEnabled) {
                val adminExists = database.suspendedTransaction {
                    PlayerAccounts.selectAll().where { PlayerAccounts.playerId eq AdminData.PLAYER_ID }.count() > 0
                }
                if (!adminExists) {
                    val start = getTimeMillis()
                    database.suspendedTransaction {
                        val adminAccount = PlayerAccount.admin()
                        val adminObjects = PlayerObjects.admin()
                        val adminNeighbor = NeighborHistory.empty(AdminData.PLAYER_ID)
                        val adminInventory = Inventory.admin()

                        PlayerAccounts.insert {
                            it[playerId] = adminAccount.playerId
                            it[hashedPassword] = adminAccount.hashedPassword
                            it[email] = adminAccount.email
                            it[displayName] = adminAccount.displayName
                            it[avatarUrl] = adminAccount.avatarUrl
                            it[createdAt] = adminAccount.createdAt
                            it[lastLogin] = adminAccount.lastLogin
                            it[countryCode] = adminAccount.countryCode
                            it[serverMetadataJson] = JSON.encode(adminAccount.serverMetadata)
                        }

                        PlayerObjectsTable.insert {
                            it[playerId] = adminObjects.playerId
                            it[dataJson] = JSON.encode(adminObjects)
                        }

                        NeighborHistoryTable.insert {
                            it[playerId] = adminNeighbor.playerId
                            it[dataJson] = JSON.encode(adminNeighbor)
                        }

                        InventoryTable.insert {
                            it[playerId] = adminInventory.playerId
                            it[dataJson] = JSON.encode(adminInventory)
                        }
                    }
                    Logger.info { "${Emoji.Database} MariaDB: Admin account inserted in ${getTimeMillis() - start}ms" }
                } else {
                    Logger.info { "${Emoji.Database} MariaDB: Admin account already exists." }
                }
            }
        } catch (e: Exception) {
            Logger.error { "${Emoji.Database} MariaDB: Failed during setup: $e" }
            throw e
        }
    }

    override suspend fun loadPlayerAccount(playerId: String): PlayerAccount? {
        return database.suspendedTransaction {
            PlayerAccounts.selectAll().where { PlayerAccounts.playerId eq playerId }
                .singleOrNull()?.let { row ->
                    PlayerAccount(
                        playerId = row[PlayerAccounts.playerId],
                        hashedPassword = row[PlayerAccounts.hashedPassword],
                        email = row[PlayerAccounts.email],
                        displayName = row[PlayerAccounts.displayName],
                        avatarUrl = row[PlayerAccounts.avatarUrl],
                        createdAt = row[PlayerAccounts.createdAt],
                        lastLogin = row[PlayerAccounts.lastLogin],
                        countryCode = row[PlayerAccounts.countryCode],
                        serverMetadata = JSON.decode(row[PlayerAccounts.serverMetadataJson])
                    )
                }
        }
    }

    override suspend fun loadPlayerObjects(playerId: String): PlayerObjects? {
        return database.suspendedTransaction {
            PlayerObjectsTable.selectAll().where { PlayerObjectsTable.playerId eq playerId }
                .singleOrNull()?.let { row ->
                    JSON.decode<PlayerObjects>(row[PlayerObjectsTable.dataJson])
                }
        }
    }

    override suspend fun loadNeighborHistory(playerId: String): NeighborHistory? {
        return database.suspendedTransaction {
            NeighborHistoryTable.selectAll().where { NeighborHistoryTable.playerId eq playerId }
                .singleOrNull()?.let { row ->
                    JSON.decode(row[NeighborHistoryTable.dataJson])
                }
        }
    }

    override suspend fun loadInventory(playerId: String): Inventory? {
        return database.suspendedTransaction {
            InventoryTable.selectAll().where { InventoryTable.playerId eq playerId }
                .singleOrNull()?.let { row ->
                    JSON.decode(row[InventoryTable.dataJson])
                }
        }
    }

    override suspend fun updatePlayerObjectsJson(playerId: String, updatedPlayerObjects: PlayerObjects) {
        database.suspendedTransaction {
            PlayerObjectsTable.update({ PlayerObjectsTable.playerId eq playerId }) {
                it[dataJson] = JSON.encode(updatedPlayerObjects)
            }
        }
    }

    @Suppress("UNCHECKED_CAST")
    override fun <T> getCollection(name: CollectionName): T {
        return when (name) {
            CollectionName.PLAYER_ACCOUNT_COLLECTION -> PlayerAccounts
            CollectionName.PLAYER_OBJECTS_COLLECTION -> PlayerObjectsTable
            CollectionName.NEIGHBOR_HISTORY_COLLECTION -> NeighborHistoryTable
            CollectionName.INVENTORY_COLLECTION -> InventoryTable
        } as T
    }

    override suspend fun createUser(username: String, password: String): String {
        val pid = UUID.new()
        val now = getTimeMillis()

        database.suspendedTransaction {
            val account = PlayerAccount(
                playerId = pid,
                hashedPassword = hashPw(password),
                email = "dummyemail@email.com",
                displayName = username,
                avatarUrl = "https://picsum.photos/200",
                createdAt = now,
                lastLogin = now,
                countryCode = null,
                serverMetadata = ServerMetadata()
            )

            val playerSrvId = UUID.new()
            val objects = PlayerObjects.newgame(pid, username, playerSrvId)
            val neighbor = NeighborHistory.empty(pid)
            val inventory = Inventory.newgame(pid)

            PlayerAccounts.insert {
                it[playerId] = account.playerId
                it[hashedPassword] = account.hashedPassword
                it[email] = account.email
                it[displayName] = account.displayName
                it[avatarUrl] = account.avatarUrl
                it[createdAt] = account.createdAt
                it[lastLogin] = account.lastLogin
                it[countryCode] = account.countryCode
                it[serverMetadataJson] = JSON.encode(account.serverMetadata)
            }

            PlayerObjectsTable.insert {
                it[playerId] = objects.playerId
                it[dataJson] = JSON.encode(objects)
            }

            NeighborHistoryTable.insert {
                it[playerId] = neighbor.playerId
                it[dataJson] = JSON.encode(neighbor)
            }

            InventoryTable.insert {
                it[playerId] = inventory.playerId
                it[dataJson] = JSON.encode(inventory)
            }
        }
        return pid
    }

    private fun hashPw(password: String): String {
        return Base64.encode(Bcrypt.hash(password, 10))
    }

    override suspend fun shutdown() = Unit
}

/**
 * Non-blocking I/O wrapper for Exposed's transaction. It always use `Dispatchers.IO`.
 */
suspend fun <T> Database.suspendedTransaction(block: suspend Transaction.() -> T): T {
    return newSuspendedTransaction(Dispatchers.IO, this, statement = block)
}

/**
 * Executes a suspending transaction on the database and returns a Result wrapper with `runCatching`.
 */
suspend fun <T> Database.suspendedTransactionResult(
    block: suspend Transaction.() -> T
): Result<T> = runCatching {
    this.suspendedTransaction(block)
}



================================================================================
ðŸ“„ FICHIER : src\main\kotlin\server\BroadcastServer.kt
================================================================================

package dev.deadzone.socket.core

import server.broadcast.BroadcastMessage
import context.ServerContext
import io.ktor.network.selector.*
import io.ktor.network.sockets.*
import io.ktor.utils.io.*
import kotlinx.coroutines.*
import server.core.Server
import utils.Emoji
import utils.Logger
import java.io.IOException
import java.util.*
import java.util.concurrent.ConcurrentHashMap

data class BroadcastServerConfig(
    val host: String = "0.0.0.0",
    val ports: List<Int> = listOf(2121, 2122, 2123),
)

data class BroadcastClient(
    val clientId: UUID,
    val remoteAddress: String,
    // coroutine reference, must cancel when client disconnects
    val job: Job,
    // write reference, used to send broadcast message
    val output: ByteWriteChannel
)

class BroadcastServer(private val config: BroadcastServerConfig) : Server {
    override val name: String = "BroadcastServer"

    private lateinit var broadcastServerScope: CoroutineScope

    private val selectorManager = SelectorManager(Dispatchers.IO)

    // reference to all server's socket for each pots
    private val serverSockets = mutableListOf<ServerSocket>()

    // reference to all server's coroutine for each ports
    private val serverJobs = mutableListOf<Job>()

    private val clients = ConcurrentHashMap<UUID, BroadcastClient>()

    private var running = false
    override fun isRunning(): Boolean = running

    /**
     * Returns the number of connected clients
     */
    fun getClientCount(): Int = clients.size

    override suspend fun initialize(scope: CoroutineScope, context: ServerContext) {
        broadcastServerScope = CoroutineScope(scope.coroutineContext + SupervisorJob() + Dispatchers.IO)
    }

    /**
     * Starts the broadcast server on all configured ports
     */
    override suspend fun start() {
        if (running) {
            Logger.warn("Broadcast server is already running")
            return
        }
        running = true

        config.ports.forEach { port ->
            // launch coroutine for each port
            val job = broadcastServerScope.launch(Dispatchers.IO + SupervisorJob()) {
                try {
                    val serverSocket = aSocket(selectorManager).tcp().bind(config.host, port)
                    serverSockets.add(serverSocket)

                    Logger.info("${Emoji.Satellite} Broadcast listening on ${config.host}:$port")

                    while (isActive) {
                        val socket = serverSocket.accept()
                        handleClient(socket)
                    }
                } catch (e: Exception) {
                    Logger.error("Failed to start broadcast server on port $port: ${e.message}")
                }
            }
            serverJobs.add(job)
        }
    }

    private fun handleClient(socket: Socket) {
        val address = socket.remoteAddress
        val clientId = UUID.randomUUID()
        Logger.info("New broadcast connection from $address")

        val job = broadcastServerScope.launch(Dispatchers.IO + SupervisorJob()) {
            val input = socket.openReadChannel()

            try {
                val buffer = ByteArray(1024)
                while (isActive) {
                    val bytes = input.readAvailable(buffer)
                    if (bytes <= 0) break // client disconnected
                    // client does not need to send data to broadcast server
                    // just ignore it as it is probably just heartbeat
                }
            } catch (e: Exception) {
                Logger.warn("Broadcast socket error for $address: ${e.message}")
            } finally {
                removeClient(clientId)
                socket.close()
                Logger.info("Closed broadcast connection $address")
            }
        }
        clients[clientId] = BroadcastClient(
            clientId = clientId,
            remoteAddress = address.toString(),
            job = job,
            output = socket.openWriteChannel(autoFlush = true)
        )
    }

    private fun removeClient(clientId: UUID) {
        if (clients.remove(clientId) != null) {
            Logger.info("${Emoji.Phone} Client disconnected from broadcast (${clients.size} total)")
        } else {
            Logger.warn("${Emoji.Phone} Requested to remove client, but it wasn't in the collection (${clients.size} total)")
        }
    }

    /**
     * Broadcasts a message to all connected clients
     */
    suspend fun broadcast(message: BroadcastMessage) {
        val wireFormat = message.toWireFormat()
        broadcast(wireFormat)
    }

    /**
     * Broadcasts a raw string message to all connected clients
     */
    suspend fun broadcast(message: String) {
        if (clients.isEmpty()) {
            return
        }

        val bytesData = message.toByteArray(Charsets.UTF_8)
        val disconnectedClients = mutableListOf<UUID>()

        clients.values.forEach { client ->
            try {
                client.output.writeFully(bytesData)
            } catch (e: IOException) {
                Logger.warn("Failed to send broadcast to client: ${e.message}")
                disconnectedClients.add(client.clientId)
            }
        }

        // Remove disconnected clients
        disconnectedClients.forEach { client ->
            removeClient(client)
        }
    }

    override suspend fun shutdown() {
        running = false
        clients.clear()
        clients.forEach { (_, u) ->
            u.output.flushAndClose()
            u.job.cancelAndJoin()
        }
        serverSockets.forEach { it.close() }
        serverJobs.forEach { it.cancelAndJoin() }
        broadcastServerScope.cancel()
        selectorManager.close()
        Logger.info("${Emoji.Satellite} Broadcast server stopped.")
    }
}



================================================================================
ðŸ“„ FICHIER : src\main\kotlin\server\GameServer.kt
================================================================================

package server

import context.ServerContext
import dev.deadzone.socket.messaging.HandlerContext
import dev.deadzone.socket.tasks.impl.MissionReturnStopParameter
import server.messaging.SocketMessage
import server.messaging.SocketMessageDispatcher
import server.protocol.PIODeserializer
import utils.Logger
import utils.UUID
import utils.sanitizedString
import io.ktor.network.selector.*
import io.ktor.network.sockets.*
import io.ktor.util.date.*
import io.ktor.utils.io.*
import kotlinx.coroutines.*
import server.core.Connection
import server.core.Server
import server.handler.AuthHandler
import server.handler.InitCompleteHandler
import server.handler.JoinHandler
import server.handler.QuestProgressHandler
import server.handler.RequestSurvivorCheckHandler
import server.handler.SaveHandler
import server.handler.ZombieAttackHandler
import server.tasks.TaskCategory
import server.tasks.impl.BuildingCreateStopParameter
import server.tasks.impl.BuildingRepairStopParameter
import server.tasks.impl.JunkRemovalStopParameter
import java.net.SocketException
import kotlin.system.measureTimeMillis

data class GameServerConfig(
    val host: String = "127.0.0.1",
    val port: Int = 7777
)

class GameServer(private val config: GameServerConfig) : Server {
    override val name: String = "GameServer"

    private lateinit var gameServerScope: CoroutineScope
    private lateinit var serverContext: ServerContext
    private val socketDispatcher = SocketMessageDispatcher()

    private var running = false
    override fun isRunning(): Boolean = running

    override suspend fun initialize(scope: CoroutineScope, context: ServerContext) {
        this.gameServerScope = CoroutineScope(scope.coroutineContext + SupervisorJob() + Dispatchers.IO)
        this.serverContext = context

        with(context) {
            socketDispatcher.register(JoinHandler(this))
            socketDispatcher.register(AuthHandler())
            socketDispatcher.register(QuestProgressHandler())
            socketDispatcher.register(InitCompleteHandler(this))
            socketDispatcher.register(SaveHandler(this))
            socketDispatcher.register(ZombieAttackHandler())
            socketDispatcher.register(RequestSurvivorCheckHandler(this))
            context.taskDispatcher.registerStopId(
                category = TaskCategory.TimeUpdate,
                stopInputFactory = {},
                deriveId = { playerId, category, _ ->
                    // "TU-playerId123"
                    "${category.code}-$playerId"
                }
            )
            context.taskDispatcher.registerStopId(
                category = TaskCategory.Building.Create,
                stopInputFactory = { BuildingCreateStopParameter() },
                deriveId = { playerId, category, stopInput ->
                    // "BLD-CREATE-bldId123-playerId123"
                    "${category.code}-${stopInput.buildingId}-$playerId"
                }
            )
            context.taskDispatcher.registerStopId(
                category = TaskCategory.Building.Repair,
                stopInputFactory = { BuildingRepairStopParameter() },
                deriveId = { playerId, category, stopInput ->
                    // "BLD-REPAIR-bldId123-playerId123"
                    "${category.code}-${stopInput.buildingId}-$playerId"
                }
            )
            context.taskDispatcher.registerStopId(
                category = TaskCategory.Mission.Return,
                stopInputFactory = { MissionReturnStopParameter() },
                deriveId = { playerId, category, stopInput ->
                    // "MIS-RETURN-missionId123-playerId123"
                    "${category.code}-${stopInput.missionId}-$playerId"
                }
            )
            context.taskDispatcher.registerStopId(
                category = TaskCategory.Task.JunkRemoval,
                stopInputFactory = { JunkRemovalStopParameter() },
                deriveId = { playerId, category, stopInput ->
                    // "TASK-JUNK-taskId123-playerId123"
                    "${category.code}-${stopInput.taskId}-$playerId"
                }
            )
        }
    }

    override suspend fun start() {
        if (running) {
            Logger.warn("Game server is already running")
            return
        }
        running = true

        gameServerScope.launch {
            try {
                val selectorManager = SelectorManager(Dispatchers.IO)
                val serverSocket = aSocket(selectorManager).tcp().bind(config.host, config.port)

                while (isActive) {
                    val socket = serverSocket.accept()

                    val connection = Connection(
                        connectionId = UUID.new(),
                        remoteAddress = socket.remoteAddress.toString(),
                        connectionScope = CoroutineScope(gameServerScope.coroutineContext + SupervisorJob() + Dispatchers.Default),
                        input = socket.openReadChannel(),
                        output = socket.openWriteChannel(autoFlush = true),
                    )
                    Logger.info { "New client: ${connection.remoteAddress}" }
                    handleClient(connection)
                }
            } catch (e: Exception) {
                Logger.error { "ERROR on server: $e" }
                shutdown()
            }
        }
    }

    private fun handleClient(connection: Connection) {
        connection.connectionScope.launch {
            try {
                val buffer = ByteArray(4096)

                while (isActive) {
                    val bytesRead = connection.input.readAvailable(buffer, 0, buffer.size)
                    if (bytesRead <= 0) break

                    var msgType = "[Undetermined]"
                    val elapsed = measureTimeMillis {
                        val data = buffer.copyOfRange(0, bytesRead)

                        if (data.startsWithBytes(POLICY_FILE_REQUEST)) {
                            Logger.debug { "=====> [SOCKET START]: POLICY_FILE_REQUEST from connection=$connection" }
                            connection.sendRaw(POLICY_FILE_RESPONSE)
                            Logger.debug {
                                buildString {
                                    appendLine("<===== [SOCKET END]  : Responded to POLICY_FILE_REQUEST for connection=$connection")
                                    append("====================================================================================================")
                                }
                            }
                            break
                        }

                        val data2 = if (data.startsWithBytes(byteArrayOf(0x00))) {
                            data.drop(1).toByteArray()
                        } else data

                        val deserialized = PIODeserializer.deserialize(data2)
                        val msg = SocketMessage.fromRaw(deserialized)
                        if (msg.isEmpty()) {
                            Logger.debug { "==== [SOCKET] Ignored empty message from connection=$connection, raw: $msg" }
                            continue
                        }

                        msgType = msg.msgTypeToString()

                        Logger.debug {
                            "=====> [SOCKET START]: of type $msgType, raw: ${data.sanitizedString()} for playerId=${connection.playerId}, bytes=$bytesRead"
                        }

                        socketDispatcher.findHandlerFor(msg).handle(HandlerContext(connection, msg))
                    }

                    Logger.debug {
                        buildString {
                            appendLine("<===== [SOCKET END] of type $msgType handled for playerId=${connection.playerId} in ${elapsed}ms")
                            append("====================================================================================================")
                        }
                    }
                }
            } catch (_: ClosedByteChannelException) {
                // Handle connection reset gracefully - this is expected when clients disconnect abruptly
                Logger.info { "Client ${connection.remoteAddress} disconnected abruptly (connection reset)" }
            } catch (e: SocketException) {
                // Handle other socket-related exceptions gracefully
                when {
                    e.message?.contains("Connection reset") == true -> {
                        Logger.info { "Client ${connection.remoteAddress} connection was reset by peer" }
                    }

                    e.message?.contains("Broken pipe") == true -> {
                        Logger.info { "Client ${connection.remoteAddress} connection broken (broken pipe)" }
                    }

                    else -> {
                        Logger.warn { "Socket exception for ${connection.remoteAddress}: ${e.message}" }
                    }
                }
            } catch (e: Exception) {
                Logger.error { "Unexpected error in socket for ${connection.remoteAddress}: $e" }
                e.printStackTrace()
            } finally {
                // Cleanup logic - this will run regardless of how the connection ended
                Logger.info { "Cleaning up connection for ${connection.remoteAddress}" }

                // Only perform cleanup if playerId is set (client was authenticated)
                if (connection.playerId != "[Undetermined]") {
                    serverContext.onlinePlayerRegistry.markOffline(connection.playerId)
                    serverContext.playerAccountRepository.updateLastLogin(connection.playerId, getTimeMillis())
                    serverContext.playerContextTracker.removePlayer(connection.playerId)
                    serverContext.taskDispatcher.stopAllTasksForPlayer(connection.playerId)
                }

                connection.shutdown()
            }
        }
    }

    override suspend fun shutdown() {
        running = false
        serverContext.playerContextTracker.shutdown()
        serverContext.onlinePlayerRegistry.shutdown()
        serverContext.sessionManager.shutdown()
        serverContext.taskDispatcher.shutdown()
        socketDispatcher.shutdown()
        gameServerScope.cancel()
    }
}

fun ByteArray.startsWithBytes(prefix: ByteArray): Boolean {
    if (this.size < prefix.size) return false
    for (i in prefix.indices) {
        if (this[i] != prefix[i]) return false
    }
    return true
}



================================================================================
ðŸ“„ FICHIER : src\main\kotlin\server\PolicyFileServer.kt
================================================================================

package server

import context.ServerContext
import io.ktor.network.selector.*
import io.ktor.network.sockets.*
import io.ktor.utils.io.*
import kotlinx.coroutines.*
import server.core.Server
import utils.Logger

val POLICY_FILE_REQUEST = "<policy-file-request/>".toByteArray()
val POLICY_FILE_RESPONSE = "<cross-domain-policy><allow-access-from domain=\"*\" to-ports=\"7777\"/></cross-domain-policy>\u0000".toByteArray()

data class PolicyFileServerConfig(
    val host: String = "0.0.0.0",
    val port: Int = 843,
    val allowedPorts: List<Int> = listOf(2121, 2122, 2123)
)

/**
 * Flash Player policy file server
 * Required for Flash to establish socket connections
 * Must run on port 843 (requires admin/root on Linux)
 */
class PolicyFileServer(private val config: PolicyFileServerConfig) : Server {
    override val name: String = "PolicyFileServer"

    private lateinit var policyServerScope: CoroutineScope

    private val selectorManager = SelectorManager(Dispatchers.IO)

    private var running = false
    override fun isRunning(): Boolean = running

    override suspend fun initialize(scope: CoroutineScope, context: ServerContext) {
        this.policyServerScope = CoroutineScope(scope.coroutineContext + SupervisorJob() + Dispatchers.IO)
    }

    /**
     * Starts the policy file server
     */
    override suspend fun start() {
        if (running) {
            Logger.warn("Policy file server already running")
            return
        }
        running = true

        policyServerScope.launch {
            try {
                val selectorManager = SelectorManager(Dispatchers.IO)
                val serverSocket = aSocket(selectorManager).tcp().bind(config.host, config.port)

                while (isActive) {
                    val socket = serverSocket.accept()
                    handleClient(socket)
                }
            } catch (e: Exception) {
                Logger.error { "ERROR in policy file server on port ${config.port}: ${e.message}" }
                Logger.warn { "Note: Port 843 requires administrator/root privileges on most systems" }
                shutdown()
            }
        }
    }

    fun handleClient(socket: Socket) {
        policyServerScope.launch(Dispatchers.IO + SupervisorJob()) {
            val input = socket.openReadChannel()
            val output = socket.openWriteChannel(autoFlush = true)

            try {
                val buffer = ByteArray(4096)

                while (isActive) {
                    val bytesRead = input.readAvailable(buffer, 0, buffer.size)
                    if (bytesRead <= 0) break

                    // Check if it's policy file request
                    val request = buffer.copyOfRange(0, bytesRead)
                    if (request.startsWithBytes(POLICY_FILE_REQUEST)) {
                        val policyFile = generatePolicyFile().toByteArray(Charsets.UTF_8)
                        output.writeFully(policyFile)
                    }

                    // Break, then close connection after sending response
                    break
                }
            } catch (e: Exception) {
                Logger.error("Error in policy file server during handling a client: ${e.message}")
            } finally {
                socket.close()
            }
        }
    }

    // Policy file response
    private fun generatePolicyFile(): String {
        val portsString = config.allowedPorts.joinToString(",")
        return """<?xml version="1.0"?>
<!DOCTYPE cross-domain-policy SYSTEM "http://www.adobe.com/xml/dtds/cross-domain-policy.dtd">
<cross-domain-policy>
    <allow-access-from domain="*" to-ports="$portsString" />
</cross-domain-policy>
"""
    }

    override suspend fun shutdown() {
        policyServerScope.cancel()
        selectorManager.close()
        Logger.info("Policy file server stopped")
    }
}



================================================================================
ðŸ“„ FICHIER : src\main\kotlin\server\ServerContainer.kt
================================================================================

package server

import context.ServerContext
import server.core.Server
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.SupervisorJob
import kotlinx.coroutines.cancelAndJoin

/**
 * The main server that orchestrates all sub-servers.
 *
 * Provides a single entry point to initialize, start, and shut down all sub-servers.
 * Serves as the root coroutine context, shared by sub-servers and client connections.
 */
class ServerContainer(private val servers: List<Server>, private val context: ServerContext) {
    private val job = SupervisorJob()
    private val coroutineScope: CoroutineScope = CoroutineScope(Dispatchers.Default + job)

    suspend fun initializeAll() {
        servers.forEach { it.initialize(coroutineScope, context) }
    }

    suspend fun startAll() {
        servers.forEach { it.start() }
    }

    suspend fun shutdownAll() {
        servers.forEach { it.shutdown() }
        job.cancelAndJoin()
    }
}


================================================================================
ðŸ“„ FICHIER : src\main\kotlin\server\broadcast\BroadcastMessage.kt
================================================================================

package server.broadcast

/**
 * Represents a broadcast message to be sent to clients
 * Format: "protocol:arg1|arg2|arg3\0"
 */
data class BroadcastMessage(
    val protocol: BroadcastProtocol,
    val arguments: List<String> = emptyList()
) {
    /**
     * Converts the message to the wire format expected by the client
     * Format: "protocol:arg1|arg2|arg3\0"
     */
    fun toWireFormat(): String {
        val body = if (arguments.isNotEmpty()) {
            ":${arguments.joinToString("|")}"
        } else {
            ""
        }
        return "${protocol.code}$body\u0000"
    }

    companion object {
        /**
         * Creates a broadcast message from protocol and vararg arguments
         */
        fun create(protocol: BroadcastProtocol, vararg args: String): BroadcastMessage {
            return BroadcastMessage(protocol, args.toList())
        }

        /**
         * Creates a plain text message
         */
        fun plainText(text: String): BroadcastMessage {
            return BroadcastMessage(BroadcastProtocol.PLAIN_TEXT, listOf(text))
        }

        /**
         * Creates an admin message
         */
        fun admin(text: String): BroadcastMessage {
            return BroadcastMessage(BroadcastProtocol.ADMIN, listOf(text))
        }

        /**
         * Creates a warning message
         */
        fun warning(text: String): BroadcastMessage {
            return BroadcastMessage(BroadcastProtocol.WARNING, listOf(text))
        }
    }
}



================================================================================
ðŸ“„ FICHIER : src\main\kotlin\server\broadcast\BroadcastProtocol.kt
================================================================================

package server.broadcast

/**
 * Broadcast protocols matching the client-side BroadcastSystemProtocols
 */
enum class BroadcastProtocol(val code: String) {
    STATIC("static"),
    ADMIN("admin"),
    WARNING("warn"),
    SHUT_DOWN("shtdn"),
    ITEM_UNBOXED("itmbx"),
    ITEM_FOUND("itmfd"),
    RAID_ATTACK("raid"),
    RAID_DEFEND("def"),
    ITEM_CRAFTED("crft"),
    ACHIEVEMENT("ach"),
    USER_LEVEL("lvl"),
    SURVIVOR_COUNT("srvcnt"),
    ZOMBIE_ATTACK_FAIL("zfail"),
    ALL_INJURED("injall"),
    PLAIN_TEXT("plain"),
    BOUNTY_ADD("badd"),
    BOUNTY_COLLECTED("bcol"),
    ALLIANCE_RAID_SUCCESS("ars"),
    ALLIANCE_RANK("arank"),
    ARENA_LEADERBOARD("arenalb"),
    RAIDMISSION_STARTED("rmstart"),
    RAIDMISSION_COMPLETE("rmcompl"),
    RAIDMISSION_FAILED("rmfail"),
    HAZ_SUCCESS("hazwin"),
    HAZ_FAIL("hazlose");

    companion object {
        fun fromCode(code: String): BroadcastProtocol? = values().find { it.code == code }
    }
}



================================================================================
ðŸ“„ FICHIER : src\main\kotlin\server\broadcast\BroadcastService.kt
================================================================================

package server.broadcast

import server.broadcast.BroadcastService.initialize
import dev.deadzone.socket.core.BroadcastServer
import utils.Logger

/**
 * A singleton service that provides a simple API for broadcasting messages to all connected clients.
 *
 * This service offers one-line call to broadcast over [BroadcastServer].
 * It must be initialized via [initialize] with an instance of [BroadcastServer] before use.
 *
 * Note that this service does **not** manage the server lifecycle â€” it should not start or shut down
 * the server. Its sole responsibility is to hold a reference to the broadcast server and delegate
 * broadcast operations.
 */
@Suppress("unused")
object BroadcastService {
    private lateinit var broadcastServer: BroadcastServer
    private var enabled = true

    /**
     * Initialize the broadcast service
     */
    fun initialize(broadcastServer: BroadcastServer) {
        this.broadcastServer = broadcastServer
    }

    /**
     * Broadcasts a message to all connected clients
     */
    suspend fun broadcast(message: BroadcastMessage) {
        if (!enabled) {
            Logger.warn { "Broadcast is not enabled" }
        }
        broadcastServer.broadcast(message)
    }

    /**
     * Broadcasts a raw message string to all connected clients
     */
    suspend fun broadcast(message: String) {
        if (!enabled) {
            Logger.warn { "Broadcast is not enabled" }
        }
        broadcastServer.broadcast(message)
    }

    /**
     * Returns the number of connected clients
     */
    fun getClientCount(): Int = broadcastServer.getClientCount()

    /**
     * Checks if the broadcast service is enabled
     */
    fun isEnabled(): Boolean = enabled

    // Convenience methods for common broadcast types
    suspend fun broadcastPlainText(text: String) {
        broadcast(BroadcastMessage.plainText(text))
    }

    suspend fun broadcastAdmin(text: String) {
        broadcast(BroadcastMessage.admin(text))
    }

    suspend fun broadcastWarning(text: String) {
        broadcast(BroadcastMessage.warning(text))
    }

    suspend fun broadcastShutdown(reason: String = "") {
        broadcast(
            BroadcastMessage(
                BroadcastProtocol.SHUT_DOWN,
                if (reason.isNotEmpty()) listOf(reason) else emptyList()
            )
        )
    }

    suspend fun broadcastItemUnboxed(playerName: String, itemName: String, quality: String = "") {
        val args = if (quality.isNotEmpty()) {
            listOf(playerName, itemName, quality)
        } else {
            listOf(playerName, itemName)
        }
        broadcast(BroadcastMessage(BroadcastProtocol.ITEM_UNBOXED, args))
    }

    suspend fun broadcastItemFound(playerName: String, itemName: String, quality: String = "") {
        val args = if (quality.isNotEmpty()) {
            listOf(playerName, itemName, quality)
        } else {
            listOf(playerName, itemName)
        }
        broadcast(BroadcastMessage(BroadcastProtocol.ITEM_FOUND, args))
    }

    suspend fun broadcastItemCrafted(playerName: String, itemName: String) {
        broadcast(BroadcastMessage(BroadcastProtocol.ITEM_CRAFTED, listOf(playerName, itemName)))
    }

    suspend fun broadcastRaidAttack(attackerName: String, defenderName: String, result: String = "") {
        val args = if (result.isNotEmpty()) {
            listOf(attackerName, defenderName, result)
        } else {
            listOf(attackerName, defenderName)
        }
        broadcast(BroadcastMessage(BroadcastProtocol.RAID_ATTACK, args))
    }

    suspend fun broadcastRaidDefend(defenderName: String, attackerName: String, result: String = "") {
        val args = if (result.isNotEmpty()) {
            listOf(defenderName, attackerName, result)
        } else {
            listOf(defenderName, attackerName)
        }
        broadcast(BroadcastMessage(BroadcastProtocol.RAID_DEFEND, args))
    }

    suspend fun broadcastAchievement(playerName: String, achievementName: String) {
        broadcast(BroadcastMessage(BroadcastProtocol.ACHIEVEMENT, listOf(playerName, achievementName)))
    }

    suspend fun broadcastUserLevel(playerName: String, level: Int) {
        broadcast(BroadcastMessage(BroadcastProtocol.USER_LEVEL, listOf(playerName, level.toString())))
    }

    suspend fun broadcastSurvivorCount(playerName: String, count: Int) {
        broadcast(BroadcastMessage(BroadcastProtocol.SURVIVOR_COUNT, listOf(playerName, count.toString())))
    }

    suspend fun broadcastZombieAttackFail(playerName: String) {
        broadcast(BroadcastMessage(BroadcastProtocol.ZOMBIE_ATTACK_FAIL, listOf(playerName)))
    }

    suspend fun broadcastAllInjured(playerName: String) {
        broadcast(BroadcastMessage(BroadcastProtocol.ALL_INJURED, listOf(playerName)))
    }

    suspend fun broadcastBountyAdd(playerName: String, bountyAmount: Int) {
        broadcast(BroadcastMessage(BroadcastProtocol.BOUNTY_ADD, listOf(playerName, bountyAmount.toString())))
    }

    suspend fun broadcastBountyCollected(collectorName: String, targetName: String, bountyAmount: Int) {
        broadcast(
            BroadcastMessage(
                BroadcastProtocol.BOUNTY_COLLECTED,
                listOf(collectorName, targetName, bountyAmount.toString())
            )
        )
    }

    suspend fun broadcastAllianceRaidSuccess(allianceName: String, targetName: String) {
        broadcast(BroadcastMessage(BroadcastProtocol.ALLIANCE_RAID_SUCCESS, listOf(allianceName, targetName)))
    }

    suspend fun broadcastAllianceRank(allianceName: String, rank: Int) {
        broadcast(BroadcastMessage(BroadcastProtocol.ALLIANCE_RANK, listOf(allianceName, rank.toString())))
    }

    suspend fun broadcastArenaLeaderboard(playerName: String, rank: Int) {
        broadcast(BroadcastMessage(BroadcastProtocol.ARENA_LEADERBOARD, listOf(playerName, rank.toString())))
    }

    suspend fun broadcastRaidMissionStarted(playerName: String, missionName: String) {
        broadcast(BroadcastMessage(BroadcastProtocol.RAIDMISSION_STARTED, listOf(playerName, missionName)))
    }

    suspend fun broadcastRaidMissionComplete(playerName: String, missionName: String) {
        broadcast(BroadcastMessage(BroadcastProtocol.RAIDMISSION_COMPLETE, listOf(playerName, missionName)))
    }

    suspend fun broadcastRaidMissionFailed(playerName: String, missionName: String) {
        broadcast(BroadcastMessage(BroadcastProtocol.RAIDMISSION_FAILED, listOf(playerName, missionName)))
    }

    suspend fun broadcastHazSuccess(playerName: String, hazardName: String) {
        broadcast(BroadcastMessage(BroadcastProtocol.HAZ_SUCCESS, listOf(playerName, hazardName)))
    }

    suspend fun broadcastHazFail(playerName: String, hazardName: String) {
        broadcast(BroadcastMessage(BroadcastProtocol.HAZ_FAIL, listOf(playerName, hazardName)))
    }
}



================================================================================
ðŸ“„ FICHIER : src\main\kotlin\server\broadcast\BroadcastTestController.kt
================================================================================

package server.broadcast

import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.SupervisorJob
import kotlinx.coroutines.delay
import kotlinx.coroutines.isActive
import kotlinx.coroutines.launch
import utils.Logger

/**
 * Test controller for sending broadcast messages
 * This is for testing and demonstration purposes
 */
object BroadcastTestController {

    /**
     * Starts sending test broadcast messages periodically
     */
    fun startTestBroadcasts(scope: CoroutineScope) {
        scope.launch(SupervisorJob() + Dispatchers.IO) {
            delay(5000) // Wait 5 seconds after server start

            Logger.info("ðŸ§ª Starting broadcast test messages...")

            // Test 1: Plain text message
            BroadcastService.broadcastPlainText("Server is online and broadcast system is working!")
            delay(3000)

            // Test 2: Admin message
            BroadcastService.broadcastAdmin("Welcome to the beta test !")
            delay(3000)

            // Test 3: Warning message
            BroadcastService.broadcastWarning("This is a test warning message")
            delay(3000)

            // Test 4: Item found
            BroadcastService.broadcastItemFound("TestPlayer", "Legendary Sword", "Legendary")
            delay(3000)

            // Test 5: Item unboxed
            BroadcastService.broadcastItemUnboxed("TestPlayer", "Epic Armor", "Epic")
            delay(3000)

            // Test 6: Achievement
            BroadcastService.broadcastAchievement("TestPlayer", "First Blood")
            delay(3000)

            // Test 7: User level
            BroadcastService.broadcastUserLevel("TestPlayer", 50)
            delay(3000)

            // Test 8: Raid attack
            BroadcastService.broadcastRaidAttack("Attacker123", "Defender456", "Victory")
            delay(3000)

            // Test 9: Item crafted
            BroadcastService.broadcastItemCrafted("CrafterPro", "Master Weapon")
            delay(3000)

            // Test 10: Bounty collected
            BroadcastService.broadcastBountyCollected("Hunter", "Target", 5000)

            Logger.info("ðŸ§ª Broadcast test messages completed")
        }
    }

    /**
     * Sends a single test message
     */
    fun sendTestMessage(scope: CoroutineScope, protocol: BroadcastProtocol, vararg args: String) {
        scope.launch(SupervisorJob() + Dispatchers.IO) {
            val message = BroadcastMessage(protocol, args.toList())
            BroadcastService.broadcast(message)
            Logger.info("ðŸ“¤ Test broadcast sent: ${message.toWireFormat()}")
        }
    }

    /**
     * Sends periodic maintenance messages every 30 seconds
     */
    fun startMaintenanceMessages(scope: CoroutineScope) {
        scope.launch(SupervisorJob() + Dispatchers.IO) {
            delay(5000) // Wait 5 seconds after server start

            while (isActive) {
                val clientCount = BroadcastService.getClientCount()
                Logger.info("ðŸ“¢ Sending maintenance message to $clientCount client(s)")

                BroadcastService.broadcastWarning("Server maintenance scheduled - save your progress!")

                delay(30000) // 30 seconds
            }
        }
    }

    /**
     * Sends periodic welcome messages
     */
    fun startPeriodicMessages(scope: CoroutineScope, intervalSeconds: Long = 300) {
        scope.launch(SupervisorJob() + Dispatchers.IO) {
            while (true) {
                delay(intervalSeconds * 1000)

                val clientCount = BroadcastService.getClientCount()
                if (clientCount > 0) {
                    BroadcastService.broadcastPlainText("Server running smoothly - $clientCount client(s) connected")
                }
            }
        }
    }
}



================================================================================
ðŸ“„ FICHIER : src\main\kotlin\server\core\Connection.kt
================================================================================

package server.core

import io.ktor.utils.io.ByteReadChannel
import io.ktor.utils.io.ByteWriteChannel
import io.ktor.utils.io.writeFully
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.cancel
import server.protocol.PIOSerializer
import utils.Logger
import utils.UUID

/**
 * Representation of a player connection.
 * @property playerId reference to which player does this socket belongs to. Only known after client send join message.
 */
class Connection(
    var playerId: String = "[Undetermined]",
    val connectionId: String = UUID.new(),
    val remoteAddress: String,
    val input: ByteReadChannel,
    val output: ByteWriteChannel,
    val connectionScope: CoroutineScope,
) {
    private var lastActivity = System.currentTimeMillis()

    /**
     * Update the last activity timestamp
     */
    fun updateActivity() {
        lastActivity = System.currentTimeMillis()
    }

    /**
     * Send raw unserialized message (non-PIO) to client
     */
    suspend fun sendRaw(b: ByteArray, enableLogging: Boolean = true, logFull: Boolean = true) {
        try {
            if (enableLogging) {
                Logger.debug(logFull = logFull) { "Sending raw: ${b.decodeToString()}" }
            }
            output.writeFully(b)
            updateActivity()
        } catch (e: Exception) {
            Logger.error { "Failed to send raw message to $remoteAddress: ${e.message}" }
            throw e
        }
    }

    /**
     * Send a serialized PIO message
     */
    suspend fun sendMessage(type: String, vararg args: Any, enableLogging: Boolean = true, logFull: Boolean = true) {
        try {
            val msg = buildList {
                add(type)
                addAll(args)
            }
            val bytes = PIOSerializer.serialize(msg)

            if (enableLogging) {
                Logger.debug(logFull = logFull) { "Sending message of type '$type' | raw message: ${bytes.decodeToString()}" }
            }

            output.writeFully(bytes)
            updateActivity()
        } catch (e: Exception) {
            Logger.error { "Failed to send message of type '$type' to $remoteAddress: ${e.message}" }
            throw e
        }
    }

    fun shutdown() {
        try {
            connectionScope.cancel()
        } catch (e: Exception) {
            Logger.warn { "Exception during connection shutdown: ${e.message}" }
        }
    }

    override fun toString(): String {
        return "Connnection(playerId=$playerId, connectionId=$connectionId, address=$remoteAddress)"
    }
}


================================================================================
ðŸ“„ FICHIER : src\main\kotlin\server\core\OnlinePlayerRegistry.kt
================================================================================

package server.core

import io.ktor.util.date.*
import java.util.concurrent.ConcurrentHashMap

data class PlayerStatus(
    val playerId: String,
    val onlineSince: Long,
)

/**
 * Keeps track online players
 */
class OnlinePlayerRegistry {
    private val players = ConcurrentHashMap<String, PlayerStatus>()

    /**
     * Mark a player of [playerId] as online. Does nothing if player is already online
     */
    fun markOnline(playerId: String) {
        players[playerId] = PlayerStatus(
            playerId = playerId,
            onlineSince = getTimeMillis(),
        )
    }

    /**
     * Mark a player of [playerId] as offline. Does nothing if player is already offline
     */
    fun markOffline(playerId: String) {
        players.remove(playerId)
    }

    /**
     * Clear all players
     */
    fun shutdown() {
        players.clear()
    }
}



================================================================================
ðŸ“„ FICHIER : src\main\kotlin\server\core\Server.kt
================================================================================

package server.core

import context.ServerContext
import kotlinx.coroutines.CoroutineScope

/**
 * Represent a server.
 */
interface Server {
    val name: String

    suspend fun initialize(scope: CoroutineScope, context: ServerContext)
    suspend fun start()
    suspend fun shutdown()

    fun isRunning(): Boolean
}


================================================================================
ðŸ“„ FICHIER : src\main\kotlin\server\handler\AuthHandler.kt
================================================================================

package server.handler

import dev.deadzone.socket.messaging.HandlerContext
import server.messaging.SocketMessage
import server.messaging.SocketMessageHandler
import utils.LogConfigSocketToClient
import utils.Logger

/**
 * Auth message is send after game ready message.
 * 'auth' contains MD5 hash produced from hashing all binaries sent in the join message.
 */
class AuthHandler() : SocketMessageHandler {
    override fun match(message: SocketMessage): Boolean {
        return message.type == "auth" || message.contains("auth")
    }

    override suspend fun handle(ctx: HandlerContext) {
        Logger.info(LogConfigSocketToClient) { "Received auth message, ignoring." }
    }
}



================================================================================
ðŸ“„ FICHIER : src\main\kotlin\server\handler\DefaultHandler.kt
================================================================================

package server.handler

import dev.deadzone.socket.messaging.HandlerContext
import server.messaging.SocketMessage
import server.messaging.SocketMessageHandler
import server.protocol.PIOSerializer
import utils.LogConfigSocketError
import utils.Logger

class DefaultHandler() : SocketMessageHandler {
    override fun match(message: SocketMessage): Boolean {
        return true
    }

    override suspend fun handle(ctx: HandlerContext) = with(ctx) {
        Logger.warn(LogConfigSocketError) {
            "Handler of type=${message.msgTypeToString()} is either unregistered (register it on GameServer.kt) or unimplemented"
        }
        send(PIOSerializer.serialize(listOf("\u0000\u0000\u0000\u0000")))
    }
}



================================================================================
ðŸ“„ FICHIER : src\main\kotlin\server\handler\InitCompleteHandler.kt
================================================================================

package server.handler

import context.ServerContext
import dev.deadzone.socket.messaging.HandlerContext
import server.messaging.NetworkMessage
import server.messaging.SocketMessage
import server.messaging.SocketMessageHandler
import server.tasks.impl.TimeUpdateTask

/**
 * Handle `ic` message by:
 *
 * 1. Do the necessary setup in server.
 * 2. Send data update to client if necessary.
 *
 * INIT_COMPLETE is a signal sent by client to notify server that the player's game is now active.
 */
class InitCompleteHandler(private val serverContext: ServerContext) :
    SocketMessageHandler {
    override fun match(message: SocketMessage): Boolean {
        // IC message is null, so only check for "ic" present
        return message.contains(NetworkMessage.INIT_COMPLETE)
    }

    override suspend fun handle(ctx: HandlerContext) = with(ctx) {
        // When game init is completed, mark player as active
        serverContext.onlinePlayerRegistry.markOnline(connection.playerId)

        // send serverTime to client
        serverContext.taskDispatcher.runTaskFor(
            connection = connection,
            taskToRun = TimeUpdateTask()
        )
    }
}



================================================================================
ðŸ“„ FICHIER : src\main\kotlin\server\handler\JoinHandler.kt
================================================================================

package server.handler

import context.ServerContext
import core.LoginStateBuilder
import dev.deadzone.socket.messaging.HandlerContext
import server.messaging.NetworkMessage
import server.messaging.SocketMessage
import server.messaging.SocketMessageHandler
import server.protocol.PIOSerializer
import utils.Logger
import utils.Time
import java.io.ByteArrayOutputStream
import java.io.File
import java.nio.ByteBuffer
import java.nio.ByteOrder
import java.util.zip.GZIPOutputStream

/**
 * Handle `join` message by:
 *
 * 1. Sending `playerio.joinresult`
 * 2. Sending `gr` message
 */
class JoinHandler(private val serverContext: ServerContext) : SocketMessageHandler {
    override fun match(message: SocketMessage): Boolean {
        return message.getString(NetworkMessage.JOIN) != null
    }

    override suspend fun handle(ctx: HandlerContext) = with(ctx) {
        val joinKey = message.getString(NetworkMessage.JOIN)
        Logger.debug { "Handling join with key: $joinKey" }

        val userId = message.getString("serviceUserId")
            ?: throw IllegalArgumentException("No userId for connection: $connection")
        connection.playerId = userId

        // First message: join result
        val success = true
        val joinResultMsg = listOf(NetworkMessage.JOIN_RESULT, success)
        send(PIOSerializer.serialize(joinResultMsg), enableLogging = false)
        Logger.debug { "Sent playerio.joinresult:$success to playerId=$userId" }

        // Create PlayerContext which initializes per-player services
        serverContext.playerContextTracker.createContext(
            playerId = connection.playerId,
            connection = connection,
            db = serverContext.db
        )

        // Second message: game ready message
        val gameReadyMsg = listOf(
            NetworkMessage.GAME_READY,
            Time.now(),
            produceBinaries(),
            loadRawFile("static/data/cost_table.json"),
            loadRawFile("static/data/srv_table.json"),
            LoginStateBuilder.build(serverContext, connection.playerId)
        )

        send(PIOSerializer.serialize(gameReadyMsg), enableLogging = false)
        Logger.debug { "Sent game ready message to playerId=$userId" }
    }

    /**
     * Pack all xml.gz resources in data/xml/ and manually added compressed
     * resources_secondary.xml.gz in data/
     *
     * Core.swf doesn't request these, the server has to send it manually.
     */
    fun produceBinaries(): ByteArray {
        val xmlResources = listOf(
            "static/game/data/resources_secondary.xml",
            "static/game/data/resources_mission.xml",
            "static/game/data/xml/alliances.xml.gz",
            "static/game/data/xml/arenas.xml.gz",
            "static/game/data/xml/attire.xml.gz",
            "static/game/data/xml/badwords.xml.gz",
            "static/game/data/xml/buildings.xml.gz",
            "static/game/data/xml/config.xml.gz",
            "static/game/data/xml/crafting.xml.gz",
            "static/game/data/xml/effects.xml.gz",
            "static/game/data/xml/humanenemies.xml.gz",
            "static/game/data/xml/injury.xml.gz",
            "static/game/data/xml/itemmods.xml.gz",
            "static/game/data/xml/items.xml.gz",
            "static/game/data/xml/quests.xml.gz",
            "static/game/data/xml/quests_global.xml.gz",
            "static/game/data/xml/raids.xml.gz",
            "static/game/data/xml/skills.xml.gz",
            "static/game/data/xml/streetstructs.xml.gz",
            "static/game/data/xml/survivor.xml.gz",
            "static/game/data/xml/vehiclenames.xml.gz",
            "static/game/data/xml/zombie.xml.gz",
            "static/game/data/xml/scenes/compound.xml.gz",
            "static/game/data/xml/scenes/interior-gunstore-1.xml.gz",
            "static/game/data/xml/scenes/street-small-1.xml.gz",
            "static/game/data/xml/scenes/street-small-2.xml.gz",
            "static/game/data/xml/scenes/street-small-3.xml.gz",
            "static/game/data/xml/scenes/set-motel.xml.gz",
        )

        val output = ByteArrayOutputStream()

        // 1. Write number of files as a single byte
        output.write(xmlResources.size)

        for (path in xmlResources) {
            File(path).inputStream().use {
                val rawBytes = it.readBytes()

                val fileBytes = if (path.endsWith(".gz")) {
                    rawBytes
                } else {
                    val compressed = ByteArrayOutputStream()
                    GZIPOutputStream(compressed).use { gzip ->
                        gzip.write(rawBytes)
                    }
                    compressed.toByteArray()
                }

                val uri = path
                    .removePrefix("static/game/data/")
                    .removeSuffix(".gz")
                val uriBytes = uri.toByteArray(Charsets.UTF_8)

                // 2. Write URI length as 2-byte little endian
                output.writeShortLE(uriBytes.size)

                // 3. Write URI bytes
                output.write(uriBytes)

                // 4. Write file size as 4-byte little endian
                output.writeIntLE(fileBytes.size)

                // 5. Write file data
                output.write(fileBytes)
            }
        }

        return output.toByteArray()
    }

    fun loadRawFile(path: String): String {
        return File(path).readText()
    }
}

fun ByteArrayOutputStream.writeShortLE(value: Int) {
    val buf = ByteBuffer.allocate(2).order(ByteOrder.LITTLE_ENDIAN).putShort(value.toShort())
    write(buf.array())
}

fun ByteArrayOutputStream.writeIntLE(value: Int) {
    val buf = ByteBuffer.allocate(4).order(ByteOrder.LITTLE_ENDIAN).putInt(value)
    write(buf.array())
}



================================================================================
ðŸ“„ FICHIER : src\main\kotlin\server\handler\QuestProgressHandler.kt
================================================================================

package server.handler

import dev.deadzone.socket.messaging.HandlerContext
import server.messaging.NetworkMessage
import server.messaging.SocketMessage
import server.messaging.SocketMessageHandler
import server.protocol.PIOSerializer

/**
 * Handle `qp` message by:
 *
 * 1. Sending quest progress JSON
 *
 */
class QuestProgressHandler() : SocketMessageHandler {
    override fun match(message: SocketMessage): Boolean {
        return message.getString(NetworkMessage.QUEST_PROGRESS) != null
    }

    override suspend fun handle(ctx: HandlerContext) = with(ctx) {
        val message = listOf(NetworkMessage.QUEST_PROGRESS, questProgressJson.trimIndent())
        send(PIOSerializer.serialize(message))
    }
}

const val questProgressJson = """
{
  "complete": null,
  "progress": null
}
"""



================================================================================
ðŸ“„ FICHIER : src\main\kotlin\server\handler\RequestSurvivorCheckHandler.kt
================================================================================

package server.handler

import context.ServerContext
import context.requirePlayerContext
import core.model.game.data.Survivor
import dev.deadzone.socket.messaging.HandlerContext
import server.messaging.NetworkMessage
import server.messaging.SocketMessage
import server.messaging.SocketMessageHandler
import server.protocol.PIOSerializer
import utils.Logger
import utils.Time
import kotlin.collections.random
import kotlin.random.Random

/**
 * Handle `rsc` message by:
 *
 * 1. Sending a reponse in JSON with success set to true
 *
 */
class RequestSurvivorCheckHandler(private val serverContext: ServerContext) : SocketMessageHandler {
    override fun match(message: SocketMessage): Boolean {
        return message.type == NetworkMessage.REQUEST_SURVIVOR_CHECK || message.contains(NetworkMessage.REQUEST_SURVIVOR_CHECK)
    }

    override suspend fun handle(ctx: HandlerContext) = with(ctx) {
        val id = message.getMap(NetworkMessage.REQUEST_SURVIVOR_CHECK)?.get("id") as? String
        Logger.debug { "Received RSC from playerId=${connection.playerId}" }

        val responseMsg =
            listOf(
                NetworkMessage.SEND_RESPONSE,  // Message Type
                id ?: "m",   // id
                Time.now(),   // server time
                """{"success": true}""".trimIndent() // response
            )

        val newSrv = generateSurvivor()
        val newSurvivorMsg = listOf(NetworkMessage.SURVIVOR_NEW, generateNewSurvivorJson(newSrv))

        send(PIOSerializer.serialize(responseMsg))
        send(PIOSerializer.serialize(newSurvivorMsg))

        val svc = serverContext.requirePlayerContext(connection.playerId).services
        svc.survivor.addNewSurvivor(newSrv)
        Unit
    }

    private fun generateSurvivor(): Survivor {
        val gender = if (Random.nextBoolean()) "male" else "female"
        val maleVoices = setOf("white-m", "black-m", "latino-m", "asian-m")
        val femaleVoices = setOf("white-f", "black-f", "latino-f")
        val name = (if (gender == "male") maleNames.random() else femaleNames.random()).split(" ")

        return Survivor(
            firstName = name[0],
            lastName = name[1],
            gender = gender,
            classId = "unassigned",
            voice = if (gender == "male") maleVoices.random() else femaleVoices.random(),
            title = "",
            morale = emptyMap(),
            injuries = emptyList(),
            level = 1,
            xp = 0,
            missionId = null,
            assignmentId = null,
            accessories = emptyMap(),
            maxClothingAccessories = 1,
        )
    }

    private fun generateNewSurvivorJson(srv: Survivor): String {
        return """
        {
            "id": "${srv.id}",
            "title": "${srv.title}",
            "firstName": "${srv.firstName}",
            "lastName": "${srv.lastName}",
            "gender": "${srv.gender}",
            "classId": "${srv.classId}",
            "voice": "${srv.voice}"
        }
        """.trimIndent()
    }

    // popular culture some troll names
    val maleNames = setOf(
        "Tony Stark", "Peter Parker", "Bruce Wayne", "Clark Kent", "Steve Rogers",
        "Luke Skywalker", "Genshin Impact", "Rick Roll", "Joel Miller", "Arthur Morgan",
        "John Wick", "Ethan Winters", "Leon Kennedy", "Gordon Freeman", "Nathan Drake",
        "Cloud Strife", "Uzumaki Naruto", "Zombie Dinner", "Jesse Pinkman", "Trevor Philips"
    )

    val femaleNames = setOf(
        "Lara Croft", "Jill Valentine", "Claire Redfield", "Ada Wong", "Ellie Williams",
        "Tifa Lockhart", "Aerith Gainsborough", "Hermione Granger", "Hinata Hyuga", "Sarah Connor",
        "Genshin Impact", "Carol Danvers", "Tasty Brain", "Natasha Romanoff", "Selina Kyle",
        "Sakura Haruno", "Asuka Langley", "Yuna Braska", "Jang Wonyoung", "Harley Quinn"
    )
}



================================================================================
ðŸ“„ FICHIER : src\main\kotlin\server\handler\SaveHandler.kt
================================================================================

package server.handler

import context.ServerContext
import dev.deadzone.socket.handler.save.SaveHandlerContext
import dev.deadzone.socket.messaging.HandlerContext
import server.messaging.NetworkMessage
import server.messaging.SocketMessage
import server.messaging.SocketMessageHandler
import utils.LogConfigSocketError
import utils.Logger
import utils.Time

/**
 * Handle `save` message by:
 *
 * 1. Receive the `data`, `_type`, and `id` (save id) for the said message.
 * 2. Route the save into the corresponding handler based on `_type`.
 * 3. Handlers determine what to do based on the given `data`.
 * 4. Optionally, response back a message of type 'r' with the expected JSON payload and the given save id.
 */
class SaveHandler(private val serverContext: ServerContext) : SocketMessageHandler {
    override fun match(message: SocketMessage): Boolean {
        return message.contains(NetworkMessage.SAVE) or (message.type?.equals(NetworkMessage.SAVE) == true)
    }

    @Suppress("UNCHECKED_CAST")
    override suspend fun handle(ctx: HandlerContext) = with(ctx) {
        val body = message.getMap(NetworkMessage.SAVE) ?: emptyMap()
        val data = body["data"] as? Map<String, Any?> ?: emptyMap()
        val type = data["_type"] as String? ?: return
        val saveId = body["id"] as String? ?: return
        requireNotNull(connection.playerId) { "Missing playerId on save message for connection=$connection" }

        // Note: the game typically send and expects JSON data for save message
        // encode JSON response to string before using PIO serialization

        var match = false
        // 15 save handlers
        serverContext.saveHandlers.forEach { saveHandler ->
            // O(1) hashset check on each handlers
            if (type in saveHandler.supportedTypes) {
                match = true
                // further string matching on the type on each handler
                saveHandler.handle(SaveHandlerContext(connection, type, saveId, data, serverContext))
            }
        }

        if (!match) {
            Logger.warn(LogConfigSocketError) { "Handled 's' network message but unrouted for save type: $type with data=$data" }
        }
    }
}

fun buildMsg(saveId: String?, vararg payloads: Any): List<Any> {
    return buildList {
        add("r")
        add(saveId ?: "m")
        add(Time.now())
        addAll(payloads)
    }
}



================================================================================
ðŸ“„ FICHIER : src\main\kotlin\server\handler\ZombieAttackHandler.kt
================================================================================

package server.handler

import dev.deadzone.socket.messaging.HandlerContext
import server.protocol.PIOSerializer
import server.messaging.NetworkMessage
import server.messaging.SocketMessage
import server.messaging.SocketMessageHandler

class ZombieAttackHandler(): SocketMessageHandler {
    override fun match(message: SocketMessage): Boolean {
        return message.contains(NetworkMessage.REQUEST_ZOMBIE_ATTACK)
    }

    override suspend fun handle(ctx: HandlerContext) = with(ctx) {
        val message = listOf(NetworkMessage.ZOMBIE_ATTACK)
        send(PIOSerializer.serialize(message))
    }
}



================================================================================
ðŸ“„ FICHIER : src\main\kotlin\server\handler\save\BaseResponse.kt
================================================================================

package server.handler.save

import core.model.game.data.skills.SkillState

/**
 * Most save message expects coins and skills update from server, which can be left null
 *
 * @property coins also known as CASH or FUEL in the game
 * @property skills not sure what is this
 */
open class BaseResponse {
    val coins: Int? = null
    val skills: List<SkillState>? = null
}


================================================================================
ðŸ“„ FICHIER : src\main\kotlin\server\handler\save\SaveHandlerContext.kt
================================================================================

package dev.deadzone.socket.handler.save

import context.ServerContext
import server.core.Connection

/**
 * Encapsulate objects and data needed by save handlers to handle message.
 */
class SaveHandlerContext(
    val connection: Connection,
    val type: String,
    val saveId: String,
    val data: Map<String, Any?>,
    val serverContext: ServerContext,
) {
    suspend fun send(
        bytes: ByteArray,
        enableLogging: Boolean = true,
        logFull: Boolean = true
    ) {
        connection.sendRaw(bytes, enableLogging, logFull)
    }

    suspend fun sendMessage(
        type: String,
        vararg args: Any,
        enableLogging: Boolean = true,
        logFull: Boolean = true
    ) {
        connection.sendMessage(type, *args, enableLogging, logFull)
    }
}



================================================================================
ðŸ“„ FICHIER : src\main\kotlin\server\handler\save\SaveSubHandler.kt
================================================================================

package server.handler.save

import dev.deadzone.socket.handler.save.SaveHandlerContext

interface SaveSubHandler {
    val supportedTypes: Set<String>
    suspend fun handle(ctx: SaveHandlerContext)
}



================================================================================
ðŸ“„ FICHIER : src\main\kotlin\server\handler\save\arena\ArenaSaveHandler.kt
================================================================================

package server.handler.save.arena

import dev.deadzone.socket.handler.save.SaveHandlerContext
import server.handler.save.SaveSubHandler
import server.messaging.SaveDataMethod
import utils.LogConfigSocketToClient
import utils.Logger

class ArenaSaveHandler : SaveSubHandler {
    override val supportedTypes: Set<String> = SaveDataMethod.ARENA_SAVES

    override suspend fun handle(ctx: SaveHandlerContext) = with(ctx) {
        when (type) {
            SaveDataMethod.ARENA_START -> {
                Logger.warn(LogConfigSocketToClient) { "Received 'ARENA_START' message [not implemented]" }
            }

            SaveDataMethod.ARENA_CONTINUE -> {
                Logger.warn(LogConfigSocketToClient) { "Received 'ARENA_CONTINUE' message [not implemented]" }
            }

            SaveDataMethod.ARENA_FINISH -> {
                Logger.warn(LogConfigSocketToClient) { "Received 'ARENA_FINISH' message [not implemented]" }
            }

            SaveDataMethod.ARENA_ABORT -> {
                Logger.warn(LogConfigSocketToClient) { "Received 'ARENA_ABORT' message [not implemented]" }
            }

            SaveDataMethod.ARENA_DEATH -> {
                Logger.warn(LogConfigSocketToClient) { "Received 'ARENA_DEATH' message [not implemented]" }
            }

            SaveDataMethod.ARENA_UPDATE -> {
                Logger.warn(LogConfigSocketToClient) { "Received 'ARENA_UPDATE' message [not implemented]" }
            }

            SaveDataMethod.ARENA_LEADER -> {
                Logger.warn(LogConfigSocketToClient) { "Received 'ARENA_LEADER' message [not implemented]" }
            }

            SaveDataMethod.ARENA_LEADERBOARD -> {
                Logger.warn(LogConfigSocketToClient) { "Received 'ARENA_LEADERBOARD' message [not implemented]" }
            }
        }
    }
}



================================================================================
ðŸ“„ FICHIER : src\main\kotlin\server\handler\save\bounty\BountySaveHandler.kt
================================================================================

package server.handler.save.bounty

import dev.deadzone.socket.handler.save.SaveHandlerContext
import server.handler.save.SaveSubHandler
import server.messaging.SaveDataMethod
import utils.LogConfigSocketToClient
import utils.Logger

class BountySaveHandler : SaveSubHandler {
    override val supportedTypes: Set<String> = SaveDataMethod.BOUNTY_SAVES

    override suspend fun handle(ctx: SaveHandlerContext) = with(ctx) {
        when (type) {
            SaveDataMethod.BOUNTY_VIEW -> {
                Logger.warn(LogConfigSocketToClient) { "Received 'BOUNTY_VIEW' message [not implemented]" }
            }

            SaveDataMethod.BOUNTY_SPEED_UP -> {
                Logger.warn(LogConfigSocketToClient) { "Received 'BOUNTY_SPEED_UP' message [not implemented]" }
            }

            SaveDataMethod.BOUNTY_NEW -> {
                Logger.warn(LogConfigSocketToClient) { "Received 'BOUNTY_NEW' message [not implemented]" }
            }

            SaveDataMethod.BOUNTY_ABANDON -> {
                Logger.warn(LogConfigSocketToClient) { "Received 'BOUNTY_ABANDON' message [not implemented]" }
            }

            SaveDataMethod.BOUNTY_ADD -> {
                Logger.warn(LogConfigSocketToClient) { "Received 'BOUNTY_ADD' message [not implemented]" }
            }
        }
    }
}



================================================================================
ðŸ“„ FICHIER : src\main\kotlin\server\handler\save\chat\ChatSaveHandler.kt
================================================================================

package server.handler.save.chat

import dev.deadzone.socket.handler.save.SaveHandlerContext
import server.handler.save.SaveSubHandler
import server.messaging.SaveDataMethod
import utils.LogConfigSocketToClient
import utils.Logger

class ChatSaveHandler : SaveSubHandler {
    override val supportedTypes: Set<String> = SaveDataMethod.CHAT_SAVES

    override suspend fun handle(ctx: SaveHandlerContext) = with(ctx) {
        when (type) {
            SaveDataMethod.CHAT_SILENCED -> {
                Logger.warn(LogConfigSocketToClient) { "Received 'CHAT_SILENCED' message [not implemented]" }
            }

            SaveDataMethod.CHAT_KICKED -> {
                Logger.warn(LogConfigSocketToClient) { "Received 'CHAT_KICKED' message [not implemented]" }
            }

            SaveDataMethod.CHAT_GET_CONTACTS_AND_BLOCKS -> {
                Logger.warn(LogConfigSocketToClient) { "Received 'CHAT_GET_CONTACTS_AND_BLOCKS' message [not implemented]" }
            }

            SaveDataMethod.CHAT_MIGRATE_CONTACTS_AND_BLOCKS -> {
                Logger.warn(LogConfigSocketToClient) { "Received 'CHAT_MIGRATE_CONTACTS_AND_BLOCKS' message [not implemented]" }
            }

            SaveDataMethod.CHAT_ADD_CONTACT -> {
                Logger.warn(LogConfigSocketToClient) { "Received 'CHAT_ADD_CONTACT' message [not implemented]" }
            }

            SaveDataMethod.CHAT_REMOVE_CONTACT -> {
                Logger.warn(LogConfigSocketToClient) { "Received 'CHAT_REMOVE_CONTACT' message [not implemented]" }
            }

            SaveDataMethod.CHAT_REMOVE_ALL_CONTACTS -> {
                Logger.warn(LogConfigSocketToClient) { "Received 'CHAT_REMOVE_ALL_CONTACTS' message [not implemented]" }
            }

            SaveDataMethod.CHAT_ADD_BLOCK -> {
                Logger.warn(LogConfigSocketToClient) { "Received 'CHAT_ADD_BLOCK' message [not implemented]" }
            }

            SaveDataMethod.CHAT_REMOVE_BLOCK -> {
                Logger.warn(LogConfigSocketToClient) { "Received 'CHAT_REMOVE_BLOCK' message [not implemented]" }
            }

            SaveDataMethod.CHAT_REMOVE_ALL_BLOCKS -> {
                Logger.warn(LogConfigSocketToClient) { "Received 'CHAT_REMOVE_ALL_BLOCKS' message [not implemented]" }
            }
        }
    }
}



================================================================================
ðŸ“„ FICHIER : src\main\kotlin\server\handler\save\command\CommandSaveHandler.kt
================================================================================

package server.handler.save.command

import core.items.model.CrateItem
import core.items.model.Item
import core.items.model.SchematicItem
import dev.deadzone.socket.handler.save.SaveHandlerContext
import server.handler.buildMsg
import server.handler.save.SaveSubHandler
import server.messaging.CommandMessage
import server.protocol.PIOSerializer
import utils.JSON
import utils.LogConfigSocketToClient
import utils.Logger
import utils.UUID

class CommandSaveHandler : SaveSubHandler {
    override val supportedTypes: Set<String> = CommandMessage.COMMAND_SAVES

    override suspend fun handle(ctx: SaveHandlerContext) = with(ctx) {
        when (type) {
            CommandMessage.GIVE -> {
                val type = data["type"] as? String ?: return

                Logger.info(LogConfigSocketToClient) { "Received 'give' command with type=$type | data=$data" }

                when (type) {
                    "schematic" -> {
                        // not tested
                        val schem = data["schem"] as? String ?: return
                        val item = SchematicItem(type = type, schem = schem, new = true)
                        val response = JSON.encode(item)
                        send(PIOSerializer.serialize(buildMsg(saveId, response)))
                    }

                    "crate" -> {
                        // not tested
                        val series = data["series"] as? Int ?: return
                        val repeat = (data["repeat"] as? Int) ?: 1
                        repeat(repeat) {
                            val item = CrateItem(type = type, series = series, new = true)
                            val response = JSON.encode(item)
                            send(PIOSerializer.serialize(buildMsg(saveId, response)))
                        }
                    }

                    "effect" -> {
                        Logger.warn(LogConfigSocketToClient) { "Received 'give' command of type effect [not implemented]" }
                    }

                    else -> {
                        // not tested with mod
                        val level = data["level"] as? Int ?: return
                        val qty = data["qty"] as? Int ?: 1
                        val mod1 = data["mod1"] as? String?
                        val mod2 = data["mod2"] as? String?
                        val item = Item(
                            id = UUID.new(),
                            type = type,
                            level = level,
                            qty = qty.toUInt(),
                            mod1 = mod1,
                            mod2 = mod2,
                            new = true,
                        )
                        val response = JSON.encode(item)
                        send(PIOSerializer.serialize(buildMsg(saveId, response)))
                    }
                }
            }


            CommandMessage.GIVE_RARE -> {
                val type = (data["type"] as String?) ?: return
                val level = (data["level"] as Int?) ?: return

                val item = Item(
                    id = UUID.new(),
                    type = type,
                    level = level,
                    quality = 50,
                    new = true,
                )

                Logger.info(LogConfigSocketToClient) { "Received 'giveRare' command with type=$type | level=$level" }

                val response = JSON.encode(item)
                send(PIOSerializer.serialize(buildMsg(saveId, response)))
            }

            CommandMessage.GIVE_UNIQUE -> {
                val type = (data["type"] as String?) ?: return
                val level = (data["level"] as Int?) ?: return

                val item = Item(
                    id = UUID.new(),
                    type = type,
                    level = level,
                    quality = 51,
                    new = true,
                )

                Logger.info(LogConfigSocketToClient) { "Received 'giveUnique' command with type=$type | level=$level" }

                val response = JSON.encode(item)
                send(PIOSerializer.serialize(buildMsg(saveId, response)))
            }

            CommandMessage.STORE_CLEAR -> {
                Logger.warn(LogConfigSocketToClient) { "Received 'STORE_CLEAR' message [not implemented]" }
            }

            CommandMessage.STORE_BLOCK -> {
                Logger.warn(LogConfigSocketToClient) { "Received 'STORE_BLOCK' message [not implemented]" }
            }

            CommandMessage.SPAWN_ELITE -> {
                Logger.warn(LogConfigSocketToClient) { "Received 'SPAWN_ELITE' message [not implemented]" }
            }

            CommandMessage.ELITE_CHANCE -> {
                Logger.warn(LogConfigSocketToClient) { "Received 'ELITE_CHANCE' message [not implemented]" }
            }

            CommandMessage.ADD_BOUNTY -> {
                Logger.warn(LogConfigSocketToClient) { "Received 'ADD_BOUNTY' message [not implemented]" }
            }

            CommandMessage.LEVEL -> {
                Logger.warn(LogConfigSocketToClient) { "Received 'LEVEL' message [not implemented]" }
            }

            CommandMessage.SERVER_TIME -> {
                Logger.warn(LogConfigSocketToClient) { "Received 'SERVER_TIME' message [not implemented]" }
            }

            CommandMessage.ZOMBIE -> {
                Logger.warn(LogConfigSocketToClient) { "Received 'ZOMBIE' message [not implemented]" }
            }

            CommandMessage.TIME -> {
                Logger.warn(LogConfigSocketToClient) { "Received 'TIME' message [not implemented]" }
            }

            CommandMessage.STAT -> {
                Logger.warn(LogConfigSocketToClient) { "Received 'STAT' message [not implemented]" }
            }

            CommandMessage.GIVE_AMOUNT -> {
                Logger.warn(LogConfigSocketToClient) { "Received 'GIVE_AMOUNT' message [not implemented]" }
            }

            CommandMessage.COUNTER -> {
                Logger.warn(LogConfigSocketToClient) { "Received 'COUNTER' message [not implemented]" }
            }

            CommandMessage.DAILY_QUEST -> {
                Logger.warn(LogConfigSocketToClient) { "Received 'DAILY_QUEST' message [not implemented]" }
            }

            CommandMessage.CHAT -> {
                Logger.warn(LogConfigSocketToClient) { "Received 'CHAT' message [not implemented]" }
            }

            CommandMessage.LANG -> {
                Logger.warn(LogConfigSocketToClient) { "Received 'LANG' message [not implemented]" }
            }

            CommandMessage.FLAG -> {
                Logger.warn(LogConfigSocketToClient) { "Received 'FLAG' message [not implemented]" }
            }

            CommandMessage.PROMO -> {
                Logger.warn(LogConfigSocketToClient) { "Received 'PROMO' message [not implemented]" }
            }

            CommandMessage.BOUNTY_ADD -> {
                Logger.warn(LogConfigSocketToClient) { "Received 'BOUNTY_ADD' message [not implemented]" }
            }

            CommandMessage.GIVE_INFECTED_BOUNTY -> {
                Logger.warn(LogConfigSocketToClient) { "Received 'GIVE_INFECTED_BOUNTY' message [not implemented]" }
            }

            CommandMessage.BOUNTY_ABANDON -> {
                Logger.warn(LogConfigSocketToClient) { "Received 'BOUNTY_ABANDON' message [not implemented]" }
            }

            CommandMessage.BOUNTY_COMPLETE -> {
                Logger.warn(LogConfigSocketToClient) { "Received 'BOUNTY_COMPLETE' message [not implemented]" }
            }

            CommandMessage.BOUNTY_TASK_COMPLETE -> {
                Logger.warn(LogConfigSocketToClient) { "Received 'BOUNTY_TASK_COMPLETE' message [not implemented]" }
            }

            CommandMessage.BOUNTY_CONDITION_COMPLETE -> {
                Logger.warn(LogConfigSocketToClient) { "Received 'BOUNTY_CONDITION_COMPLETE' message [not implemented]" }
            }

            CommandMessage.BOUNTY_KILL -> {
                Logger.warn(LogConfigSocketToClient) { "Received 'BOUNTY_KILL' message [not implemented]" }
            }

            CommandMessage.SKILL_GIVEXP -> {
                Logger.warn(LogConfigSocketToClient) { "Received 'SKILL_GIVEXP' message [not implemented]" }
            }

            CommandMessage.SKILL_LEVEL -> {
                Logger.warn(LogConfigSocketToClient) { "Received 'SKILL_LEVEL' message [not implemented]" }
            }
        }
    }
}



================================================================================
ðŸ“„ FICHIER : src\main\kotlin\server\handler\save\compound\building\BuildingSaveHandler.kt
================================================================================

package server.handler.save.compound.building

import context.requirePlayerContext
import core.model.game.data.*
import dev.deadzone.core.model.game.data.TimerData
import dev.deadzone.core.model.game.data.reduceBy
import dev.deadzone.core.model.game.data.reduceByHalf
import dev.deadzone.core.model.game.data.secondsLeftToEnd
import dev.deadzone.socket.handler.save.SaveHandlerContext
import server.handler.buildMsg
import server.handler.save.SaveSubHandler
import server.handler.save.compound.building.response.*
import server.messaging.SaveDataMethod
import server.protocol.PIOSerializer
import server.tasks.TaskCategory
import server.tasks.impl.BuildingCreateStopParameter
import server.tasks.impl.BuildingCreateTask
import server.tasks.impl.BuildingRepairStopParameter
import server.tasks.impl.BuildingRepairTask
import utils.JSON
import utils.LogConfigSocketError
import utils.LogConfigSocketToClient
import utils.Logger
import utils.SpeedUpCostCalculator
import kotlin.math.min
import kotlin.time.Duration
import kotlin.time.Duration.Companion.hours
import kotlin.time.Duration.Companion.seconds
import kotlin.time.DurationUnit
import kotlin.time.toDuration

class BuildingSaveHandler : SaveSubHandler {
    override val supportedTypes: Set<String> = SaveDataMethod.COMPOUND_BUILDING_SAVES

    override suspend fun handle(ctx: SaveHandlerContext) = with(ctx) {
        val playerId = connection.playerId
        val svc = serverContext.requirePlayerContext(playerId).services.compound

        when (type) {
            SaveDataMethod.BUILDING_CREATE -> {
                val bldId = data["id"] as? String ?: return
                val bldType = data["type"] as? String ?: return
                val x = data["tx"] as? Int ?: return
                val y = data["ty"] as? Int ?: return
                val r = data["rotation"] as? Int ?: return
                Logger.info(LogConfigSocketToClient) { "'BUILDING_CREATE' message for $saveId and $bldId,$bldType to tx=$x, ty=$y, rotation=$r" }

                val buildDuration = 1444.seconds
                val timer = TimerData.runForDuration(
                    duration = buildDuration,
                    data = mapOf("level" to 0, "type" to "upgrade", "xp" to 50)
                )

                val result = svc.createBuilding {
                    Building(
                        id = bldId,
                        name = null,
                        type = bldType,
                        level = 0,
                        rotation = r,
                        tx = x,
                        ty = y,
                        destroyed = false,
                        resourceValue = 0.0,
                        upgrade = timer,
                        repair = null
                    )
                }

                val response: BuildingCreateResponse
                if (result.isSuccess) {
                    response = BuildingCreateResponse(
                        success = true,
                        items = emptyMap(),
                        timer = timer
                    )
                } else {
                    Logger.error(LogConfigSocketError) { "Failed to create building bldId=$bldId for playerId=$playerId: ${result.exceptionOrNull()?.message}" }
                    response = BuildingCreateResponse(
                        success = false,
                        items = emptyMap(),
                        timer = null
                    )
                }

                val responseJson = JSON.encode(response)
                send(PIOSerializer.serialize(buildMsg(saveId, responseJson)))

                if (result.isSuccess) {
                    serverContext.taskDispatcher.runTaskFor(
                        connection = connection,
                        taskToRun = BuildingCreateTask(
                            taskInputBlock = {
                                this.buildingId = bldId
                                this.buildDuration = buildDuration
                                this.serverContext = serverContext
                            },
                            stopInputBlock = {
                                this.buildingId = bldId
                            }
                        )
                    )
                }
            }

            SaveDataMethod.BUILDING_MOVE -> {
                val x = (data["tx"] as? Number)?.toInt() ?: return
                val y = (data["ty"] as? Number)?.toInt() ?: return
                val r = (data["rotation"] as? Number)?.toInt() ?: return
                val buildingId = data["id"] as? String ?: return
                Logger.info(LogConfigSocketToClient) { "'bld_move' message for $saveId and $buildingId to tx=$x, ty=$y, rotation=$r" }

                val result = svc.updateBuilding(buildingId) { it.copy(tx = x, ty = y, rotation = r) }

                val response: BuildingMoveResponse
                if (result.isSuccess) {
                    response = BuildingMoveResponse(success = true, x = x, y = y, r = r)
                } else {
                    Logger.error(LogConfigSocketError) { "Failed to move building bldId=$buildingId for playerId=$playerId: ${result.exceptionOrNull()?.message}" }
                    response = BuildingMoveResponse(success = false, x = x, y = y, r = r)
                }

                val responseJson = JSON.encode(response)
                send(PIOSerializer.serialize(buildMsg(saveId, responseJson)))
            }

            SaveDataMethod.BUILDING_UPGRADE -> {
                val bldId = data["id"] as? String ?: return
                Logger.info(LogConfigSocketToClient) { "'BUILDING_UPGRADE' message for $saveId and $bldId" }

                val buildDuration = 10.seconds
                lateinit var timer: TimerData
                val result = svc.updateBuilding(bldId) { bld ->
                    timer = TimerData.runForDuration(
                        duration = buildDuration,
                        data = mapOf("level" to (bld.level + 1), "type" to "upgrade", "xp" to 50)
                    )
                    bld.copy(upgrade = timer)
                }

                val response: BuildingUpgradeResponse
                if (result.isSuccess) {
                    response = BuildingUpgradeResponse(success = true, items = emptyMap(), timer = timer)
                } else {
                    Logger.error(LogConfigSocketError) { "Failed to upgrade building bldId=$bldId for playerId=$playerId: ${result.exceptionOrNull()?.message}" }
                    response = BuildingUpgradeResponse(success = false, items = emptyMap(), timer = null)
                }

                val responseJson = JSON.encode(response)
                send(PIOSerializer.serialize(buildMsg(saveId, responseJson)))

                if (result.isSuccess) {
                    serverContext.taskDispatcher.runTaskFor(
                        connection = connection,
                        taskToRun = BuildingCreateTask(
                            taskInputBlock = {
                                this.buildingId = bldId
                                this.buildDuration = buildDuration
                                this.serverContext = serverContext
                            },
                            stopInputBlock = {
                                this.buildingId = bldId
                            }
                        )
                    )
                }
            }

            SaveDataMethod.BUILDING_RECYCLE -> {
                val bldId = data["id"] as? String ?: return
                Logger.info(LogConfigSocketToClient) { "'BUILDING_RECYCLE' message for $saveId and $bldId" }

                val result = svc.deleteBuilding(bldId)

                val response: BuildingRecycleResponse
                if (result.isSuccess) {
                    response = BuildingRecycleResponse(success = true, items = emptyMap())
                } else {
                    Logger.error(LogConfigSocketError) { "Failed to recycle building bldId=$bldId for playerId=$playerId: ${result.exceptionOrNull()?.message}" }
                    response = BuildingRecycleResponse(success = false, items = emptyMap())
                }

                val responseJson = JSON.encode(response)
                send(PIOSerializer.serialize(buildMsg(saveId, responseJson)))
            }

            SaveDataMethod.BUILDING_COLLECT -> {
                val bldId = data["id"] as? String ?: return
                Logger.info(LogConfigSocketToClient) { "'BUILDING_COLLECT' message for $saveId and $bldId" }

                val collectResult = svc.collectBuilding(bldId)

                val response: BuildingCollectResponse
                if (collectResult.isSuccess) {
                    val res = collectResult.getOrThrow()
                    val resType =
                        requireNotNull(res.getNonEmptyResTypeOrNull()) { "Unexpected null on getNonEmptyResTypeOrNull during collect resource" }
                    val resAmount = requireNotNull(
                        res.getNonEmptyResAmountOrNull()?.toDouble()
                    ) { "Unexpected null on getNonEmptyResAmountOrNull during collect resource" }
                    val currentResource = svc.getResources()
                    val limit = 100_000_000.0 // TODO: Base this on storage capacity from GameDefinitions
                    val expectedResource = currentResource.wood + resAmount
                    val remainder = expectedResource - limit
                    val total = min(limit, expectedResource)
                    response = BuildingCollectResponse(
                        success = true,
                        locked = false,
                        resource = resType,
                        collected = resAmount,
                        remainder = remainder,
                        total = total,
                        bonus = 0.0,
                        destroyed = false
                    )
                } else {
                    Logger.error(LogConfigSocketError) { "Failed to collect building bldId=$bldId for playerId=$playerId: ${collectResult.exceptionOrNull()?.message}" }
                    response = BuildingCollectResponse(
                        success = false,
                        locked = false,
                        resource = "",
                        collected = 0.0,
                        remainder = 0.0,
                        total = 0.0,
                        bonus = 0.0,
                        destroyed = false
                    )
                }

                val responseJson = JSON.encode(response)
                send(PIOSerializer.serialize(buildMsg(saveId, responseJson)))
            }

            SaveDataMethod.BUILDING_CANCEL -> {
                val bldId = data["id"] as? String ?: return
                Logger.info(LogConfigSocketToClient) { "'BUILDING_CANCEL' message for $saveId and $bldId" }

                val result = svc.deleteBuilding(bldId)

                val response: BuildingCancelResponse
                if (result.isSuccess) {
                    response = BuildingCancelResponse(success = true, items = emptyMap())
                } else {
                    Logger.error(LogConfigSocketError) { "Failed to cancel building bldId=$bldId for playerId=$playerId: ${result.exceptionOrNull()?.message}" }
                    response = BuildingCancelResponse(success = false, items = emptyMap())
                }

                val responseJson = JSON.encode(response)
                send(PIOSerializer.serialize(buildMsg(saveId, responseJson)))
            }

            SaveDataMethod.BUILDING_SPEED_UP -> {
                val bldId = data["id"] as? String ?: return
                val option = data["option"] as? String ?: return
                Logger.info(LogConfigSocketToClient) { "'BUILDING_SPEED_UP' message for bldId=$bldId with option.key=$option" }

                val svc = serverContext.requirePlayerContext(connection.playerId).services
                val playerFuel = svc.compound.getResources().cash
                val notEnoughCoinsErrorId = "55"

                val response: BuildingSpeedUpResponse
                var resourceResponse: GameResources? = null
                if (playerFuel < 0) {
                    response = BuildingSpeedUpResponse(error = notEnoughCoinsErrorId, success = false, cost = 0)
                } else {
                    val building =
                        requireNotNull(svc.compound.getBuilding(bldId)) { "Building bldId=$bldId was somehow null in BUILDING_SPEED_UP request for playerId=$playerId" }.toBuilding()
                    val upgradeTimer =
                        requireNotNull(building.upgrade) { "Building upgrade timer for bldId=$bldId was somehow null in BUILDING_SPEED_UP request for playerId=$playerId" }

                    val secondsRemaining = upgradeTimer.secondsLeftToEnd()
                    val (newBuilding, cost) = when (option) {
                        "SpeedUpOneHour" -> {
                            val calculatedCost = SpeedUpCostCalculator.calculateCost(option, secondsRemaining)
                            building.copy(upgrade = upgradeTimer.reduceBy(1.hours)) to calculatedCost
                        }

                        "SpeedUpTwoHour" -> {
                            val calculatedCost = SpeedUpCostCalculator.calculateCost(option, secondsRemaining)
                            building.copy(upgrade = upgradeTimer.reduceBy(2.hours)) to calculatedCost
                        }

                        "SpeedUpHalf" -> {
                            val calculatedCost = SpeedUpCostCalculator.calculateCost(option, secondsRemaining)
                            building.copy(upgrade = upgradeTimer.reduceByHalf()) to calculatedCost
                        }

                        "SpeedUpComplete" -> {
                            val calculatedCost = SpeedUpCostCalculator.calculateCost(option, secondsRemaining)
                            val newLevel = (upgradeTimer.data?.get("level") as? Int) ?: (building.level + 1)
                            building.copy(upgrade = null, level = newLevel) to calculatedCost
                        }

                        "SpeedUpFree" -> {
                            if (building.upgrade.secondsLeftToEnd() <= 300) {
                                val calculatedCost = SpeedUpCostCalculator.calculateCost(option, secondsRemaining)
                                val newLevel = (upgradeTimer.data?.get("level") as? Int) ?: (building.level + 1)
                                building.copy(upgrade = null, level = newLevel) to calculatedCost
                            } else {
                                Logger.warn { "Received unexpected BuildingSpeedUp FREE option: $option from playerId=${connection.playerId} (speed up requested when timer is off or build time more than 5 minutes)" }
                                null to null
                            }
                        }

                        else -> {
                            Logger.warn { "Received unknown BuildingSpeedUp option: $option from playerId=${connection.playerId}" }
                            null to null
                        }
                    }

                    if (newBuilding != null && cost != null) {
                        // successful response
                        val updateBuildingResult = svc.compound.updateBuilding(bldId) { newBuilding as BuildingLike }
                        val updateResourceResult = svc.compound.updateResource { resource ->
                            resourceResponse = resource.copy(cash = playerFuel - cost)
                            resourceResponse
                        }

                        // if for some reason DB fail, do not proceed the speed up request
                        response = if (updateBuildingResult.isFailure || updateResourceResult.isFailure) {
                            BuildingSpeedUpResponse(error = "", success = false, cost = 0)
                        } else {
                            BuildingSpeedUpResponse(error = "", success = true, cost = cost)
                        }

                        // end the currently active building task
                        serverContext.taskDispatcher.stopTaskFor<BuildingCreateStopParameter>(
                            connection = connection,
                            category = TaskCategory.Building.Create,
                            stopInputBlock = {
                                this.buildingId = bldId
                            }
                        )

                        // then restart it to change the timer
                        // if construction ended after the speed up, automatically start with zero second delay
                        serverContext.taskDispatcher.runTaskFor(
                            connection = connection,
                            taskToRun = BuildingCreateTask(
                                taskInputBlock = {
                                    this.buildingId = bldId
                                    this.buildDuration =
                                        newBuilding.upgrade
                                            ?.secondsLeftToEnd()
                                            ?.toDuration(DurationUnit.SECONDS)
                                            ?: Duration.ZERO
                                    this.serverContext = serverContext
                                },
                                stopInputBlock = {
                                    this.buildingId = bldId
                                }
                            )
                        )
                    } else {
                        // unexpected DB error response
                        Logger.error(LogConfigSocketError) { "Failed to speed up create building bldId=$bldId for playerId=$playerId: old=${building.toCompactString()} new=${newBuilding?.toCompactString()}" }
                        response = BuildingSpeedUpResponse(error = "", success = false, cost = 0)
                    }
                }

                val responseJson = JSON.encode(response)
                val resourceResponseJson = JSON.encode(resourceResponse)
                send(PIOSerializer.serialize(buildMsg(saveId, responseJson, resourceResponseJson)))
            }

            SaveDataMethod.BUILDING_REPAIR -> {
                val bldId = data["id"] as? String ?: return
                Logger.info(LogConfigSocketToClient) { "'BUILDING_REPAIR' message for $saveId and $bldId" }

                val buildDuration = 10.seconds
                val timer = TimerData.runForDuration(
                    duration = buildDuration,
                    data = mapOf("type" to "repair")
                )

                val result = svc.updateBuilding(bldId) { bld -> bld.copy(repair = timer) }

                val response: BuildingRepairResponse
                if (result.isSuccess) {
                    response = BuildingRepairResponse(success = true, items = emptyMap(), timer = timer)
                } else {
                    Logger.error(LogConfigSocketError) { "Failed to repair building bldId=$bldId for playerId=$playerId: ${result.exceptionOrNull()?.message}" }
                    response = BuildingRepairResponse(success = false, items = emptyMap(), timer = null)
                }

                val responseJson = JSON.encode(response)
                send(PIOSerializer.serialize(buildMsg(saveId, responseJson)))

                if (result.isSuccess) {
                    serverContext.taskDispatcher.runTaskFor(
                        connection = connection,
                        taskToRun = BuildingRepairTask(
                            taskInputBlock = {
                                this.buildingId = bldId
                                this.repairDuration = buildDuration
                                this.serverContext = serverContext
                            },
                            stopInputBlock = {
                                this.buildingId = bldId
                            }
                        )
                    )
                }
            }

            SaveDataMethod.BUILDING_REPAIR_SPEED_UP -> {
                val bldId = data["id"] as? String ?: return
                val option = data["option"] as? String ?: return
                Logger.info(LogConfigSocketToClient) { "'BUILDING_REPAIR_SPEED_UP' message for bldId=$bldId with option.key=$option" }

                val svc = serverContext.requirePlayerContext(connection.playerId).services
                val playerFuel = svc.compound.getResources().cash
                val notEnoughCoinsErrorId = "55"

                var resourceResponse: GameResources? = null
                val response: BuildingRepairSpeedUpResponse
                if (playerFuel < 0) {
                    response = BuildingRepairSpeedUpResponse(error = notEnoughCoinsErrorId, success = false, cost = 0)
                } else {
                    val building =
                        requireNotNull(svc.compound.getBuilding(bldId)) { "Building bldId=$bldId was somehow null in BUILDING_REPAIR_SPEED_UP request for playerId=$playerId" }.toBuilding()
                    val repairTimer =
                        requireNotNull(building.repair) { "Building repair timer for bldId=$bldId was somehow null in BUILDING_REPAIR_SPEED_UP request for playerId=$playerId" }

                    val secondsRemaining = repairTimer.secondsLeftToEnd()
                    val (newBuilding, cost) = when (option) {
                        "SpeedUpOneHour" -> {
                            val calculatedCost = SpeedUpCostCalculator.calculateCost(option, secondsRemaining)
                            building.copy(repair = repairTimer.reduceBy(1.hours)) to calculatedCost
                        }

                        "SpeedUpTwoHour" -> {
                            val calculatedCost = SpeedUpCostCalculator.calculateCost(option, secondsRemaining)
                            building.copy(repair = repairTimer.reduceBy(2.hours)) to calculatedCost
                        }

                        "SpeedUpHalf" -> {
                            val calculatedCost = SpeedUpCostCalculator.calculateCost(option, secondsRemaining)
                            building.copy(repair = repairTimer.reduceByHalf()) to calculatedCost
                        }

                        "SpeedUpComplete" -> {
                            val calculatedCost = SpeedUpCostCalculator.calculateCost(option, secondsRemaining)
                            building.copy(repair = null, destroyed = false) to calculatedCost
                        }

                        "SpeedUpFree" -> {
                            if (building.repair.secondsLeftToEnd() <= 300) {
                                val calculatedCost = SpeedUpCostCalculator.calculateCost(option, secondsRemaining)
                                building.copy(repair = null, destroyed = false) to calculatedCost
                            } else {
                                Logger.warn { "Received unexpected BuildingSpeedUp FREE option: $option from playerId=${connection.playerId} (speed up requested when timer is off or build time more than 5 minutes)" }
                                null to null
                            }
                        }

                        else -> {
                            Logger.warn { "Received unknown BuildingRepairSpeedUp option: $option from playerId=${connection.playerId}" }
                            null to null
                        }
                    }

                    if (newBuilding != null && cost != null) {
                        // successful response
                        val updateBuildingResult = svc.compound.updateBuilding(bldId) { newBuilding as BuildingLike }
                        val updateResourceResult = svc.compound.updateResource { resource ->
                            resourceResponse = resource.copy(cash = playerFuel - cost)
                            resourceResponse
                        }

                        // if for some reason DB fail, do not proceed the speed up request
                        response = if (updateBuildingResult.isFailure || updateResourceResult.isFailure) {
                            BuildingRepairSpeedUpResponse(error = "", success = false, cost = 0)
                        } else {
                            BuildingRepairSpeedUpResponse(error = "", success = true, cost = cost)
                        }

                        // end the currently active building repair task
                        serverContext.taskDispatcher.stopTaskFor<BuildingRepairStopParameter>(
                            connection = connection,
                            category = TaskCategory.Building.Repair,
                            stopInputBlock = {
                                this.buildingId = bldId
                            }
                        )

                        // then restart it to change the timer
                        // if construction ended after the speed up, automatically start with zero second delay
                        serverContext.taskDispatcher.runTaskFor(
                            connection = connection,
                            taskToRun = BuildingRepairTask(
                                taskInputBlock = {
                                    this.buildingId = bldId
                                    this.repairDuration =
                                        newBuilding.repair
                                            ?.secondsLeftToEnd()
                                            ?.toDuration(DurationUnit.SECONDS)
                                            ?: Duration.ZERO
                                    this.serverContext = serverContext
                                },
                                stopInputBlock = {
                                    this.buildingId = bldId
                                }
                            )
                        )
                    } else {
                        // unexpected DB error response
                        Logger.error(LogConfigSocketError) { "Failed to speed up repair building bldId=$bldId for playerId=$playerId: old=${building.toCompactString()} new=${newBuilding?.toCompactString()}" }
                        response = BuildingRepairSpeedUpResponse(error = "", success = false, cost = 0)
                    }
                }

                val responseJson = JSON.encode(response)
                val resourceResponseJson = JSON.encode(resourceResponse)
                send(PIOSerializer.serialize(buildMsg(saveId, responseJson, resourceResponseJson)))
            }

            SaveDataMethod.BUILDING_CREATE_BUY -> {
                val bldId = data["id"] as? String ?: return
                val bldType = data["type"] as? String ?: return
                val x = data["tx"] as? Int ?: return
                val y = data["ty"] as? Int ?: return
                val r = data["rotation"] as? Int ?: return
                Logger.info(LogConfigSocketToClient) { "'BUILDING_CREATE_BUY' message for $saveId and $bldId,$bldType to tx=$x, ty=$y, rotation=$r" }

                val buildDuration = 0.seconds
                val timer = TimerData.runForDuration(
                    duration = buildDuration,
                    data = mapOf("level" to 0, "type" to "upgrade", "xp" to 50)
                )

                val result = svc.createBuilding {
                    Building(
                        id = bldId,
                        name = null,
                        type = bldType,
                        level = 0,
                        rotation = r,
                        tx = x,
                        ty = y,
                        destroyed = false,
                        resourceValue = 0.0,
                        upgrade = timer,
                        repair = null
                    )
                }

                val response: BuildingCreateResponse
                if (result.isSuccess) {
                    response = BuildingCreateResponse(
                        success = true,
                        items = emptyMap(),
                        timer = timer
                    )
                } else {
                    Logger.error(LogConfigSocketError) { "Failed to create (buy) building bldId=$bldId for playerId=$playerId: ${result.exceptionOrNull()?.message}" }
                    response = BuildingCreateResponse(
                        success = false,
                        items = emptyMap(),
                        timer = null
                    )
                }

                val responseJson = JSON.encode(response)
                send(PIOSerializer.serialize(buildMsg(saveId, responseJson)))

                if (result.isSuccess) {
                    serverContext.taskDispatcher.runTaskFor(
                        connection = connection,
                        taskToRun = BuildingCreateTask(
                            taskInputBlock = {
                                this.buildingId = bldId
                                this.buildDuration = buildDuration
                                this.serverContext = serverContext
                            },
                            stopInputBlock = {
                                this.buildingId = bldId
                            }
                        )
                    )
                }
            }

            SaveDataMethod.BUILDING_UPGRADE_BUY -> {
                val bldId = data["id"] as? String ?: return
                Logger.info(LogConfigSocketToClient) { "'BUILDING_UPGRADE_BUY' message for $saveId and $bldId" }

                var newLevel = 0
                val result = svc.updateBuilding(bldId) { bld ->
                    newLevel = bld.level + 1
                    bld.copy(level = newLevel, upgrade = null)
                }

                val response: BuildingUpgradeResponse
                if (result.isSuccess) {
                    response = BuildingUpgradeResponse(
                        success = true,
                        items = emptyMap(),
                        timer = null,
                        level = newLevel
                    )
                } else {
                    Logger.error(LogConfigSocketError) { "Failed to upgrade (buy) building bldId=$bldId for playerId=$playerId: ${result.exceptionOrNull()?.message}" }
                    response = BuildingUpgradeResponse(success = false, items = emptyMap(), timer = null)
                }

                val responseJson = JSON.encode(response)
                send(PIOSerializer.serialize(buildMsg(saveId, responseJson)))
            }

            SaveDataMethod.BUILDING_REPAIR_BUY -> {
                Logger.warn(LogConfigSocketToClient) { "Received 'BUILDING_REPAIR_BUY' message [not implemented]" }
            }

            SaveDataMethod.BUILDING_TRAP_EXPLODE -> {
                Logger.warn(LogConfigSocketToClient) { "Received 'BUILDING_TRAP_EXPLODE' message [not implemented]" }
            }
        }
    }
}


================================================================================
ðŸ“„ FICHIER : src\main\kotlin\server\handler\save\compound\building\response\BuildingCancelResponse.kt
================================================================================

package server.handler.save.compound.building.response

import kotlinx.serialization.Serializable

@Serializable
data class BuildingCancelResponse(
    val success: Boolean,
    val items: Map<String, Int>,
)



================================================================================
ðŸ“„ FICHIER : src\main\kotlin\server\handler\save\compound\building\response\BuildingCollectResponse.kt
================================================================================

package server.handler.save.compound.building.response

import kotlinx.serialization.Serializable

@Serializable
data class BuildingCollectResponse(
    val success: Boolean = true,
    val locked: Boolean,
    val resource: String, // point to GameResources constants
    val collected: Double,
    val remainder: Double,
    val total: Double,
    val bonus: Double, // some special bonus IDK
    val destroyed: Boolean = false
)



================================================================================
ðŸ“„ FICHIER : src\main\kotlin\server\handler\save\compound\building\response\BuildingCreateBuyResponse.kt
================================================================================

package server.handler.save.compound.building.response

import kotlinx.serialization.Serializable

@Serializable
data class BuildingCreateBuyResponse(
    val success: Boolean,
    // likely level pts gained after creating the building
    val levelPts: Int? = null,
)



================================================================================
ðŸ“„ FICHIER : src\main\kotlin\server\handler\save\compound\building\response\BuildingCreateResponse.kt
================================================================================

package server.handler.save.compound.building.response

import dev.deadzone.core.model.game.data.TimerData
import kotlinx.serialization.Serializable

@Serializable
data class BuildingCreateResponse(
    val success: Boolean,
    val items: Map<String, Int>, // item id to quantity
    val timer: TimerData?,        // build timer
)



================================================================================
ðŸ“„ FICHIER : src\main\kotlin\server\handler\save\compound\building\response\BuildingMoveResponse.kt
================================================================================

package server.handler.save.compound.building.response

import server.handler.save.BaseResponse
import kotlinx.serialization.Serializable

@Serializable
data class BuildingMoveResponse(
    val success: Boolean = true,
    val x: Int,
    val y: Int,
    val r: Int,
): BaseResponse()



================================================================================
ðŸ“„ FICHIER : src\main\kotlin\server\handler\save\compound\building\response\BuildingRecycleResponse.kt
================================================================================

package server.handler.save.compound.building.response

import kotlinx.serialization.Serializable

@Serializable
data class BuildingRecycleResponse(
    val success: Boolean,
    val items: Map<String, Int>,
)



================================================================================
ðŸ“„ FICHIER : src\main\kotlin\server\handler\save\compound\building\response\BuildingRepairResponse.kt
================================================================================

package server.handler.save.compound.building.response

import dev.deadzone.core.model.game.data.TimerData
import kotlinx.serialization.Serializable

@Serializable
data class BuildingRepairResponse(
    val success: Boolean = true,
    val items: Map<String, Int>? = emptyMap(),
    val timer: TimerData?
)



================================================================================
ðŸ“„ FICHIER : src\main\kotlin\server\handler\save\compound\building\response\BuildingRepairSpeedUpResponse.kt
================================================================================

package server.handler.save.compound.building.response

import kotlinx.serialization.Serializable

@Serializable
data class BuildingRepairSpeedUpResponse(
    val error: String, // not enough fuel error: PlayerIOError.NotEnoughCoins.errorID
    val success: Boolean = true,
    val cost: Int,
)



================================================================================
ðŸ“„ FICHIER : src\main\kotlin\server\handler\save\compound\building\response\BuildingSpeedUpResponse.kt
================================================================================

package server.handler.save.compound.building.response

import kotlinx.serialization.Serializable

@Serializable
data class BuildingSpeedUpResponse(
    val error: String, // not enough fuel error: PlayerIOError.NotEnoughCoins.errorID
    val success: Boolean = true,
    val cost: Int,
)



================================================================================
ðŸ“„ FICHIER : src\main\kotlin\server\handler\save\compound\building\response\BuildingUpgradeResponse.kt
================================================================================

package server.handler.save.compound.building.response

import dev.deadzone.core.model.game.data.TimerData
import server.handler.save.BaseResponse
import kotlinx.serialization.Serializable

@Serializable
data class BuildingUpgradeResponse(
    val success: Boolean = true,
    val items: Map<String, Int>? = emptyMap(),
    val timer: TimerData?,
    val xp: Int = 0,
    val level: Int? = null,
    val levelPts: Int? = null,
): BaseResponse()



================================================================================
ðŸ“„ FICHIER : src\main\kotlin\server\handler\save\compound\misc\CmpMiscSaveHandler.kt
================================================================================

package server.handler.save.compound.misc

import dev.deadzone.socket.handler.save.SaveHandlerContext
import server.handler.save.SaveSubHandler
import server.messaging.SaveDataMethod
import utils.LogConfigSocketToClient
import utils.Logger

class CmpMiscSaveHandler : SaveSubHandler {
    override val supportedTypes: Set<String> = SaveDataMethod.COMPOUND_MISC_SAVES

    override suspend fun handle(ctx: SaveHandlerContext) = with(ctx) {
        when (type) {
            SaveDataMethod.CRAFT_ITEM -> {
                Logger.warn(LogConfigSocketToClient) { "Received 'CRAFT_ITEM' message [not implemented]" }
            }

            SaveDataMethod.CRAFT_UPGRADE -> {
                Logger.warn(LogConfigSocketToClient) { "Received 'CRAFT_UPGRADE' message [not implemented]" }
            }

            SaveDataMethod.CRAFT_SCHEMATIC -> {
                Logger.warn(LogConfigSocketToClient) { "Received 'CRAFT_SCHEMATIC' message [not implemented]" }
            }

            SaveDataMethod.EFFECT_SET -> {
                Logger.warn(LogConfigSocketToClient) { "Received 'EFFECT_SET' message [not implemented]" }
            }

            SaveDataMethod.RESEARCH_START -> {
                Logger.warn(LogConfigSocketToClient) { "Received 'RESEARCH_START' message [not implemented]" }
            }

            SaveDataMethod.AH_EVENT -> {
                Logger.warn(LogConfigSocketToClient) { "Received 'AH_EVENT' message [not implemented]" }
            }

            SaveDataMethod.CULL_NEIGHBORS -> {
                Logger.warn(LogConfigSocketToClient) { "Received 'CULL_NEIGHBORS' message [not implemented]" }
            }

            SaveDataMethod.RALLY_ASSIGNMENT -> {
                Logger.warn(LogConfigSocketToClient) { "Received 'RALLY_ASSIGNMENT' message [not implemented]" }
            }
        }
    }
}



================================================================================
ðŸ“„ FICHIER : src\main\kotlin\server\handler\save\compound\task\TaskSaveHandler.kt
================================================================================

package server.handler.save.compound.task

import context.requirePlayerContext
import dev.deadzone.socket.handler.save.SaveHandlerContext
import kotlinx.serialization.Serializable
import server.handler.buildMsg
import server.handler.save.SaveSubHandler
import server.messaging.SaveDataMethod
import server.protocol.PIOSerializer
import server.tasks.TaskCategory
import server.tasks.impl.JunkRemovalStopParameter
import server.tasks.impl.JunkRemovalTask
import utils.JSON
import utils.LogConfigSocketToClient
import utils.Logger
import kotlin.time.Duration.Companion.seconds

@Serializable
data class TaskStartedResponse(
    val items: List<TaskItem>
)

@Serializable
data class TaskItem(
    val id: String,
    val quantity: Int,
    val quality: String? = null
)

class TaskSaveHandler : SaveSubHandler {
    override val supportedTypes: Set<String> = setOf(
        SaveDataMethod.TASK_STARTED,
        SaveDataMethod.TASK_CANCELLED,
        SaveDataMethod.TASK_SURVIVOR_ASSIGNED,
        SaveDataMethod.TASK_SURVIVOR_REMOVED,
        SaveDataMethod.TASK_SPEED_UP
    )

    override suspend fun handle(ctx: SaveHandlerContext) = with(ctx) {
        when (type) {
            SaveDataMethod.TASK_STARTED -> {
                val taskType = data["type"] as? String
                val buildingId = data["buildingId"] as? String
                val taskId = data["id"] as? String
                val survivors = data["survivors"] as? List<*>
                val length = (data["length"] as? Number)?.toInt() ?: 0

                Logger.info(LogConfigSocketToClient) { "Task started: type=$taskType, buildingId=$buildingId, taskId=$taskId, length=$length, survivors=${survivors?.size}" }

                val items = when (taskType) {
                    "junk_removal" -> generateJunkRemovalItems()
                    "scavenging" -> generateScavengingItems()
                    "construction" -> generateConstructionItems()
                    else -> emptyList()
                }

                val responseJson = JSON.encode(
                    TaskStartedResponse(items = items)
                )

                send(PIOSerializer.serialize(buildMsg(saveId, responseJson)))

                if (taskType == "junk_removal" && taskId != null && buildingId != null && length > 0) {
                    val numSurvivors = survivors?.size ?: 1
                    val actualDuration = if (numSurvivors > 0) {
                        (length / numSurvivors).seconds
                    } else {
                        length.seconds
                    }

                    Logger.info(LogConfigSocketToClient) {
                        "Junk removal task: base=$length seconds, survivors=$numSurvivors, actual duration=$actualDuration"
                    }

                    val playerContext = serverContext.requirePlayerContext(connection.playerId)
                    val compoundService = playerContext.services.compound

                    serverContext.taskDispatcher.runTaskFor(
                        connection = connection,
                        taskToRun = JunkRemovalTask(
                            compoundService = compoundService,
                            taskInputBlock = {
                                this.taskId = taskId
                                this.buildingId = buildingId
                                this.removalDuration = actualDuration
                            },
                            stopInputBlock = {
                                this.taskId = taskId
                            }
                        )
                    )
                }
            }

            SaveDataMethod.TASK_CANCELLED -> {
                val taskId = data["id"] as? String
                val taskType = data["type"] as? String
                Logger.info(LogConfigSocketToClient) { "Task cancelled: taskId=$taskId, type=$taskType" }

                if (taskType == "junk_removal" && taskId != null) {
                    serverContext.taskDispatcher.stopTaskFor<JunkRemovalStopParameter>(
                        connection = connection,
                        category = TaskCategory.Task.JunkRemoval,
                        stopInputBlock = {
                            this.taskId = taskId
                        }
                    )
                }

                send(PIOSerializer.serialize(buildMsg(saveId, "{}")))
            }

            SaveDataMethod.TASK_SURVIVOR_ASSIGNED -> {
                val taskId = data["id"] as? String
                val survivors = data["survivors"] as? List<*>
                Logger.info(LogConfigSocketToClient) { "Survivors assigned to task: taskId=$taskId, survivors=${survivors?.size}" }

                send(PIOSerializer.serialize(buildMsg(saveId, "{}")))
            }

            SaveDataMethod.TASK_SURVIVOR_REMOVED -> {
                val taskId = data["id"] as? String
                val survivors = data["survivors"] as? List<*>
                Logger.info(LogConfigSocketToClient) { "Survivors removed from task: taskId=$taskId, survivors=${survivors?.size}" }

                send(PIOSerializer.serialize(buildMsg(saveId, "{}")))
            }

            SaveDataMethod.TASK_SPEED_UP -> {
                val taskId = data["id"] as? String
                Logger.info(LogConfigSocketToClient) { "Task speed up: taskId=$taskId" }

                send(PIOSerializer.serialize(buildMsg(saveId, "{}")))
            }
        }
    }

    private fun generateJunkRemovalItems(): List<TaskItem> {
        return listOf(
            TaskItem("scrap_metal", kotlin.random.Random.nextInt(5, 15)),
            TaskItem("wood", kotlin.random.Random.nextInt(3, 10)),
            TaskItem("cloth", kotlin.random.Random.nextInt(2, 8))
        )
    }

    private fun generateScavengingItems(): List<TaskItem> {
        return listOf(
            TaskItem("food", kotlin.random.Random.nextInt(2, 6)),
            TaskItem("water", kotlin.random.Random.nextInt(1, 4)),
            TaskItem("medicine", kotlin.random.Random.nextInt(1, 3))
        )
    }

    private fun generateConstructionItems(): List<TaskItem> {
        return listOf(
            TaskItem("building_materials", kotlin.random.Random.nextInt(10, 25)),
            TaskItem("tools", kotlin.random.Random.nextInt(1, 5))
        )
    }
}


================================================================================
ðŸ“„ FICHIER : src\main\kotlin\server\handler\save\crate\CrateSaveHandler.kt
================================================================================

package server.handler.save.crate

import server.broadcast.BroadcastService
import core.items.ItemFactory
import dev.deadzone.socket.handler.save.SaveHandlerContext
import server.handler.buildMsg
import server.handler.save.SaveSubHandler
import server.handler.save.crate.response.CrateUnlockResponse
import server.messaging.SaveDataMethod
import server.protocol.PIOSerializer
import utils.JSON
import utils.LogConfigSocketToClient
import utils.Logger

class CrateSaveHandler : SaveSubHandler {
    override val supportedTypes: Set<String> = SaveDataMethod.CRATE_SAVES

    override suspend fun handle(ctx: SaveHandlerContext) = with(ctx) {
        when (type) {
            SaveDataMethod.CRATE_UNLOCK -> {
                val keyId = data["keyId"] as String?
                val crateId = (data["crateId"] ?: "") as String?

                val item = ItemFactory.getRandomItem()

                val responseJson = JSON.encode(
                    CrateUnlockResponse(
                        success = true,
                        item = item,
                        keyId = keyId,
                        crateId = crateId,
                    )
                )

                Logger.info(LogConfigSocketToClient) { "Opening crateId=$crateId with keyId=$keyId" }

                // Broadcast item unboxed
                try {
                    val playerName = connection.playerId // You might want to get the actual player name
                    val itemName = item.name ?: "Unknown Item"
                    val quality = item.quality?.toString() ?: ""

                    BroadcastService.broadcastItemUnboxed(playerName, itemName, quality)
                } catch (e: Exception) {
                    Logger.warn("Failed to broadcast item unboxed: ${e.message}")
                }

                send(PIOSerializer.serialize(buildMsg(saveId, responseJson)))
            }

            SaveDataMethod.CRATE_MYSTERY_UNLOCK -> {
                Logger.warn(LogConfigSocketToClient) { "Received 'CRATE_MYSTERY_UNLOCK' message [not implemented]" }
            }
        }
    }
}


================================================================================
ðŸ“„ FICHIER : src\main\kotlin\server\handler\save\crate\response\CrateUnlockResponse.kt
================================================================================

package server.handler.save.crate.response

import core.items.ItemFactory
import core.items.model.Item
import kotlinx.serialization.Serializable

@Serializable
data class CrateUnlockResponse(
    val success: Boolean = true,
    val item: Item = ItemFactory.getRandomItem(),
    val effect: String? = null,   // base64 encoded, parsed to [Effect]
    val cooldown: String? = null, // similar as above
    val keyId: String? = null, // to remove the key used to open the crate
    val keyQty: Int? = null, // to remove the key used to open the crate
    val crateId: String? = null, // to remove the opened crate
)

val gachaPoolExample = listOf(
    ItemFactory.createItemFromId(idInXML = "exo-rig-heavyBrawler-replica"),
    ItemFactory.createItemFromId(idInXML = "helmet-exo-brawler-replica"),
    ItemFactory.createItemFromId(idInXML = "helmet-exo-targeting-replica"),
    ItemFactory.createItemFromId(idInXML = "mask-herc-exo-replica"),
    ItemFactory.createItemFromId(idInXML = "exo-undershirt-1-replica"),
    ItemFactory.createItemFromId(idInXML = "exo-underpants-1-replica"),
    ItemFactory.createItemFromId(idInXML = "pistol-halloween-reborn"),
    ItemFactory.createItemFromId(idInXML = "pistol-halloween-2-reborn"),
    ItemFactory.createItemFromId(idInXML = "rifle-halloween-reborn"),
    ItemFactory.createItemFromId(idInXML = "rifle-halloween-2-reborn"),
    ItemFactory.createItemFromId(idInXML = "sword-laser-purple-reborn"),
    ItemFactory.createItemFromId(idInXML = "trident-halloween-reborn"),
    ItemFactory.createItemFromId(idInXML = "trident-halloween-2-reborn"),
    ItemFactory.createItemFromId(idInXML = "crossbow-halloween-2015-reborn"),
    ItemFactory.createItemFromId(idInXML = "crossbow-halloween-2015-2-reborn"),
    ItemFactory.createItemFromId(idInXML = "halloween-exo-zombie"),
    ItemFactory.createItemFromId(idInXML = "bladesaw"),
    ItemFactory.createItemFromId(idInXML = "warclub")
)



================================================================================
ðŸ“„ FICHIER : src\main\kotlin\server\handler\save\item\ItemSaveHandler.kt
================================================================================

package server.handler.save.item

import context.requirePlayerContext
import core.items.model.Item
import dev.deadzone.socket.handler.save.SaveHandlerContext
import server.handler.buildMsg
import server.handler.save.SaveSubHandler
import server.messaging.SaveDataMethod
import server.protocol.PIOSerializer
import utils.LogConfigSocketToClient
import utils.Logger
import utils.UUID
import kotlin.random.Random

class ItemSaveHandler : SaveSubHandler {
    override val supportedTypes: Set<String> = SaveDataMethod.ITEM_SAVES

    private fun generateRecycleRewards(itemType: String): List<Item> {
        val rewards = mutableListOf<Item>()

        val baseRewards = mapOf(
            "wood" to 2..5,
            "metal" to 1..3,
            "cloth" to 1..4,
            "water" to 1..2
        )

        baseRewards.forEach { (type, range) ->
            if (Random.nextDouble() < 0.3) {
                val qty = Random.nextInt(range.first, range.last + 1).toUInt()
                rewards.add(Item(
                    id = UUID.new(),
                    type = type,
                    qty = qty,
                    new = true
                ))
            }
        }

        return rewards
    }

    override suspend fun handle(ctx: SaveHandlerContext) = with(ctx) {
        when (type) {
            SaveDataMethod.ITEM -> {
                Logger.warn(LogConfigSocketToClient) { "Received 'ITEM' message [not implemented]" }
            }

            SaveDataMethod.ITEM_BUY -> {
                Logger.warn(LogConfigSocketToClient) { "Received 'ITEM_BUY' message [not implemented]" }
            }

            SaveDataMethod.ITEM_LIST -> {
                Logger.warn(LogConfigSocketToClient) { "Received 'ITEM_LIST' message [not implemented]" }
            }

            SaveDataMethod.ITEM_RECYCLE -> {
                val itemId = data["id"] as? String
                if (itemId == null) {
                    send(PIOSerializer.serialize(buildMsg(saveId, """{"success":false}""")))
                    Logger.warn(LogConfigSocketToClient) { "ITEM_RECYCLE: missing 'id' parameter" }
                    return@with
                }

                val svc = serverContext.requirePlayerContext(connection.playerId).services
                val inventory = svc.inventory.getInventory()
                val itemToRecycle = inventory.find { it.id == itemId }

                if (itemToRecycle == null) {
                    send(PIOSerializer.serialize(buildMsg(saveId, """{"success":false}""")))
                    Logger.warn(LogConfigSocketToClient) { "ITEM_RECYCLE: item not found with id=$itemId" }
                    return@with
                }

                svc.inventory.updateInventory { items ->
                    items.filter { it.id != itemId }
                }

                val recycledItems = generateRecycleRewards(itemToRecycle.type)

                if (recycledItems.isNotEmpty()) {
                    svc.inventory.updateInventory { items ->
                        items + recycledItems
                    }
                }

                val responseJson = if (recycledItems.isNotEmpty()) {
                    val itemsJsonArray = recycledItems.joinToString(",") { item ->
                        """{"id":"${item.id}","type":"${item.type}","qty":${item.qty},"new":true}"""
                    }
                    """{"success":true,"qty":0,"items":[$itemsJsonArray]}"""
                } else {
                    """{"success":true,"qty":0}"""
                }

                send(PIOSerializer.serialize(buildMsg(saveId, responseJson)))

                Logger.info(LogConfigSocketToClient) {
                    "Item recycled: id=$itemId, type=${itemToRecycle.type}, rewards=${recycledItems.size} items for player ${connection.playerId}"
                }
            }

            SaveDataMethod.ITEM_DISPOSE -> {
                val itemId = data["id"] as? String
                if (itemId == null) {
                    send(PIOSerializer.serialize(buildMsg(saveId, """{"success":false}""")))
                    Logger.warn(LogConfigSocketToClient) { "ITEM_DISPOSE: missing 'id' parameter" }
                    return@with
                }

                val svc = serverContext.requirePlayerContext(connection.playerId).services
                val inventory = svc.inventory.getInventory()
                val itemToDispose = inventory.find { it.id == itemId }

                if (itemToDispose == null) {
                    send(PIOSerializer.serialize(buildMsg(saveId, """{"success":false}""")))
                    Logger.warn(LogConfigSocketToClient) { "ITEM_DISPOSE: item not found with id=$itemId" }
                    return@with
                }

                svc.inventory.updateInventory { items ->
                    items.filter { it.id != itemId }
                }

                send(PIOSerializer.serialize(buildMsg(saveId, """{"success":true,"qty":0}""")))

                Logger.info(LogConfigSocketToClient) { "Item disposed: id=$itemId, type=${itemToDispose.type}, qty=${itemToDispose.qty} for player ${connection.playerId}" }
            }

            SaveDataMethod.ITEM_CLEAR_NEW -> {
                val svc = serverContext.requirePlayerContext(connection.playerId).services

                svc.inventory.updateInventory { items ->
                    items.map { item -> item.copy(new = false) }
                }

                Logger.info(LogConfigSocketToClient) { "Cleared 'new' flag on all items for player ${connection.playerId}" }
            }

            SaveDataMethod.ITEM_BATCH_RECYCLE -> {
                Logger.warn(LogConfigSocketToClient) { "Received 'ITEM_BATCH_RECYCLE' message [not implemented]" }
            }

            SaveDataMethod.ITEM_BATCH_RECYCLE_SPEED_UP -> {
                Logger.warn(LogConfigSocketToClient) { "Received 'ITEM_BATCH_RECYCLE_SPEED_UP' message [not implemented]" }
            }

            SaveDataMethod.ITEM_BATCH_DISPOSE -> {
                Logger.warn(LogConfigSocketToClient) { "Received 'ITEM_BATCH_DISPOSE' message [not implemented]" }
            }
        }
    }
}



================================================================================
ðŸ“„ FICHIER : src\main\kotlin\server\handler\save\misc\MiscSaveHandler.kt
================================================================================

package server.handler.save.misc

import context.requirePlayerContext
import core.metadata.model.PlayerFlags_Constants
import dev.deadzone.socket.handler.save.SaveHandlerContext
import server.handler.save.SaveSubHandler
import server.messaging.SaveDataMethod
import utils.LogConfigSocketToClient
import utils.Logger
import kotlin.experimental.inv

class MiscSaveHandler : SaveSubHandler {
    override val supportedTypes: Set<String> = SaveDataMethod.MISC_SAVES

    override suspend fun handle(ctx: SaveHandlerContext) = with(ctx) {
        when (type) {
            SaveDataMethod.TUTORIAL_PVP_PRACTICE -> {
                Logger.warn(LogConfigSocketToClient) { "Received 'TUTORIAL_PVP_PRACTICE' message [not implemented]" }
            }

            SaveDataMethod.TUTORIAL_COMPLETE -> {
                val playerId = connection.playerId
                val services = serverContext.requirePlayerContext(playerId).services
                val current = services.playerObjectMetadata.getPlayerFlags()
                val bitIndex = PlayerFlags_Constants.TutorialComplete.toInt()
                val updated = setFlag(current, bitIndex, true)
                services.playerObjectMetadata.updatePlayerFlags(updated)
                Logger.info(LogConfigSocketToClient) { "Tutorial completed flag set for playerId=$playerId" }
            }

            SaveDataMethod.GET_OFFERS -> {
                Logger.warn(LogConfigSocketToClient) { "Received 'GET_OFFERS' message [not implemented]" }
            }

            SaveDataMethod.NEWS_READ -> {
                Logger.warn(LogConfigSocketToClient) { "Received 'NEWS_READ' message [not implemented]" }
            }

            SaveDataMethod.CLEAR_NOTIFICATIONS -> {
                val playerId = connection.playerId
                val services = serverContext.requirePlayerContext(playerId).services
                services.playerObjectMetadata.clearNotifications()
                Logger.info(LogConfigSocketToClient) { "Notifications cleared for playerId=$playerId" }
            }

            SaveDataMethod.FLUSH_PLAYER -> {
                Logger.warn(LogConfigSocketToClient) { "Received 'FLUSH_PLAYER' message [not implemented]" }
            }

            SaveDataMethod.SAVE_ALT_IDS -> {
                Logger.warn(LogConfigSocketToClient) { "Received 'SAVE_ALT_IDS' message [not implemented]" }
            }

            SaveDataMethod.TRADE_DO_TRADE -> {
                Logger.warn(LogConfigSocketToClient) { "Received 'TRADE_DO_TRADE' message [not implemented]" }
            }

            SaveDataMethod.GET_INVENTORY_SIZE -> {
                Logger.warn(LogConfigSocketToClient) { "Received 'GET_INVENTORY_SIZE' message [not implemented]" }
            }
        }
    }

    private fun setFlag(flags: ByteArray, bitIndex: Int, value: Boolean): ByteArray {
        val byteIndex = bitIndex / 8
        val bitInByte = bitIndex % 8

        val arr = if (flags.size <= byteIndex) {
            flags.copyOf(byteIndex + 1)
        } else {
            flags.copyOf()
        }

        val mask = (1 shl bitInByte).toByte()
        arr[byteIndex] = if (value) {
            (arr[byteIndex].toInt() or mask.toInt()).toByte()
        } else {
            (arr[byteIndex].toInt() and mask.inv().toInt()).toByte()
        }

        return arr
    }

}



================================================================================
ðŸ“„ FICHIER : src\main\kotlin\server\handler\save\mission\MissionSaveHandler.kt
================================================================================

package server.handler.save.mission

import server.broadcast.BroadcastService
import context.requirePlayerContext
import core.data.GameDefinition
import core.items.model.Item
import core.items.model.combineItems
import core.items.model.compactString
import core.items.model.stackOwnItems
import core.mission.LootService
import core.mission.model.LootContent
import core.mission.model.LootParameter
import core.model.game.data.GameResources
import core.model.game.data.MissionStats
import core.model.game.data.ZombieData
import core.model.game.data.toFlatList
import dev.deadzone.core.model.game.data.TimerData
import dev.deadzone.socket.handler.save.SaveHandlerContext
import dev.deadzone.socket.handler.save.mission.response.MissionSpeedUpResponse
import dev.deadzone.socket.tasks.impl.MissionReturnTask
import server.handler.buildMsg
import server.handler.save.SaveSubHandler
import server.handler.save.mission.response.*
import server.messaging.NetworkMessage
import server.messaging.SaveDataMethod
import server.protocol.PIOSerializer
import utils.JSON
import utils.LogConfigSocketToClient
import utils.Logger
import utils.UUID
import kotlin.math.pow
import kotlin.random.Random
import kotlin.time.Duration.Companion.seconds
import kotlin.time.DurationUnit

class MissionSaveHandler : SaveSubHandler {
    override val supportedTypes: Set<String> = SaveDataMethod.MISSION_SAVES

    // save stats of playerId: MissionStats
    // use this to know loots, EXP, kills, etc. after mission ended.
    private val missionStats: MutableMap<String, MissionStats> = mutableMapOf()

    // when player start a mission, generate missionId
    // this map from playerId to (missionId, insertedLoots)
    private val activeMissions = mutableMapOf<String, Pair<String, List<LootContent>>>()

    override suspend fun handle(ctx: SaveHandlerContext) = with(ctx) {
        val playerId = connection.playerId
        when (type) {
            SaveDataMethod.MISSION_START -> {
                // IMPORTANT NOTE: the scene that involves human model is not working now (e.g., raid island human)
                // the same error is for survivor class if you fill SurvivorAppearance non-null value
                // The error was 'cyclic object' thing.
                val isCompoundZombieAttack = data["compound"]?.equals(true)
                val areaType = if (isCompoundZombieAttack == true) "compound" else data["areaType"] as String
                Logger.info(LogConfigSocketToClient) { "Going to scene with areaType=$areaType" }

                val svc = serverContext.requirePlayerContext(playerId).services
                val leader = svc.survivor.getSurvivorLeader()

                val sceneXML = resolveAndLoadScene(areaType)
                if (sceneXML == null) {
                    Logger.error(LogConfigSocketToClient) { "That area=$areaType isn't working yet, typically because the map file is lost" }
                    return
                }
                val lootParameter = LootParameter(
                    areaLevel = (data["areaLevel"] as? Int ?: 0),
                    playerLevel = leader.level,
                    itemWeightOverrides = mapOf(),
                    specificItemBoost = mapOf(
                        "fuel-bottle" to 3.0,    // +300% find fuel chance (of the base chance)
                        "fuel-container" to 3.0,
                        "fuel" to 3.0,
                        "fuel-cans" to 3.0,
                    ),
                    itemTypeBoost = mapOf(
                        "junk" to 0.8 // +80% junk find chance
                    ),
                    itemQualityBoost = mapOf(
                        "blue" to 0.5 // +50% blue quality find chance
                    ),
                    baseWeight = 1.0,
                    fuelLimit = 50
                )
                val lootService = LootService(sceneXML, lootParameter)
                val (sceneXMLWithLoot, insertedLoots) = lootService.insertLoots()

                val zombies = listOf(
                    ZombieData.standardZombieWeakAttack(Random.nextInt()),
                    ZombieData.standardZombieWeakAttack(Random.nextInt()),
                    ZombieData.dogStandard(Random.nextInt()),
                    ZombieData.fatWalkerStrongAttack(Random.nextInt()),
                ).flatMap { it.toFlatList() }

                val timeSeconds = if (isCompoundZombieAttack == true) 30 else 240

                // temporarily use player's ID as missionId itself
                // this enables deterministic ID therefore can avoid memory leak
                // later, should save the missionId as task to DB in MISSION_END
                val missionId = connection.playerId
                activeMissions[connection.playerId] = missionId to insertedLoots

                val responseJson = JSON.encode(
                    MissionStartResponse(
                        id = missionId,
                        time = timeSeconds,
                        assignmentType = "None", // 'None' because not a raid or arena. see AssignmentType
                        areaClass = (data["areaClass"] as String?) ?: "", // supposedly depend on the area
                        automated = false,
                        sceneXML = sceneXMLWithLoot,
                        z = zombies,
                        allianceAttackerEnlisting = false,
                        allianceAttackerLockout = false,
                        allianceAttackerAllianceId = null,
                        allianceAttackerAllianceTag = null,
                        allianceMatch = false,
                        allianceRound = 0,
                        allianceRoundActive = false,
                        allianceError = false,
                        allianceAttackerWinPoints = 0
                    )
                )

                send(PIOSerializer.serialize(buildMsg(saveId, responseJson)), logFull = false)
            }

            SaveDataMethod.MISSION_START_FLAG -> {
                Logger.info { "<----- Mission start flag received ----->" }
            }

            SaveDataMethod.MISSION_INTERACTION_FLAG -> {
                Logger.info { "<----- First interaction received ----->" }
            }

            SaveDataMethod.MISSION_END -> {
                val svc = serverContext.requirePlayerContext(playerId).services
                val leader = svc.survivor.getSurvivorLeader()

                val playerStats = missionStats[connection.playerId] ?: MissionStats()
                val earnedXp = calculateMissionXp(playerStats.killData)

                val (missionId, insertedLoots) =
                    requireNotNull(activeMissions[connection.playerId]) { "Mission ID for playerId=$playerId was somehow null in MISSION_END request." }

                val rawLootedItems = summarizeLoots(data, insertedLoots)
                val (combinedLootedItems, obtainedResources) = buildInventoryAndResource(rawLootedItems)

                // Calculate new XP and level
                val newXp = leader.xp + earnedXp
                val (newLevel, newLevelPts) = calculateNewLevelAndPoints(leader.level, leader.xp, newXp)

                // Update the leader's XP and level
                // TODO respond to DB failure
                svc.survivor.updateSurvivor(leader.id) { currentLeader ->
                    currentLeader.copy(xp = newXp, level = newLevel)
                }

                // Broadcast level up if player leveled up
                if (newLevelPts > 0) {
                    try {
                        BroadcastService.broadcastUserLevel(connection.playerId, newLevel)
                    } catch (e: Exception) {
                        Logger.warn("Failed to broadcast user level: ${e.message}")
                    }
                }

                // Broadcast rare items found
                try {
                    combinedLootedItems.forEach { item ->
                        val quality = item.quality?.toString() ?: ""
                        if (quality.equals("legendary", ignoreCase = true) || quality.equals("epic", ignoreCase = true)) {
                            BroadcastService.broadcastItemFound(connection.playerId, item.type, quality)
                        }
                    }
                } catch (e: Exception) {
                    Logger.warn("Failed to broadcast items found: ${e.message}")
                }

                // Update player's inventory
                // TO-DO move inventory update to MissionReturnTask execute()
                // items and injuries are sent to player after mission return complete
                // TODO respond to DB failure
                svc.inventory.updateInventory { items ->
                    items.combineItems(
                        combinedLootedItems.filter { !GameDefinition.isResourceItem(it.type) },
                        GameDefinition
                    )
                }

                // TODO respond to DB failure
                svc.compound.updateResource { currentRes ->
                    // Cap resources at storage limit (default 100 per resource type)
                    val storageLimit = 100_000_000 // TODO: Get actual limit from GameDefinitions based on storage buildings
                    val cappedResources = GameResources(
                        wood = minOf(currentRes.wood + obtainedResources.wood, storageLimit),
                        metal = minOf(currentRes.metal + obtainedResources.metal, storageLimit),
                        cloth = minOf(currentRes.cloth + obtainedResources.cloth, storageLimit),
                        water = minOf(currentRes.water + obtainedResources.water, storageLimit),
                        food = minOf(currentRes.food + obtainedResources.food, storageLimit),
                        ammunition = minOf(currentRes.ammunition + obtainedResources.ammunition, storageLimit),
                        cash = currentRes.cash + obtainedResources.cash // Cash has no limit
                    )
                    cappedResources
                }

                val returnTime = 20.seconds

                val responseJson = JSON.encode(
                    MissionEndResponse(
                        automated = false,
                        xpEarned = earnedXp,
                        xp = XpBreakdown(total = earnedXp),
                        returnTimer = TimerData.runForDuration(
                            duration = returnTime,
                            data = mapOf("return" to returnTime.toInt(DurationUnit.SECONDS))
                        ),
                        lockTimer = null,
                        loot = combinedLootedItems,

                        // itmCounters is not related to item quantity
                        // it is some kind of internal weapon state (i.e., kill count)
                        itmCounters = emptyMap(),
                        injuries = null,
                        survivors = emptyList(),
                        player = PlayerSurvivor(
                            xp = newXp,
                            level = newLevel
                        ),
                        levelPts = newLevelPts,
                        cooldown = null
                    )
                )

                val resourceResponseJson = JSON.encode(svc.compound.getResources())
                send(PIOSerializer.serialize(buildMsg(saveId, responseJson, resourceResponseJson)))

                // TO-DO update player's task collection to include the mission return task
                serverContext.taskDispatcher.runTaskFor(
                    connection = connection,
                    taskToRun = MissionReturnTask(
                        taskInputBlock = {
                            this.missionId = missionId
                            this.returnTime = returnTime
                        },
                        stopInputBlock = {
                            this.missionId = missionId
                        }
                    )
                )

                missionStats.remove(connection.playerId)
                activeMissions.remove(connection.playerId)
            }

            SaveDataMethod.MISSION_ZOMBIES -> {
                // usually requested during middle of mission
                // there could be 'rush' flag somewhere, which means we need to send runner zombies

                val zombies = listOf(
                    ZombieData.strongRunner(Random.nextInt()),
                    ZombieData.standardZombieWeakAttack(Random.nextInt()),
                ).flatMap { it.toFlatList() }

                val responseJson = JSON.encode(
                    GetZombieResponse(
                        max = false,
                        z = zombies
                    )
                )

                Logger.info(LogConfigSocketToClient) { "'mis_zombies' message (spawn zombie) request received" }

                send(PIOSerializer.serialize(buildMsg(saveId, responseJson)))
            }

            SaveDataMethod.MISSION_INJURY -> {
                Logger.warn(LogConfigSocketToClient) { "Received 'MISSION_INJURY' message [not implemented]" }
            }

            SaveDataMethod.MISSION_SPEED_UP -> {
                Logger.warn(LogConfigSocketToClient) { "Received 'MISSION_SPEED_UP' message [not implemented]" }

                // TO-DO implement mission speed up similar to building speed up
                // TO-DO don't forget to save mission as a task to DB (TaskCollection),
                // just like how building construction modify upgrade/repair timer in DB

                // temporarily always make speed up always success so player don't stuck
                val response: MissionSpeedUpResponse = MissionSpeedUpResponse("", true, 0)
                val responseJson = JSON.encode(response)
                send(PIOSerializer.serialize(buildMsg(saveId, responseJson)))

                connection.sendMessage(NetworkMessage.MISSION_RETURN_COMPLETE, connection.playerId)
            }

            SaveDataMethod.MISSION_SCOUTED -> {
                Logger.warn(LogConfigSocketToClient) { "Received 'MISSION_SCOUTED' message [not implemented]" }
            }

            SaveDataMethod.MISSION_ITEM_USE -> {
                Logger.warn(LogConfigSocketToClient) { "Received 'MISSION_ITEM_USE' message [not implemented]" }
            }

            SaveDataMethod.MISSION_TRIGGER -> {
                Logger.warn(LogConfigSocketToClient) { "Received 'MISSION_TRIGGER' message [not implemented]" }
            }

            SaveDataMethod.MISSION_ELITE_SPAWNED -> {
                Logger.warn(LogConfigSocketToClient) { "Received 'MISSION_ELITE_SPAWNED' message [not implemented]" }
            }

            SaveDataMethod.MISSION_ELITE_KILLED -> {
                Logger.warn(LogConfigSocketToClient) { "Received 'MISSION_ELITE_KILLED' message [not implemented]" }
            }

            // also handle this
            SaveDataMethod.STAT_DATA -> {
                val playerStats = parseMissionStats(data["stats"])
                Logger.debug(logFull = true) { "STAT_DATA parsed: $playerStats" }
                missionStats[connection.playerId] = playerStats
                // TODO: attach missionStats to a running mission context or persist if needed
            }

            SaveDataMethod.STAT -> {
                val playerStats = parseMissionStats(data["stats"])
                Logger.debug(logFull = true) { "STAT parsed: $missionStats" }
                missionStats[connection.playerId] = playerStats
                // TODO: attach missionStats to a running mission context or persist if needed
            }
        }
    }

    private fun parseMissionStats(raw: Any?): MissionStats {
        val m = (raw as? Map<*, *>) ?: emptyMap<Any?, Any?>()
        fun asInt(v: Any?): Int = when (v) {
            is Int -> v
            is Long -> v.toInt()
            is Double -> v.toInt()
            is Float -> v.toInt()
            is Number -> v.toInt()
            is String -> v.toIntOrNull() ?: 0
            else -> 0
        }

        fun asDouble(v: Any?): Double = when (v) {
            is Double -> v
            is Float -> v.toDouble()
            is Int -> v.toDouble()
            is Long -> v.toDouble()
            is Number -> v.toDouble()
            is String -> v.toDoubleOrNull() ?: 0.0
            else -> 0.0
        }

        val knownKeys = setOf(
            "zombieSpawned", "levelUps", "damageOutput", "damageTaken", "containersSearched",
            "survivorKills", "survivorsDowned", "survivorExplosiveKills",
            "humanKills", "humanExplosiveKills",
            "zombieKills", "zombieExplosiveKills",
            "hpHealed", "explosivesPlaced", "grenadesThrown", "grenadesSmokeThrown",
            "allianceFlagCaptured", "buildingsDestroyed", "buildingsLost", "buildingsExplosiveDestroyed",
            "trapsTriggered", "trapDisarmTriggered",
            "cashFound", "woodFound", "metalFound", "clothFound", "foodFound", "waterFound",
            "ammunitionFound", "ammunitionUsed",
            "weaponsFound", "gearFound", "junkFound", "medicalFound", "craftingFound",
            "researchFound", "researchNoteFound", "clothingFound", "cratesFound", "schematicsFound",
            "effectFound", "rareWeaponFound", "rareGearFound", "uniqueWeaponFound", "uniqueGearFound",
            "greyWeaponFound", "greyGearFound", "whiteWeaponFound", "whiteGearFound",
            "greenWeaponFound", "greenGearFound", "blueWeaponFound", "blueGearFound",
            "purpleWeaponFound", "purpleGearFound", "premiumWeaponFound", "premiumGearFound"
        )

        val killData = buildMap {
            for ((kAny, v) in m) {
                val k = kAny?.toString() ?: continue
                if (k.endsWith("-kills") || k.endsWith("-explosive-kills")) {
                    put(k, asInt(v))
                }
            }
        }

        val customData = buildMap {
            for ((kAny, v) in m) {
                val k = kAny?.toString() ?: continue
                if (k !in knownKeys && !k.endsWith("-kills") && !k.endsWith("-explosive-kills")) {
                    val iv = asInt(v)
                    if (iv != 0) put(k, iv)
                }
            }
        }

        return MissionStats(
            zombieSpawned = asInt(m["zombieSpawned"]),
            levelUps = asInt(m["levelUps"]),
            damageOutput = asDouble(m["damageOutput"]),
            damageTaken = asDouble(m["damageTaken"]),
            containersSearched = asInt(m["containersSearched"]),
            survivorKills = asInt(m["survivorKills"]),
            survivorsDowned = asInt(m["survivorsDowned"]),
            survivorExplosiveKills = asInt(m["survivorExplosiveKills"]),
            humanKills = asInt(m["humanKills"]),
            humanExplosiveKills = asInt(m["humanExplosiveKills"]),
            zombieKills = asInt(m["zombieKills"]),
            zombieExplosiveKills = asInt(m["zombieExplosiveKills"]),
            hpHealed = asInt(m["hpHealed"]),
            explosivesPlaced = asInt(m["explosivesPlaced"]),
            grenadesThrown = asInt(m["grenadesThrown"]),
            grenadesSmokeThrown = asInt(m["grenadesSmokeThrown"]),
            allianceFlagCaptured = asInt(m["allianceFlagCaptured"]),
            buildingsDestroyed = asInt(m["buildingsDestroyed"]),
            buildingsLost = asInt(m["buildingsLost"]),
            buildingsExplosiveDestroyed = asInt(m["buildingsExplosiveDestroyed"]),
            trapsTriggered = asInt(m["trapsTriggered"]),
            trapDisarmTriggered = asInt(m["trapDisarmTriggered"]),
            cashFound = asInt(m["cashFound"]),
            woodFound = asInt(m["woodFound"]),
            metalFound = asInt(m["metalFound"]),
            clothFound = asInt(m["clothFound"]),
            foodFound = asInt(m["foodFound"]),
            waterFound = asInt(m["waterFound"]),
            ammunitionFound = asInt(m["ammunitionFound"]),
            ammunitionUsed = asInt(m["ammunitionUsed"]),
            weaponsFound = asInt(m["weaponsFound"]),
            gearFound = asInt(m["gearFound"]),
            junkFound = asInt(m["junkFound"]),
            medicalFound = asInt(m["medicalFound"]),
            craftingFound = asInt(m["craftingFound"]),
            researchFound = asInt(m["researchFound"]),
            researchNoteFound = asInt(m["researchNoteFound"]),
            clothingFound = asInt(m["clothingFound"]),
            cratesFound = asInt(m["cratesFound"]),
            schematicsFound = asInt(m["schematicsFound"]),
            effectFound = asInt(m["effectFound"]),
            rareWeaponFound = asInt(m["rareWeaponFound"]),
            rareGearFound = asInt(m["rareGearFound"]),
            uniqueWeaponFound = asInt(m["uniqueWeaponFound"]),
            uniqueGearFound = asInt(m["uniqueGearFound"]),
            greyWeaponFound = asInt(m["greyWeaponFound"]),
            greyGearFound = asInt(m["greyGearFound"]),
            whiteWeaponFound = asInt(m["whiteWeaponFound"]),
            whiteGearFound = asInt(m["whiteGearFound"]),
            greenWeaponFound = asInt(m["greenWeaponFound"]),
            greenGearFound = asInt(m["greenGearFound"]),
            blueWeaponFound = asInt(m["blueWeaponFound"]),
            blueGearFound = asInt(m["blueGearFound"]),
            purpleWeaponFound = asInt(m["purpleWeaponFound"]),
            purpleGearFound = asInt(m["purpleGearFound"]),
            premiumWeaponFound = asInt(m["premiumWeaponFound"]),
            premiumGearFound = asInt(m["premiumGearFound"]),
            killData = killData,
            customData = customData
        )
    }

    @Suppress("UNCHECKED_CAST")
    private fun summarizeLoots(data: Map<String, Any?>, serverInsertedLoots: List<LootContent>): List<Item> {
        val lootedIds: List<String> =
            requireNotNull(data["loot"] as? List<String>) { "Error: 'loot' structure in data is not as expected, data: $data" }
        val items = mutableSetOf<Item>()

        lootedIds.forEach { lootId ->
            val loot = serverInsertedLoots.find { it.lootId == lootId }
            if (loot != null) {
                items.add(Item(id = UUID.new(), type = loot.itemIdInXML, qty = loot.quantity.toUInt(), new = true))
            } else {
                Logger.warn { "Unexpected scenario: player reportedly loot:$lootId but it doesn't exist in serverInsertedLoots." }
            }
        }

        return items.toList()
    }

    private fun buildInventoryAndResource(items: List<Item>): Pair<List<Item>, GameResources> {
        var totalRes = GameResources()

        for (item in items) {
            if (GameDefinition.isResourceItem(item.type)) {
                val resAmount = GameDefinition.getResourceAmount(item.type)
                if (resAmount != null) {
                    totalRes += resAmount
                } else {
                    Logger.warn { "Unexpected scenario: item=${item.compactString()} was classified as resource item but getResourceAmount returns null" }
                }
            }
        }

        return items.stackOwnItems(GameDefinition) to totalRes
    }

    private fun calculateNewLevelAndPoints(currentLevel: Int, currentXp: Int, newXp: Int): Pair<Int, Int> {
        var level = currentLevel
        var levelPts = 0
        var xp = currentXp

        while (xp < newXp) {
            val xpForNextLevel = calculateXpForNextLevel(level)
            if (newXp >= xp + xpForNextLevel) {
                level++
                levelPts++
                xp += xpForNextLevel
            } else {
                break
            }
        }

        return Pair(level, levelPts)
    }

    private fun calculateXpForNextLevel(currentLevel: Int): Int {
        return (100 * (currentLevel.toDouble().pow(1.5))).toInt()
    }

    private fun calculateMissionXp(killData: Map<String, Int>): Int {
        var totalXp = 50
        totalXp += (killData["zombie"] ?: 0) * 5
        totalXp += (killData["runner"] ?: 0) * 10
        totalXp += (killData["fatty"] ?: 0) * 15
        totalXp += (killData["boss"] ?: 0) * 100
        return totalXp.coerceAtMost(1000)
    }
}



================================================================================
ðŸ“„ FICHIER : src\main\kotlin\server\handler\save\mission\response\GetZombieResponse.kt
================================================================================

package server.handler.save.mission.response

import server.handler.save.BaseResponse
import kotlinx.serialization.Serializable

/**
 * Get zombie response (mis_zombies)
 *
 * @property max server spawning is disabled if set to false
 */
@Serializable
data class GetZombieResponse(
    val z: List<String>,
    val max: Boolean = false,
): BaseResponse()



================================================================================
ðŸ“„ FICHIER : src\main\kotlin\server\handler\save\mission\response\MissionEndResponse.kt
================================================================================

package server.handler.save.mission.response

import core.items.model.Item
import core.model.game.data.Morale
import core.model.game.data.assignment.AssignmentResult
import core.survivor.model.injury.Injury
import dev.deadzone.core.model.game.data.TimerData
import kotlinx.serialization.Serializable

@Serializable
data class MissionEndResponse(
    // For isPvPPractice
    val bountyCollect: Boolean = false,
    val bounty: Double? = null,
    val allianceFlagCaptured: Boolean = false,
    val bountyCap: Int? = null,
    val bountyCapTimestamp: Long? = null,

    // If assignment type is raid or arena
    val assignmentresult: AssignmentResult? = null,

    // For onMissionEndSaved, required
    val automated: Boolean = false,
    val xpEarned: Int = 120,
    val xp: XpBreakdown? = null,
    val returnTimer: TimerData? = null,
    val lockTimer: TimerData? = null,
    val loot: List<Item> = emptyList(),
    val itmCounters: Map<String, Int> = emptyMap(), // item id to quantity
    val injuries: List<InjuryData>? = null,
    val survivors: List<SurvivorResult> = emptyList(),
    val player: PlayerSurvivor = PlayerSurvivor(),
    val levelPts: Int = 0,
    val cooldown: String? = null // base64 encoded string
)

@Serializable
data class XpBreakdown(
    val total: Int? = 120,
)

@Serializable
data class InjuryData(
    val success: Boolean = false, // false = didn't die
    val survivorId: String,
    val injury: Injury
)

@Serializable
data class SurvivorResult(
    val id: String, // survivor id
    val morale: Morale? = null,
    val xp: Int,
    val level: Int
)

@Serializable
data class PlayerSurvivor(
    val xp: Int = 120, // end xp after mission
    val level: Int = 60 // end level after mission
    // obviously, should be higher than before unless xp decrease is intended
)



================================================================================
ðŸ“„ FICHIER : src\main\kotlin\server\handler\save\mission\response\MissionSpeedUpResponse.kt
================================================================================

package dev.deadzone.socket.handler.save.mission.response

import kotlinx.serialization.Serializable

@Serializable
data class MissionSpeedUpResponse(
    val error: String, // not enough fuel error: PlayerIOError.NotEnoughCoins.errorID
    val success: Boolean = true,
    val cost: Int,
)



================================================================================
ðŸ“„ FICHIER : src\main\kotlin\server\handler\save\mission\response\MissionStartResponse.kt
================================================================================

package server.handler.save.mission.response

import server.handler.save.BaseResponse
import kotlinx.serialization.Serializable
import java.io.File
import java.io.InputStreamReader
import java.util.zip.GZIPInputStream

// SaveDataMethod.MISSION_START, MissionData.as line 685
@Serializable
data class MissionStartResponse(
    val disabled: Boolean = false,
    val id: String,
    val time: Int,
    val assignmentType: String,
    val areaClass: String,
    val automated: Boolean = false,
    val sceneXML: String,
    val z: List<String>,
    val allianceAttackerEnlisting: Boolean,
    val allianceAttackerLockout: Boolean,
    val allianceAttackerAllianceId: String?,
    val allianceAttackerAllianceTag: String?,
    val allianceMatch: Boolean,
    val allianceRound: Int,
    val allianceRoundActive: Boolean,
    val allianceError: Boolean,
    val allianceAttackerWinPoints: Int,
) : BaseResponse()

fun resolveAndLoadScene(areaType: String): String? {
    val scene = areaTypeToScenes[areaType]?.random()
    return scene?.let { loadSceneXML(it) }
}

fun loadSceneXML(filename: String): String {
    val path = "static/game/data/xml/scenes/$filename.xml.gz"
    val file = File(path)

    GZIPInputStream(file.inputStream()).use { gzipStream ->
        InputStreamReader(gzipStream, Charsets.UTF_8).use { reader ->
            return reader.readText()
        }
    }
}

val areaTypeToScenes = mapOf(
    // missing:
    // Convenience Store (areaType: tutorialStore)
    // Department Store (areaType: deptStore)
    // Forest (areaType: forest)
    // Suburban Street (areaType: substreet)
    // Street (areaType: street)

    "compound" to listOf(
        "compound"
    ),
    "bridge" to listOf(
        "exterior-bridge-1",
        "exterior-bridge-2",
        "exterior-bridge-3"
    ),
    "cityBlock" to listOf(
        "exterior-cityblock-1",
        "exterior-cityblock-2",
        "exterior-cityblock-3",
        "exterior-cityblock-4",
        "exterior-cityblock-5"
    ),
    "constSiteLarge" to listOf(
        "exterior-construction-1",
        "exterior-construction-2",
        "exterior-construction-3"
    ),
    "constSiteSmall" to listOf(
        "exterior-construction-small-1",
        "exterior-construction-small-2",
        "exterior-construction-small-3"
    ),
    "depot" to listOf(
        "exterior-depot-1",
        "exterior-depot-2",
        "exterior-depot-3"
    ),
    "dock" to listOf(
        "exterior-dock-1",
        "exterior-dock-2"
    ),
    "farm" to listOf(
        "exterior-farm-1",
        "exterior-farm-2",
    ),
    "highway" to listOf(
        "exterior-highway-1",
        "exterior-highway-2",
        "exterior-highway-3",
    ),
    "highwaySmall" to listOf(
        "exterior-highway-small-1",
        "exterior-highway-small-2",
        "exterior-highway-small-3",
    ),
    "militarybase" to listOf(
        "exterior-militarybase-1",
        "exterior-militarybase-2",
        "exterior-militarybase-3"
    ),
    "militaryDock" to listOf(
        "exterior-militarydock-1",
        "exterior-militarydock-2",
    ),
    "motelLarge" to listOf(
        "exterior-motel-1",
        "exterior-motel-2",
        "exterior-motel-3"
    ),
    "motel" to listOf(
        "exterior-motel-small-1",
        "exterior-motel-small-2",
        "exterior-motel-small-3"
    ),
    "parkLarge" to listOf(
        "exterior-park-large-1",
        "exterior-park-large-2",
        "exterior-park-large-3"
    ),
    "parkMedium" to listOf(
        "exterior-park-medium-1",
        "exterior-park-medium-2",
        "exterior-park-medium-3"
    ),
    "prison" to listOf(
        "exterior-prison-1",
        "exterior-prison-2",
        "exterior-prison-3",
    ),
    "shoppingstrip" to listOf(
        "exterior-shoppingstrip-1",
        "exterior-shoppingstrip-2",
    ),
    "shoppingStripSmall" to listOf(
        "exterior-shoppingstrip-small-1",
        "exterior-shoppingstrip-small-2",
    ),
    "subblock" to listOf(
        "exterior-subblock-1",
        "exterior-subblock-2"
    ),
    "trainStationLarge" to listOf(
        "exterior-trainstation-1",
        "exterior-trainstation-2"
    ),
    "trainStationSmall" to listOf(
        "exterior-trainstation-small-1",
        "exterior-trainstation-small-2"
    ),
    "trainYard" to listOf(
        "exterior-trainyard-1",
        "exterior-trainyard-2"
    ),
    "gunStore" to listOf(
        "interior-gunstore-1",
        "interior-gunstore-2",
        "interior-gunstore-3"
    ),
    "hardwareStoreLarge" to listOf(
        "interior-hardwarestore-large-1",
        "interior-hardwarestore-large-2",
        "interior-hardwarestore-large-3"
    ),
    "hospital" to listOf(
        "interior-hospital-1",
        "interior-hospital-2",
        "interior-hospital-3"
    ),
    "officeLarge" to listOf(
        "interior-office-large-1",
        "interior-office-large-2",
        "interior-office-large-3"
    ),
    "officeMedium" to listOf(
        "interior-office-medium-1",
        "interior-office-medium-2"
    ),
    "office" to listOf(
        "interior-office-small-1"
    ),
    "police" to listOf(
        "interior-police-large-1",
        "interior-police-large-2",
        "interior-police-large-3",
        "interior-police-medium-1",
        "interior-police-medium-2",
        "interior-police-medium-3"
    ),
    "residential" to listOf(
        "interior-residential",
        "interior-residential-2",
        "interior-residential-3",
        "interior-residential-4",
        "interior-residential-5"
    ),
    "resLarge" to listOf(
        "interior-residential-large-1",
        "interior-residential-large-2",
        "interior-residential-large-3"
    ),
    "security" to listOf(
        "interior-security-1",
        "interior-security-2",
        "interior-security-3",
    ),
    "store" to listOf(
        "interior-store-1",
        "interior-store-2",
        "interior-store-3"
    ),
    // No idea if this is the right one lol
    "tutorialStore" to listOf(
        "interior-store-small-1",
        "interior-store-small-2"
    ),
    "hardwareStore" to listOf(
        "interior-store-small-1",
        "interior-store-small-2"
    ),
    "subway" to listOf(
        "interior-subway-1",
        "interior-subway-2",
        "interior-subway-3"
    ),
    "subwayLarge" to listOf(
        "interior-subway-large-1",
        "interior-subway-large-2",
        "interior-subway-large-3"
    ),
    "superMarket" to listOf(
        "interior-supermarket-1",
        "interior-supermarket-2"
    ),
    "superMarketLarge" to listOf(
        "interior-supermarket-large-1",
        "interior-supermarket-large-2"
    ),
    "warehouse" to listOf(
        "interior-warehouse-1",
        "interior-warehouse-2",
        "interior-warehouse-3"
    ),
    "warehouseMedium" to listOf(
        "interior-warehouse-small-1",
        "interior-warehouse-small-2",
        "interior-warehouse-small-3"
    ),
    "streetSmall" to listOf(
        "street-small-1",
        "street-small-2",
        "street-small-3"
    ),

    // Others
    // Raid
    "raidBridgeHuman" to listOf(
        "raid-island-bridge-human-01",
        "raid-island-bridge-human-02",
        "raid-island-bridge-human-03"
    ),
    "raidBridgeZombie" to listOf(
        "raid-island-bridge-zombie-01",
        "raid-island-bridge-zombie-02",
        "raid-island-bridge-zombie-03"
    ),
    "raidCompoundHuman" to listOf(
        "raid-island-compound-human-01",
        "raid-island-compound-human-02",
        "raid-island-compound-human-03"
    ),
    "raidCompoundZombie" to listOf(
        "raid-island-compound-zombie-01",
        "raid-island-compound-zombie-02",
        "raid-island-compound-zombie-03"
    ),
    "raidMonumentHuman" to listOf(
        "raid-island-monument-human-01",
        "raid-island-monument-human-02",
        "raid-island-monument-human-03"
    ),
    "raidMonumentZombie" to listOf(
        "raid-island-monument-zombie-01",
        "raid-island-monument-zombie-02",
        "raid-island-monument-zombie-03"
    ),

    // Arena
    "stadium" to listOf(
        "exterior-stadium-1-no-spawn",
        "exterior-stadium-3-no-spawn",
        "exterior-stadium-5-no-spawn",
        "exterior-stadium-6-no-spawn",
        "exterior-stadium-7-no-spawn",
        "exterior-stadium-8-no-spawn",
        "exterior-stadium-9-no-spawn",
        "exterior-stadium-10-no-spawn",
        "exterior-stadium-11-no-spawn"
    ),
)



================================================================================
ðŸ“„ FICHIER : src\main\kotlin\server\handler\save\purchase\PurchaseSaveHandler.kt
================================================================================

package server.handler.save.purchase

import dev.deadzone.socket.handler.save.SaveHandlerContext
import server.handler.save.SaveSubHandler
import server.messaging.SaveDataMethod
import utils.LogConfigSocketToClient
import utils.Logger

class PurchaseSaveHandler : SaveSubHandler {
    override val supportedTypes: Set<String> = SaveDataMethod.PURCHASE_SAVES

    override suspend fun handle(ctx: SaveHandlerContext) = with(ctx) {
        when (type) {
            SaveDataMethod.RESOURCE_BUY -> {
                Logger.warn(LogConfigSocketToClient) { "Received 'RESOURCE_BUY' message [not implemented]" }
            }

            SaveDataMethod.PROTECTION_BUY -> {
                Logger.warn(LogConfigSocketToClient) { "Received 'PROTECTION_BUY' message [not implemented]" }
            }

            SaveDataMethod.PAYVAULT_BUY -> {
                Logger.warn(LogConfigSocketToClient) { "Received 'PAYVAULT_BUY' message [not implemented]" }
            }

            SaveDataMethod.CLAIM_PROMO_CODE -> {
                Logger.warn(LogConfigSocketToClient) { "Received 'CLAIM_PROMO_CODE' message [not implemented]" }
            }

            SaveDataMethod.BUY_PACKAGE -> {
                Logger.warn(LogConfigSocketToClient) { "Received 'BUY_PACKAGE' message [not implemented]" }
            }

            SaveDataMethod.CHECK_APPLY_DIRECT_PURCHASE -> {
                Logger.warn(LogConfigSocketToClient) { "Received 'CHECK_APPLY_DIRECT_PURCHASE' message [not implemented]" }
            }

            SaveDataMethod.HAS_PAYVAULT_ITEM -> {
                Logger.warn(LogConfigSocketToClient) { "Received 'HAS_PAYVAULT_ITEM' message [not implemented]" }
            }

            SaveDataMethod.INCREMENT_PURCHASE_COUNT -> {
                Logger.warn(LogConfigSocketToClient) { "Received 'INCREMENT_PURCHASE_COUNT' message [not implemented]" }
            }

            SaveDataMethod.DEATH_MOBILE_RENAME -> {
                Logger.warn(LogConfigSocketToClient) { "Received 'DEATH_MOBILE_RENAME' message [not implemented]" }
            }
        }
    }
}



================================================================================
ðŸ“„ FICHIER : src\main\kotlin\server\handler\save\quest\QuestSaveHandler.kt
================================================================================

package server.handler.save.quest

import dev.deadzone.socket.handler.save.SaveHandlerContext
import server.handler.save.SaveSubHandler
import server.messaging.SaveDataMethod
import utils.LogConfigSocketToClient
import utils.Logger

class QuestSaveHandler : SaveSubHandler {
    override val supportedTypes: Set<String> = SaveDataMethod.QUEST_SAVES

    override suspend fun handle(ctx: SaveHandlerContext) = with(ctx) {
        when (type) {
            SaveDataMethod.QUEST_COLLECT -> {
                Logger.warn(LogConfigSocketToClient) { "Received 'QUEST_COLLECT' message [not implemented]" }
            }

            SaveDataMethod.QUEST_TRACK -> {
                handleQuestTrack(ctx)
            }

            SaveDataMethod.QUEST_UNTRACK -> {
                handleQuestUntrack(ctx)
            }

            SaveDataMethod.QUEST_DAILY_DECLINE -> {
                Logger.warn(LogConfigSocketToClient) { "Received 'QUEST_DAILY_DECLINE' message [not implemented]" }
            }

            SaveDataMethod.QUEST_DAILY_ACCEPT -> {
                Logger.warn(LogConfigSocketToClient) { "Received 'QUEST_DAILY_ACCEPT' message [not implemented]" }
            }

            SaveDataMethod.REPEAT_ACHIEVEMENT -> {
                Logger.warn(LogConfigSocketToClient) { "Received 'REPEAT_ACHIEVEMENT' message [not implemented]" }
            }

            SaveDataMethod.GLOBAL_QUEST_COLLECT -> {
                Logger.warn(LogConfigSocketToClient) { "Received 'GLOBAL_QUEST_COLLECT' message [not implemented]" }
            }
        }
    }

    private suspend fun handleQuestTrack(ctx: SaveHandlerContext) = with(ctx) {
        val playerId = connection.playerId ?: run {
            Logger.error(LogConfigSocketToClient) { "QUEST_TRACK: No playerId in connection" }
            return
        }

        val questId = data["id"] as? String ?: run {
            Logger.error(LogConfigSocketToClient) { "QUEST_TRACK: Missing quest id 'id'" }
            return
        }

        val playerObjects = serverContext.db.loadPlayerObjects(playerId) ?: run {
            Logger.error(LogConfigSocketToClient) { "QUEST_TRACK: PlayerObjects not found for playerId=$playerId" }
            return
        }

        val currentTracked = playerObjects.questsTracked?.split(",")?.filter { it.isNotBlank() }?.toMutableList() ?: mutableListOf()

        if (!currentTracked.contains(questId)) {
            currentTracked.add(questId)

            val updatedPlayerObjects = playerObjects.copy(
                questsTracked = currentTracked.joinToString(",")
            )

            serverContext.db.updatePlayerObjectsJson(playerId, updatedPlayerObjects)

            Logger.info(LogConfigSocketToClient) { "QUEST_TRACK: Tracked quest $questId for player $playerId" }

            sendMessage(
                "saveOK",
                "saveID", saveId,
                "success", true
            )
        } else {
            Logger.info(LogConfigSocketToClient) { "QUEST_TRACK: Quest $questId already tracked for player $playerId" }
            sendMessage(
                "saveOK",
                "saveID", saveId,
                "success", true
            )
        }
    }

    private suspend fun handleQuestUntrack(ctx: SaveHandlerContext) = with(ctx) {
        val playerId = connection.playerId ?: run {
            Logger.error(LogConfigSocketToClient) { "QUEST_UNTRACK: No playerId in connection" }
            return
        }

        val questId = data["id"] as? String ?: run {
            Logger.error(LogConfigSocketToClient) { "QUEST_UNTRACK: Missing quest id 'id'" }
            return
        }

        val playerObjects = serverContext.db.loadPlayerObjects(playerId) ?: run {
            Logger.error(LogConfigSocketToClient) { "QUEST_UNTRACK: PlayerObjects not found for playerId=$playerId" }
            return
        }

        val currentTracked = playerObjects.questsTracked?.split(",")?.filter { it.isNotBlank() }?.toMutableList() ?: mutableListOf()

        if (currentTracked.remove(questId)) {
            val updatedPlayerObjects = playerObjects.copy(
                questsTracked = if (currentTracked.isEmpty()) null else currentTracked.joinToString(",")
            )

            serverContext.db.updatePlayerObjectsJson(playerId, updatedPlayerObjects)

            Logger.info(LogConfigSocketToClient) { "QUEST_UNTRACK: Untracked quest $questId for player $playerId" }

            sendMessage(
                "saveOK",
                "saveID", saveId,
                "success", true
            )
        } else {
            Logger.info(LogConfigSocketToClient) { "QUEST_UNTRACK: Quest $questId was not tracked for player $playerId" }
            sendMessage(
                "saveOK",
                "saveID", saveId,
                "success", true
            )
        }
    }
}



================================================================================
ðŸ“„ FICHIER : src\main\kotlin\server\handler\save\raid\RaidSaveHandler.kt
================================================================================

package server.handler.save.raid

import dev.deadzone.socket.handler.save.SaveHandlerContext
import server.handler.save.SaveSubHandler
import server.messaging.SaveDataMethod
import utils.LogConfigSocketToClient
import utils.Logger

class RaidSaveHandler : SaveSubHandler {
    override val supportedTypes: Set<String> = SaveDataMethod.RAID_SAVES

    override suspend fun handle(ctx: SaveHandlerContext) = with(ctx) {
        when (type) {
            SaveDataMethod.RAID_START -> {
                Logger.warn(LogConfigSocketToClient) { "Received 'RAID_START' message [not implemented]" }
            }

            SaveDataMethod.RAID_CONTINUE -> {
                Logger.warn(LogConfigSocketToClient) { "Received 'RAID_CONTINUE' message [not implemented]" }
            }

            SaveDataMethod.RAID_ABORT -> {
                Logger.warn(LogConfigSocketToClient) { "Received 'RAID_ABORT' message [not implemented]" }
            }

            SaveDataMethod.RAID_DEATH -> {
                Logger.warn(LogConfigSocketToClient) { "Received 'RAID_DEATH' message [not implemented]" }
            }
        }
    }
}



================================================================================
ðŸ“„ FICHIER : src\main\kotlin\server\handler\save\survivor\SurvivorSaveHandler.kt
================================================================================

package server.handler.save.survivor

import context.requirePlayerContext
import core.metadata.model.PlayerFlags
import core.model.game.data.HumanAppearance
import core.model.game.data.Survivor
import core.model.game.data.SurvivorClassConstants_Constants
import core.model.game.data.SurvivorLoadoutEntry
import dev.deadzone.socket.handler.save.SaveHandlerContext
import server.handler.buildMsg
import server.handler.save.SaveSubHandler
import server.handler.save.survivor.response.PlayerCustomResponse
import server.handler.save.survivor.response.SurvivorEditResponse
import server.handler.save.survivor.response.SurvivorRenameResponse
import server.handler.save.survivor.response.SurvivorClassResponse
import server.handler.save.survivor.response.SurvivorLoadoutResponse
import server.messaging.SaveDataMethod
import server.protocol.PIOSerializer
import utils.JSON
import utils.LogConfigSocketToClient
import utils.Logger

class SurvivorSaveHandler : SaveSubHandler {
    override val supportedTypes: Set<String> = SaveDataMethod.SURVIVOR_SAVES

    override suspend fun handle(ctx: SaveHandlerContext) = with(ctx) {
        val playerId = connection.playerId

        when (type) {
            SaveDataMethod.SURVIVOR_CLASS -> {
                val survivorId = data["survivorId"] as? String
                val classId = data["classId"] as? String

                if (survivorId == null || classId == null) {
                    val responseJson = JSON.encode(
                        SurvivorClassResponse(success = false, error = "invalid_params")
                    )
                    send(PIOSerializer.serialize(buildMsg(saveId, responseJson)))
                    return
                }

                val validClasses = listOf(
                    SurvivorClassConstants_Constants.FIGHTER.value,
                    SurvivorClassConstants_Constants.MEDIC.value,
                    SurvivorClassConstants_Constants.SCAVENGER.value,
                    SurvivorClassConstants_Constants.ENGINEER.value,
                    SurvivorClassConstants_Constants.RECON.value,
                    SurvivorClassConstants_Constants.UNASSIGNED.value
                )

                if (classId !in validClasses) {
                    val responseJson = JSON.encode(
                        SurvivorClassResponse(success = false, error = "invalid_class")
                    )
                    send(PIOSerializer.serialize(buildMsg(saveId, responseJson)))
                    return
                }

                val svc = serverContext.requirePlayerContext(playerId).services

                val updateResult = svc.survivor.updateSurvivor(srvId = survivorId) { currentSurvivor ->
                    currentSurvivor.copy(classId = classId)
                }

                val responseJson = if (updateResult.isSuccess) {
                    JSON.encode(SurvivorClassResponse(success = true))
                } else {
                    Logger.error(LogConfigSocketToClient) { "Failed to update survivor class: ${updateResult.exceptionOrNull()?.message}" }
                    JSON.encode(
                        SurvivorClassResponse(success = false, error = "update_failed")
                    )
                }
                send(PIOSerializer.serialize(buildMsg(saveId, responseJson)))
            }

            SaveDataMethod.SURVIVOR_OFFENCE_LOADOUT -> {
                val loadoutDataList = (data as? List<*>) ?: (data["data"] as? List<*>)

                if (loadoutDataList == null) {
                    val responseJson = JSON.encode(
                        SurvivorLoadoutResponse(success = false)
                    )
                    send(PIOSerializer.serialize(buildMsg(saveId, responseJson)))
                    return
                }

                val playerObjects = serverContext.db.loadPlayerObjects(playerId)
                if (playerObjects == null) {
                    val responseJson = JSON.encode(
                        SurvivorLoadoutResponse(success = false)
                    )
                    send(PIOSerializer.serialize(buildMsg(saveId, responseJson)))
                    return
                }

                val updatedLoadouts = mutableMapOf<String, SurvivorLoadoutEntry>()
                val bindItemIds = mutableListOf<String>()

                for (loadoutData in loadoutDataList) {
                    val loadoutMap = loadoutData as? Map<*, *> ?: continue
                    val survivorId = loadoutMap["id"] as? String ?: continue
                    val weaponId = (loadoutMap["weapon"] ?: loadoutMap["w"] ?: "") as? String ?: ""
                    val gear1Id = (loadoutMap["gearPassive"] ?: loadoutMap["g1"] ?: "") as? String ?: ""
                    val gear2Id = (loadoutMap["gearActive"] ?: loadoutMap["g2"] ?: "") as? String ?: ""

                    updatedLoadouts[survivorId] = SurvivorLoadoutEntry(
                        weapon = weaponId,
                        gear1 = gear1Id,
                        gear2 = gear2Id
                    )

                    if (weaponId.isNotEmpty()) bindItemIds.add(weaponId)
                    if (gear1Id.isNotEmpty()) bindItemIds.add(gear1Id)
                    if (gear2Id.isNotEmpty()) bindItemIds.add(gear2Id)
                }

                val updatedPlayerObjects = playerObjects.copy(offenceLoadout = updatedLoadouts)
                serverContext.db.updatePlayerObjectsJson(playerId, updatedPlayerObjects)

                val responseJson = JSON.encode(
                    SurvivorLoadoutResponse(success = true, bind = bindItemIds)
                )
                send(PIOSerializer.serialize(buildMsg(saveId, responseJson)))
            }

            SaveDataMethod.SURVIVOR_DEFENCE_LOADOUT -> {
                val loadoutDataList = (data as? List<*>) ?: (data["data"] as? List<*>)

                if (loadoutDataList == null) {
                    val responseJson = JSON.encode(
                        SurvivorLoadoutResponse(success = false)
                    )
                    send(PIOSerializer.serialize(buildMsg(saveId, responseJson)))
                    return
                }

                val playerObjects = serverContext.db.loadPlayerObjects(playerId)
                if (playerObjects == null) {
                    val responseJson = JSON.encode(
                        SurvivorLoadoutResponse(success = false)
                    )
                    send(PIOSerializer.serialize(buildMsg(saveId, responseJson)))
                    return
                }

                val updatedLoadouts = mutableMapOf<String, SurvivorLoadoutEntry>()
                val bindItemIds = mutableListOf<String>()

                for (loadoutData in loadoutDataList) {
                    val loadoutMap = loadoutData as? Map<*, *> ?: continue
                    val survivorId = loadoutMap["id"] as? String ?: continue
                    val weaponId = (loadoutMap["weapon"] ?: loadoutMap["w"] ?: "") as? String ?: ""
                    val gear1Id = (loadoutMap["gearPassive"] ?: loadoutMap["g1"] ?: "") as? String ?: ""
                    val gear2Id = (loadoutMap["gearActive"] ?: loadoutMap["g2"] ?: "") as? String ?: ""

                    updatedLoadouts[survivorId] = SurvivorLoadoutEntry(
                        weapon = weaponId,
                        gear1 = gear1Id,
                        gear2 = gear2Id
                    )

                    if (weaponId.isNotEmpty()) bindItemIds.add(weaponId)
                    if (gear1Id.isNotEmpty()) bindItemIds.add(gear1Id)
                    if (gear2Id.isNotEmpty()) bindItemIds.add(gear2Id)
                }

                val updatedPlayerObjects = playerObjects.copy(defenceLoadout = updatedLoadouts)
                serverContext.db.updatePlayerObjectsJson(playerId, updatedPlayerObjects)

                val responseJson = JSON.encode(
                    SurvivorLoadoutResponse(success = true, bind = bindItemIds)
                )
                send(PIOSerializer.serialize(buildMsg(saveId, responseJson)))
            }

            SaveDataMethod.SURVIVOR_CLOTHING_LOADOUT -> {
                val loadoutDataMap = data as? Map<*, *>

                if (loadoutDataMap == null) {
                    val responseJson = JSON.encode(
                        SurvivorLoadoutResponse(success = false)
                    )
                    send(PIOSerializer.serialize(buildMsg(saveId, responseJson)))
                    return
                }

                val svc = serverContext.requirePlayerContext(playerId).services
                val bindItemIds = mutableListOf<String>()
                val updatedSurvivors = mutableListOf<Survivor>()

                for (survivor in svc.survivor.getAllSurvivors()) {
                    val survivorData = loadoutDataMap[survivor.id] as? Map<*, *>

                    if (survivorData != null) {
                        val newAccessories = mutableMapOf<String, String>()
                        for ((slotIndex, itemId) in survivorData) {
                            val slotKey = slotIndex.toString()
                            val itemIdStr = itemId as? String ?: continue
                            if (itemIdStr.isNotEmpty()) {
                                newAccessories[slotKey] = itemIdStr
                                bindItemIds.add(itemIdStr)
                            }
                        }
                        updatedSurvivors.add(survivor.copy(accessories = newAccessories))
                    } else {
                        updatedSurvivors.add(survivor)
                    }
                }

                val updateResult = svc.survivor.updateSurvivors(updatedSurvivors)

                val responseJson = if (updateResult.isSuccess) {
                    JSON.encode(
                        SurvivorLoadoutResponse(success = true, bind = bindItemIds)
                    )
                } else {
                    Logger.error(LogConfigSocketToClient) { "Failed to update survivor clothing: ${updateResult.exceptionOrNull()?.message}" }
                    JSON.encode(
                        SurvivorLoadoutResponse(success = false)
                    )
                }
                send(PIOSerializer.serialize(buildMsg(saveId, responseJson)))
            }

            SaveDataMethod.SURVIVOR_INJURY_SPEED_UP -> {
                Logger.warn(LogConfigSocketToClient) { "Received 'SURVIVOR_INJURY_SPEED_UP' message [not implemented]" }
            }

            SaveDataMethod.SURVIVOR_RENAME -> {
                val survivorId = data["id"] as? String
                val name = data["name"] as? String

                if (survivorId == null || name == null) {
                    val responseJson = JSON.encode(
                        SurvivorRenameResponse(success = false, error = "name_invalid")
                    )
                    send(PIOSerializer.serialize(buildMsg(saveId, responseJson)))
                    return
                }

                val trimmedName = name.trim()

                if (trimmedName.length < 3) {
                    val responseJson = JSON.encode(
                        SurvivorRenameResponse(success = false, error = "name_short")
                    )
                    send(PIOSerializer.serialize(buildMsg(saveId, responseJson)))
                    return
                }

                if (trimmedName.length > 30) {
                    val responseJson = JSON.encode(
                        SurvivorRenameResponse(success = false, error = "name_long")
                    )
                    send(PIOSerializer.serialize(buildMsg(saveId, responseJson)))
                    return
                }

                if (!trimmedName.matches(Regex("^[a-zA-Z0-9 ]+$"))) {
                    val responseJson = JSON.encode(
                        SurvivorRenameResponse(success = false, error = "name_invalid")
                    )
                    send(PIOSerializer.serialize(buildMsg(saveId, responseJson)))
                    return
                }

                val svc = serverContext.requirePlayerContext(playerId).services

                val updateResult = svc.survivor.updateSurvivor(srvId = survivorId) { currentSurvivor ->
                    currentSurvivor.copy(
                        title = trimmedName,
                        firstName = trimmedName.split(" ").firstOrNull() ?: trimmedName,
                        lastName = trimmedName.split(" ").getOrNull(1) ?: ""
                    )
                }

                val responseJson = if (updateResult.isSuccess) {
                    JSON.encode(
                        SurvivorRenameResponse(success = true, name = trimmedName, id = survivorId)
                    )
                } else {
                    Logger.error(LogConfigSocketToClient) { "Failed to update survivor: ${updateResult.exceptionOrNull()?.message}" }
                    JSON.encode(
                        SurvivorRenameResponse(success = false, error = "name_invalid")
                    )
                }
                send(PIOSerializer.serialize(buildMsg(saveId, responseJson)))
            }

            SaveDataMethod.SURVIVOR_REASSIGN -> {
                Logger.warn(LogConfigSocketToClient) { "Received 'SURVIVOR_REASSIGN' message [not implemented]" }
            }

            SaveDataMethod.SURVIVOR_REASSIGN_SPEED_UP -> {
                Logger.warn(LogConfigSocketToClient) { "Received 'SURVIVOR_REASSIGN_SPEED_UP' message [not implemented]" }
            }

            SaveDataMethod.SURVIVOR_BUY -> {
                Logger.warn(LogConfigSocketToClient) { "Received 'SURVIVOR_BUY' message [not implemented]" }
            }

            SaveDataMethod.SURVIVOR_INJURE -> {
                Logger.warn(LogConfigSocketToClient) { "Received 'SURVIVOR_INJURE' message [not implemented]" }
            }

            SaveDataMethod.SURVIVOR_ENEMY_INJURE -> {
                Logger.warn(LogConfigSocketToClient) { "Received 'SURVIVOR_ENEMY_INJURE' message [not implemented]" }
            }

            SaveDataMethod.SURVIVOR_HEAL_INJURY -> {
                Logger.warn(LogConfigSocketToClient) { "Received 'SURVIVOR_HEAL_INJURY' message [not implemented]" }
            }

            SaveDataMethod.SURVIVOR_HEAL_ALL -> {
                Logger.warn(LogConfigSocketToClient) { "Received 'SURVIVOR_HEAL_ALL' message [not implemented]" }
            }

            SaveDataMethod.PLAYER_CUSTOM -> {
                val ap = data["ap"] as? Map<*, *> ?: return
                val title = data["name"] as? String ?: return
                val voice = data["v"] as? String ?: return
                val gender = data["g"] as? String ?: return
                val appearance = HumanAppearance.parse(ap)
                @Suppress("SENSELESS_COMPARISON")
                if (appearance == null) {
                    Logger.error(LogConfigSocketToClient) { "Failed to parse rawappearance=$ap" }
                    return
                }

                val bannedNicknames = listOf("dick")
                val nicknameNotAllowed = bannedNicknames.any { bannedWord ->
                    title.contains(bannedWord)
                }
                if (nicknameNotAllowed) {
                    val responseJson = JSON.encode(
                        PlayerCustomResponse(error = "Nickname not allowed")
                    )
                    send(PIOSerializer.serialize(buildMsg(saveId, responseJson)))
                    return
                }

                val svc = serverContext.requirePlayerContext(playerId).services

                val flagsResult = svc.playerObjectMetadata.updatePlayerFlags(
                    flags = PlayerFlags.create(nicknameVerified = true)
                )
                if (flagsResult.isFailure) {
                    Logger.error(LogConfigSocketToClient) { "Failed to update player flags: ${flagsResult.exceptionOrNull()?.message}" }
                    val responseJson = JSON.encode(
                        PlayerCustomResponse(error = "db_error")
                    )
                    send(PIOSerializer.serialize(buildMsg(saveId, responseJson)))
                    return
                }

                val nicknameResult = svc.playerObjectMetadata.updatePlayerNickname(nickname = title)
                if (nicknameResult.isFailure) {
                    Logger.error(LogConfigSocketToClient) { "Failed to update nickname: ${nicknameResult.exceptionOrNull()?.message}" }
                    val responseJson = JSON.encode(
                        PlayerCustomResponse(error = "db_error")
                    )
                    send(PIOSerializer.serialize(buildMsg(saveId, responseJson)))
                    return
                }

                val survivorResult = svc.survivor.updateSurvivor(srvId = svc.survivor.survivorLeaderId) {
                    svc.survivor.getSurvivorLeader().copy(
                        title = title,
                        firstName = title.split(" ").firstOrNull() ?: "",
                        lastName = title.split(" ").getOrNull(1) ?: "",
                        voice = voice,
                        gender = gender,
                        appearance = appearance
                    )
                }
                if (survivorResult.isFailure) {
                    Logger.error(LogConfigSocketToClient) { "Failed to update survivor: ${survivorResult.exceptionOrNull()?.message}" }
                    val responseJson = JSON.encode(
                        PlayerCustomResponse(error = "db_error")
                    )
                    send(PIOSerializer.serialize(buildMsg(saveId, responseJson)))
                    return
                }

                val responseJson = JSON.encode(PlayerCustomResponse())

                send(PIOSerializer.serialize(buildMsg(saveId, responseJson)))
            }

            SaveDataMethod.SURVIVOR_EDIT -> {
                val survivorId = data["id"] as? String ?: return
                val ap = data["ap"] as? Map<*, *>
                val gender = data["g"] as? String
                val voice = data["v"] as? String

                Logger.info(LogConfigSocketToClient) { "Editing survivor id=$survivorId, ap=$ap, gender=$gender, voice=$voice" }

                val svc = serverContext.requirePlayerContext(playerId).services

                val updateResult = svc.survivor.updateSurvivor(srvId = survivorId) { currentSurvivor ->
                    var updatedSurvivor = currentSurvivor

                    if (ap != null) {
                        val appearance = HumanAppearance.parse(ap)
                        @Suppress("SENSELESS_COMPARISON")
                        if (appearance != null) {
                            updatedSurvivor = updatedSurvivor.copy(appearance = appearance)
                        } else {
                            Logger.error(LogConfigSocketToClient) { "Failed to parse appearance=$ap" }
                        }
                    }

                    if (gender != null) {
                        updatedSurvivor = updatedSurvivor.copy(gender = gender)
                    }

                    if (voice != null) {
                        updatedSurvivor = updatedSurvivor.copy(voice = voice)
                    }

                    updatedSurvivor
                }

                val responseJson = if (updateResult.isSuccess) {
                    JSON.encode(SurvivorEditResponse(success = true))
                } else {
                    Logger.error(LogConfigSocketToClient) { "Failed to update survivor: ${updateResult.exceptionOrNull()?.message}" }
                    JSON.encode(SurvivorEditResponse(success = false))
                }
                send(PIOSerializer.serialize(buildMsg(saveId, responseJson)))
            }

            SaveDataMethod.NAMES -> {
                Logger.warn(LogConfigSocketToClient) { "Received 'NAMES' message [not implemented]" }
            }

            SaveDataMethod.RESET_LEADER -> {
                Logger.warn(LogConfigSocketToClient) { "Received 'RESET_LEADER' message [not implemented]" }
            }
        }
    }
}


================================================================================
ðŸ“„ FICHIER : src\main\kotlin\server\handler\save\survivor\response\PlayerCustomResponse.kt
================================================================================

package server.handler.save.survivor.response

import server.handler.save.BaseResponse
import kotlinx.serialization.Serializable

/**
 * Any update to player's leader, such as create leader, respec
 */
@Serializable
data class PlayerCustomResponse(
    // only if error
    val error: String? = null,

    // list of string which is AttributesConstants
    // likely used when leader respec skill
    val attributes: List<String> = emptyList(),

    // likely used when respec and there is extra level point??
    val levelPts: Int? = null,

    // base64 string, likely change name cooldown
    val cooldown: String? = null,
): BaseResponse()


================================================================================
ðŸ“„ FICHIER : src\main\kotlin\server\handler\save\survivor\response\SurvivorClassResponse.kt
================================================================================

package server.handler.save.survivor.response

import server.handler.save.BaseResponse
import kotlinx.serialization.Serializable

@Serializable
data class SurvivorClassResponse(
    val success: Boolean = true,
    val error: String? = null
): BaseResponse()



================================================================================
ðŸ“„ FICHIER : src\main\kotlin\server\handler\save\survivor\response\SurvivorEditResponse.kt
================================================================================

package server.handler.save.survivor.response

import server.handler.save.BaseResponse
import kotlinx.serialization.Serializable

@Serializable
data class SurvivorEditResponse(
    val success: Boolean = true
): BaseResponse()


================================================================================
ðŸ“„ FICHIER : src\main\kotlin\server\handler\save\survivor\response\SurvivorLoadoutResponse.kt
================================================================================

package server.handler.save.survivor.response

import server.handler.save.BaseResponse
import kotlinx.serialization.Serializable

@Serializable
data class SurvivorLoadoutResponse(
    val success: Boolean = true,
    val bind: List<String>? = null
): BaseResponse()



================================================================================
ðŸ“„ FICHIER : src\main\kotlin\server\handler\save\survivor\response\SurvivorRenameResponse.kt
================================================================================

package server.handler.save.survivor.response

import server.handler.save.BaseResponse
import kotlinx.serialization.Serializable

@Serializable
data class SurvivorRenameResponse(
    val success: Boolean = true,
    val error: String? = null,
    val name: String? = null,
    val id: String? = null
): BaseResponse()



================================================================================
ðŸ“„ FICHIER : src\main\kotlin\server\messaging\CommandMessage.kt
================================================================================

package server.messaging

/**
 * CC commands constants used by the game.
 */
@Suppress("Unused", "SpellCheckingInspection")
object CommandMessage {
    const val STORE_CLEAR = "storeClear"
    const val STORE_BLOCK = "storeBlock"
    const val SPAWN_ELITE = "spawnelite"
    const val ELITE_CHANCE = "elitechance"
    const val ADD_BOUNTY = "addbounty"
    const val LEVEL = "level"
    const val SERVER_TIME = "serverTime"
    const val ZOMBIE = "zombie"
    const val TIME = "time"
    const val STAT = "stat"
    const val GIVE_AMOUNT = "giveAmount"
    const val GIVE = "give"
    const val GIVE_RARE = "giveRare"
    const val GIVE_UNIQUE = "giveUnique"
    const val COUNTER = "counter"
    const val DAILY_QUEST = "dq"
    const val CHAT = "chat"
    const val LANG = "lang"
    const val FLAG = "flag"
    const val PROMO = "promo"
    const val BOUNTY_ADD = "badd"
    const val GIVE_INFECTED_BOUNTY = "giveinfectedbounty"
    const val BOUNTY_ABANDON = "bountyabandon"
    const val BOUNTY_COMPLETE = "bountycomplete"
    const val BOUNTY_TASK_COMPLETE = "bountytaskcomplete"
    const val BOUNTY_CONDITION_COMPLETE = "bountycondcomplete"
    const val BOUNTY_KILL = "bountykill"
    const val SKILL_GIVEXP = "skillgivexp"
    const val SKILL_LEVEL = "skilllevel"

    val COMMAND_SAVES = setOf(
        STORE_CLEAR,
        STORE_BLOCK,
        SPAWN_ELITE,
        ELITE_CHANCE,
        ADD_BOUNTY,
        LEVEL,
        SERVER_TIME,
        ZOMBIE,
        TIME,
        STAT,
        GIVE_AMOUNT,
        GIVE,
        GIVE_RARE,
        GIVE_UNIQUE,
        COUNTER,
        DAILY_QUEST,
        CHAT,
        LANG,
        FLAG,
        PROMO,
        BOUNTY_ADD,
        GIVE_INFECTED_BOUNTY,
        BOUNTY_ABANDON,
        BOUNTY_COMPLETE,
        BOUNTY_TASK_COMPLETE,
        BOUNTY_CONDITION_COMPLETE,
        BOUNTY_KILL,
        SKILL_GIVEXP,
        SKILL_LEVEL,
    )
}



================================================================================
ðŸ“„ FICHIER : src\main\kotlin\server\messaging\HandlerContext.kt
================================================================================

package dev.deadzone.socket.messaging

import server.core.Connection
import server.messaging.SocketMessage

/**
 * Encapsulate objects and data needed by handlers to handle message.
 */
class HandlerContext(
    val connection: Connection,
    val message: SocketMessage
) {
    suspend fun send(
        bytes: ByteArray,
        enableLogging: Boolean = true,
        logFull: Boolean = true
    ) {
        connection.sendRaw(bytes, enableLogging, logFull)
    }

    suspend fun sendMessage(
        type: String,
        vararg args: Any,
        enableLogging: Boolean = true,
        logFull: Boolean = true
    ) {
        connection.sendMessage(type, *args, enableLogging, logFull)
    }
}



================================================================================
ðŸ“„ FICHIER : src\main\kotlin\server\messaging\NetworkMessage.kt
================================================================================

package server.messaging

/**
 * Network message constants used by the game.
 */
@Suppress("Unused", "SpellCheckingInspection")
object NetworkMessage {
    // custom definition
    const val JOIN = "join"
    const val JOIN_RESULT = "playerio.joinresult"

    // from game
    const val INIT_COMPLETE = "ic"
    const val ERROR = "err"
    const val BANNED = "ban"
    const val SEND_RESPONSE = "r"
    const val SERVER_SHUTDOWN_UPDATE = "ssu"
    const val SERVER_SHUTDOWN_MAINTENANCE = "ssm"
    const val SERVER_ROOM_DISABLED = "srd"
    const val SERVER_SETTINGS = "ssup"
    const val SERVER_NEW_VERSION = "snv"
    const val GAME_READY = "gr"
    const val GAME_LOADING_PROGRESS = "gp"
    const val SERVER_INIT_PROGRESS = "sip"
    const val SIGN_IN_FAILED = "sf"
    const val SCENE_READY = "sr"
    const val SCENE_REQUEST = "srq"
    const val SERVER_UPDATE = "su"
    const val TIME_UPDATE = "tu"
    const val OUT_OF_SYNC = "os"
    const val PURCHASE_COIN = "p"
    const val SAVE = "s"
    const val SAVE_SUCCCESS = "ss"
    const val MISSION_LOOT = "ml"
    const val RESOURCE_UPDATE = "ru"
    const val SURVIVOR_NEW = "sn"
    const val PLAYER_VIEW_REQUEST = "pvr"
    const val PLAYER_ATTACK_REQUEST = "par"
    const val PLAYER_ATTACK_RESPONSE = "parp"
    const val HELP_PLAYER = "hp"
    const val NEW_NOTIFICATIONS = "nn"
    const val UNDER_ATTACK = "ua"
    const val ZOMBIE_ATTACK = "za"
    const val GET_PLAYER_SURVIVOR = "ps"
    const val GET_NEIGHBOR_STATES = "ns"
    const val REQUEST_ZOMBIE_ATTACK = "rza"
    const val REQUEST_SURVIVOR_CHECK = "rsc"
    const val TASK_COMPLETE = "tc"
    const val BUILDING_COMPLETE = "bc"
    const val BUILDING_REPAIR_COMPLETE = "brpc"
    const val MISSION_RETURN_COMPLETE = "mrc"
    const val MISSION_LOCK_COMPLETE = "mlc"
    const val SURVIVOR_INJURY_COMPLETE = "sic"
    const val BATCH_RECYCLE_COMPLETE = "brc"
    const val QUEST_PROGRESS = "qp"
    const val QUEST_DAILY_FAILED = "qdf"
    const val QUEST_ARMOR_GAMES_COMPLETE = "agq"
    const val SURVIVOR_REASSIGNMENT_COMPLETE = "src"
    const val EFFECT_COMPLETE = "ec"
    const val EFFECT_LOCKOUT_COMPLETE = "elc"
    const val COOLDOWN_COMPLETE = "cc"
    const val FLAG_CHANGED = "fc"
    const val UPGRADE_FLAG_CHANGED = "ufc"
    const val MISSION_EVENT = "me"
    const val PVP_LIST_UPDATE = "pvplist"
    const val SCAV_STARTED = "scvstrt"
    const val SCAV_ENDED = "scvend"
    const val FUEL_UPDATE = "fuel"
    const val TRADE_DISABLED = "td"
    const val LINKED_ALLIANCES = "alink"
    const val RESEARCH_COMPLETE = "rscmp"
    const val GLOBAL_QUEST_CONTRIBUTE = "gqcon"
    const val GLOBAL_QUEST_PROGRESS = "gqpr"
    const val BOUNTY_COMPLETE = "bcmp"
    const val BOUNTY_TASK_COMPLETE = "btcmp"
    const val BOUNTY_TASK_CONDITION_COMPLETE = "btccmp"
    const val BOUNTY_UPDATE = "bup"
    const val RPC = "rpc"
    const val RPC_RESPONSE = "rpcr"
}



================================================================================
ðŸ“„ FICHIER : src\main\kotlin\server\messaging\SaveDataMethod.kt
================================================================================

package server.messaging

/**
 * Save data method constants used by the game.
 */
@Suppress("Unused", "SpellCheckingInspection")
object SaveDataMethod {
    // -------------------- COMPOUND_BUILDING --------------------
    const val BUILDING_CREATE = "bld_create"
    const val BUILDING_CREATE_BUY = "bld_create_buy"
    const val BUILDING_UPGRADE = "bld_upgrade"
    const val BUILDING_UPGRADE_BUY = "bld_upgrade_buy"
    const val BUILDING_MOVE = "bld_move"
    const val BUILDING_RECYCLE = "bld_recycle"
    const val BUILDING_COLLECT = "bld_collect"
    const val BUILDING_CANCEL = "bld_cancel"
    const val BUILDING_SPEED_UP = "bld_speedup"
    const val BUILDING_REPAIR = "bld_repair"
    const val BUILDING_REPAIR_BUY = "bld_repair_buy"
    const val BUILDING_REPAIR_SPEED_UP = "bld_repair_speedup"
    const val BUILDING_TRAP_EXPLODE = "bld_trap_exp"

    val COMPOUND_BUILDING_SAVES = setOf(
        BUILDING_CREATE,
        BUILDING_CREATE_BUY,
        BUILDING_UPGRADE,
        BUILDING_UPGRADE_BUY,
        BUILDING_MOVE,
        BUILDING_RECYCLE,
        BUILDING_COLLECT,
        BUILDING_CANCEL,
        BUILDING_SPEED_UP,
        BUILDING_REPAIR,
        BUILDING_REPAIR_BUY,
        BUILDING_REPAIR_SPEED_UP,
        BUILDING_TRAP_EXPLODE,
    )

    // -------------------- COMPOUND_TASK --------------------
    const val TASK_STARTED = "tsk_start"
    const val TASK_CANCELLED = "tsk_cancelled"
    const val TASK_SURVIVOR_ASSIGNED = "tsk_srv_assign"
    const val TASK_SURVIVOR_REMOVED = "tsk_srv_remove"
    const val TASK_SPEED_UP = "tsk_speedup"

    val COMPOUND_TASK_SAVES = setOf(
        TASK_STARTED,
        TASK_CANCELLED,
        TASK_SURVIVOR_ASSIGNED,
        TASK_SURVIVOR_REMOVED,
        TASK_SPEED_UP,
    )

    // -------------------- COMPOUND_MISC --------------------
    const val CRAFT_ITEM = "craft_item"
    const val CRAFT_UPGRADE = "craft_upgrade"
    const val CRAFT_SCHEMATIC = "craft_schematic"
    const val EFFECT_SET = "effect_set"
    const val RESEARCH_START = "rsstrt"
    const val AH_EVENT = "ahEvent"
    const val CULL_NEIGHBORS = "cullneighbors"
    const val RALLY_ASSIGNMENT = "rally_assign"

    val COMPOUND_MISC_SAVES = setOf(
        CRAFT_ITEM,
        CRAFT_UPGRADE,
        CRAFT_SCHEMATIC,
        EFFECT_SET,
        RESEARCH_START,
        AH_EVENT,
        CULL_NEIGHBORS,
        RALLY_ASSIGNMENT
    )

    // -------------------- ITEM --------------------
    const val ITEM = "itm"
    const val ITEM_BUY = "itm_buy"
    const val ITEM_LIST = "itm_list"
    const val ITEM_RECYCLE = "itm_recycle"
    const val ITEM_DISPOSE = "itm_dispose"
    const val ITEM_CLEAR_NEW = "itm_clear_new"
    const val ITEM_BATCH_RECYCLE = "itm_batch_recycle"
    const val ITEM_BATCH_RECYCLE_SPEED_UP = "itm_batch_recycle_speedup"
    const val ITEM_BATCH_DISPOSE = "itm_batch_dispose"

    val ITEM_SAVES = setOf(
        ITEM,
        ITEM_BUY,
        ITEM_LIST,
        ITEM_RECYCLE,
        ITEM_DISPOSE,
        ITEM_CLEAR_NEW,
        ITEM_BATCH_RECYCLE,
        ITEM_BATCH_RECYCLE_SPEED_UP,
        ITEM_BATCH_DISPOSE,
    )

    // -------------------- MISSION --------------------
    const val MISSION_START = "mis_start"
    const val MISSION_END = "mis_end"
    const val MISSION_INJURY = "mis_inj"
    const val MISSION_SPEED_UP = "mis_speedup"
    const val MISSION_ZOMBIES = "mis_zombies"
    const val MISSION_START_FLAG = "mis_startFlag"
    const val MISSION_INTERACTION_FLAG = "mis_interacted"
    const val MISSION_SCOUTED = "mis_scouted"
    const val MISSION_ITEM_USE = "mis_use"
    const val MISSION_TRIGGER = "mis_trig"
    const val MISSION_ELITE_SPAWNED = "mis_elsp"
    const val MISSION_ELITE_KILLED = "mis_elkl"

    val MISSION_SAVES = setOf(
        MISSION_START,
        MISSION_END,
        MISSION_INJURY,
        MISSION_SPEED_UP,
        MISSION_ZOMBIES,
        MISSION_START_FLAG,
        MISSION_INTERACTION_FLAG,
        MISSION_SCOUTED,
        MISSION_ITEM_USE,
        MISSION_TRIGGER,
        MISSION_ELITE_SPAWNED,
        MISSION_ELITE_KILLED,
        STAT_DATA,
        STAT
    )

    // -------------------- SURVIVOR --------------------
    const val SURVIVOR_CLASS = "srv_class"
    const val SURVIVOR_OFFENCE_LOADOUT = "srv_oLoadout"
    const val SURVIVOR_DEFENCE_LOADOUT = "srv_dLoadout"
    const val SURVIVOR_CLOTHING_LOADOUT = "srv_cLoadout"
    const val SURVIVOR_INJURY_SPEED_UP = "srv_injury_speedup"
    const val SURVIVOR_RENAME = "srv_rename"
    const val SURVIVOR_REASSIGN = "srv_reassign"
    const val SURVIVOR_REASSIGN_SPEED_UP = "srv_reassign_speedup"
    const val SURVIVOR_BUY = "srv_buy"
    const val SURVIVOR_INJURE = "srv_inj"
    const val SURVIVOR_ENEMY_INJURE = "srv_einj"
    const val SURVIVOR_HEAL_INJURY = "srv_heal"
    const val SURVIVOR_HEAL_ALL = "srv_healall"
    const val PLAYER_CUSTOM = "ply_custom"
    const val SURVIVOR_EDIT = "srv_edit"
    const val NAMES = "names"
    const val RESET_LEADER = "resetLeader"

    val SURVIVOR_SAVES = setOf(
        SURVIVOR_CLASS,
        SURVIVOR_OFFENCE_LOADOUT,
        SURVIVOR_DEFENCE_LOADOUT,
        SURVIVOR_CLOTHING_LOADOUT,
        SURVIVOR_INJURY_SPEED_UP,
        SURVIVOR_RENAME,
        SURVIVOR_REASSIGN,
        SURVIVOR_REASSIGN_SPEED_UP,
        SURVIVOR_BUY,
        SURVIVOR_INJURE,
        SURVIVOR_ENEMY_INJURE,
        SURVIVOR_HEAL_INJURY,
        SURVIVOR_HEAL_ALL,
        PLAYER_CUSTOM,
        SURVIVOR_EDIT,
        NAMES,
        RESET_LEADER,
    )

    // -------------------- RAID --------------------
    const val RAID_START = "raid_start"
    const val RAID_CONTINUE = "raid_cont"
    const val RAID_ABORT = "raid_abort"
    const val RAID_DEATH = "raid_death"

    val RAID_SAVES = setOf(
        RAID_START,
        RAID_CONTINUE,
        RAID_ABORT,
        RAID_DEATH,
    )

    // -------------------- ARENA --------------------
    const val ARENA_START = "arena_start"
    const val ARENA_CONTINUE = "arena_cont"
    const val ARENA_FINISH = "arena_fin"
    const val ARENA_ABORT = "arena_abort"
    const val ARENA_DEATH = "arena_death"
    const val ARENA_UPDATE = "arena_update"
    const val ARENA_LEADER = "arena_ldr"
    const val ARENA_LEADERBOARD = "arena_lb"

    val ARENA_SAVES = setOf(
        ARENA_START,
        ARENA_CONTINUE,
        ARENA_FINISH,
        ARENA_ABORT,
        ARENA_DEATH,
        ARENA_UPDATE,
        ARENA_LEADER,
        ARENA_LEADERBOARD,
    )

    // -------------------- QUEST --------------------
    const val QUEST_COLLECT = "quest_collect"
    const val QUEST_TRACK = "quest_track"
    const val QUEST_UNTRACK = "quest_untrack"
    const val QUEST_DAILY_DECLINE = "quest_daily_dec"
    const val QUEST_DAILY_ACCEPT = "quest_daily_acc"
    const val REPEAT_ACHIEVEMENT = "rep_ach"
    const val GLOBAL_QUEST_COLLECT = "gQuest_collect"

    val QUEST_SAVES = setOf(
        QUEST_COLLECT,
        QUEST_TRACK,
        QUEST_UNTRACK,
        QUEST_DAILY_DECLINE,
        QUEST_DAILY_ACCEPT,
        REPEAT_ACHIEVEMENT,
        GLOBAL_QUEST_COLLECT
    )

    // -------------------- CRATE --------------------
    const val CRATE_UNLOCK = "crate_unlock"
    const val CRATE_MYSTERY_UNLOCK = "crate_mystery_unlock"

    val CRATE_SAVES = setOf(
        CRATE_UNLOCK,
        CRATE_MYSTERY_UNLOCK
    )

    // -------------------- ALLIANCE --------------------
    const val ALLIANCE_CREATE = "alliance_create"
    const val ALLIANCE_COLLECT_WINNINGS = "alliance_collectWinnings"
    const val ALLIANCE_QUERY_WINNINGS = "alliance_queryWinnings"
    const val ALLIANCE_GET_PREV_ROUND_RESULT = "alliance_getPrevRoundResults"
    const val ALLIANCE_EFFECT_UPDATE = "alliance_effects"
    const val ALLIANCE_INFORM_ABOUT_LEAVE = "alliance_informAboutLeave"
    const val ALLIANCE_GET_LIFETIMESTATS = "alliance_getLifeStats"

    val ALLIANCE_SAVES = setOf(
        ALLIANCE_CREATE,
        ALLIANCE_COLLECT_WINNINGS,
        ALLIANCE_QUERY_WINNINGS,
        ALLIANCE_GET_PREV_ROUND_RESULT,
        ALLIANCE_EFFECT_UPDATE,
        ALLIANCE_INFORM_ABOUT_LEAVE,
        ALLIANCE_GET_LIFETIMESTATS,
    )

    // -------------------- CHAT --------------------
    const val CHAT_SILENCED = "chat_silenced"
    const val CHAT_KICKED = "chat_kicked"
    const val CHAT_GET_CONTACTS_AND_BLOCKS = "chat_getContactsBlocks"
    const val CHAT_MIGRATE_CONTACTS_AND_BLOCKS = "chat_migrateContactsBlocks"
    const val CHAT_ADD_CONTACT = "chat_addContact"
    const val CHAT_REMOVE_CONTACT = "chat_removeContact"
    const val CHAT_REMOVE_ALL_CONTACTS = "chat_removeAllContacts"
    const val CHAT_ADD_BLOCK = "chat_addBlock"
    const val CHAT_REMOVE_BLOCK = "chat_removeBlock"
    const val CHAT_REMOVE_ALL_BLOCKS = "chat_removeAllBlocks"

    val CHAT_SAVES = setOf(
        CHAT_SILENCED,
        CHAT_KICKED,
        CHAT_GET_CONTACTS_AND_BLOCKS,
        CHAT_MIGRATE_CONTACTS_AND_BLOCKS,
        CHAT_ADD_CONTACT,
        CHAT_REMOVE_CONTACT,
        CHAT_REMOVE_ALL_CONTACTS,
        CHAT_ADD_BLOCK,
        CHAT_REMOVE_BLOCK,
        CHAT_REMOVE_ALL_BLOCKS,
    )

    // -------------------- BOUNTY --------------------
    const val BOUNTY_VIEW = "dzbountyview"
    const val BOUNTY_SPEED_UP = "dzbountyspeedup"
    const val BOUNTY_NEW = "dzbountynew"
    const val BOUNTY_ABANDON = "dzbountyabn"
    const val BOUNTY_ADD = "addBounty"

    val BOUNTY_SAVES = setOf(
        BOUNTY_VIEW,
        BOUNTY_SPEED_UP,
        BOUNTY_NEW,
        BOUNTY_ABANDON,
        BOUNTY_ADD,
    )

    // -------------------- PURCHASE --------------------
    const val RESOURCE_BUY = "res_buy"
    const val PROTECTION_BUY = "prot_buy"
    const val PAYVAULT_BUY = "payvault_buy"
    const val CLAIM_PROMO_CODE = "claim_promo"
    const val BUY_PACKAGE = "pack_buy"
    const val CHECK_APPLY_DIRECT_PURCHASE = "chk_dp"
    const val HAS_PAYVAULT_ITEM = "haspvitem"
    const val INCREMENT_PURCHASE_COUNT = "incPrchCnt"
    const val DEATH_MOBILE_RENAME = "dm_rename"

    val PURCHASE_SAVES = setOf(
        RESOURCE_BUY,
        PROTECTION_BUY,
        PAYVAULT_BUY,
        CLAIM_PROMO_CODE,
        BUY_PACKAGE,
        CHECK_APPLY_DIRECT_PURCHASE,
        HAS_PAYVAULT_ITEM,
        INCREMENT_PURCHASE_COUNT,
        DEATH_MOBILE_RENAME
    )

    // -------------------- COMMON --------------------
    const val STAT = "stat"
    const val GET_STATS = "stat_get"
    const val GLOBAL_STAT = "gstat"
    const val STAT_DATA = "stat_data"

    // -------------------- MISC --------------------
    const val TUTORIAL_PVP_PRACTICE = "tut_pvppractice"
    const val TUTORIAL_COMPLETE = "tut_complete"
    const val GET_OFFERS = "get_offers"
    const val NEWS_READ = "news_read"
    const val CLEAR_NOTIFICATIONS = "clear_notes"
    const val FLUSH_PLAYER = "flushPlayer"
    const val SAVE_ALT_IDS = "savealts"
    const val TRADE_DO_TRADE = "trade_doTrade"
    const val GET_INVENTORY_SIZE = "get_invsize"

    val MISC_SAVES = setOf(
        TUTORIAL_PVP_PRACTICE,
        TUTORIAL_COMPLETE,
        GET_OFFERS,
        NEWS_READ,
        CLEAR_NOTIFICATIONS,
        FLUSH_PLAYER,
        SAVE_ALT_IDS,
        TRADE_DO_TRADE,
        GET_INVENTORY_SIZE
    )
}



================================================================================
ðŸ“„ FICHIER : src\main\kotlin\server\messaging\SocketMessage.kt
================================================================================

package server.messaging

import utils.parseJsonToMap

/**
 * A higher-level representation of game message sent to the socket server.
 *
 * Message is always a flat list of even length (if odd then the first is the type).
 * Two of each element is paired as key-value pair.
 *
 * @constructor Raw deserialized data received from socket connection
 *
 */
class SocketMessage(private val raw: List<Any>) {
    val type: String? = if (raw.size % 2 == 1 && raw.size != 1) raw.firstOrNull() as? String else null

    private val map: Map<String, Any?> = buildMap {
        val start = if (type != null) 1 else 0
        val end = raw.size
        for (i in start until end step 2) {
            val key = raw.getOrNull(i) as? String ?: continue
            val value = raw.getOrNull(i + 1)
            put(key, value)
        }
    }

    fun isEmpty(): Boolean {
        return map.keys.isEmpty()
    }

    /**
     * Type of socket message in String.
     *
     * This will check [type] (which is non-null string if length of message is odd).
     * The fallback will be the first key of the message map.
     * If message type is not able to be determined after these two, this will return `[Undetermined]`
     */
    fun msgTypeToString(): String {
        if (map.keys.firstOrNull() == "s") {
            return "save/${getSaveSubType()}"
        }
        return type ?: (map.keys.firstOrNull() ?: "[Undetermined]")
    }

    @Suppress("UNCHECKED_CAST")
    fun getSaveSubType(): String {
        return (this.getMap("s")?.get("data") as? Map<String, Any?>)?.get("_type") as String? ?: ""
    }

    /**
     * Get a value (`any` type) from particular key.
     * Use [getString], [getInt], etc for typed result
     *
     * @param key
     * @return the value from the corresponding key in the message
     */
    fun get(key: String): Any? = map[key]

    fun contains(key: String): Boolean {
        return map.containsKey(key)
    }

    fun getString(key: String): String? = map[key] as? String
    fun getInt(key: String): Int? = (map[key] as? Number)?.toInt()

    @Suppress("UNCHECKED_CAST")
    fun getMap(key: String): Map<String, Any?>? {
        val rawValue = map[key] ?: return null
        return when (rawValue) {
            is Map<*, *> -> rawValue as? Map<String, Any?>
            is String -> {
                try {
                    parseJsonToMap(rawValue)
                } catch (_: Exception) {
                    null
                }
            }

            else -> null
        }
    }

    override fun toString(): String = if (type != null)
        "Message(type=$type, map=$map)"
    else
        "Message(map=$map)"

    companion object {
        fun fromRaw(raw: List<Any>): SocketMessage {
            return SocketMessage(raw)
        }
    }
}



================================================================================
ðŸ“„ FICHIER : src\main\kotlin\server\messaging\SocketMessageDispatcher.kt
================================================================================

package server.messaging

import server.handler.DefaultHandler
import utils.Logger

/**
 * Dispatch [SocketMessage] to a registered handler
 */
class SocketMessageDispatcher() {
    private val handlers = mutableListOf<SocketMessageHandler>()

    fun register(handler: SocketMessageHandler) {
        handlers.add(handler)
    }

    fun findHandlerFor(msg: SocketMessage): SocketMessageHandler {
        return (handlers.find { it.match(msg) } ?: DefaultHandler()).also {
            Logger.debug { "Handled by $it, type=${msg.type} | message=$msg" }
        }
    }

    fun shutdown() {
        handlers.clear()
    }
}



================================================================================
ðŸ“„ FICHIER : src\main\kotlin\server\messaging\SocketMessageHandler.kt
================================================================================

package server.messaging

import dev.deadzone.socket.messaging.HandlerContext

/**
 * A template for socket message handler
 *
 * See example
 * - [socket.handler.JoinHandler]
 * - [socket.handler.DefaultHandler]
 */
interface SocketMessageHandler {
    fun match(message: SocketMessage): Boolean
    suspend fun handle(ctx: HandlerContext)
}



================================================================================
ðŸ“„ FICHIER : src\main\kotlin\server\protocol\Pattern.kt
================================================================================

package server.protocol

internal enum class Pattern(val value: Int) {
    STRING_SHORT_PATTERN(0xC0),
    STRING_PATTERN(0x0C),
    BYTE_ARRAY_SHORT_PATTERN(0x40),
    BYTE_ARRAY_PATTERN(0x10),
    UNSIGNED_LONG_SHORT_PATTERN(0x38),
    UNSIGNED_LONG_PATTERN(0x3C),
    LONG_SHORT_PATTERN(0x30),
    LONG_PATTERN(0x34),
    UNSIGNED_INT_SHORT_PATTERN(0x80),
    UNSIGNED_INT_PATTERN(0x08),
    INT_PATTERN(0x04),
    DOUBLE_PATTERN(0x03),
    FLOAT_PATTERN(0x02),
    BOOLEAN_TRUE_PATTERN(0x01),
    BOOLEAN_FALSE_PATTERN(0x00),
    DOES_NOT_EXIST(0xFF);

    companion object {
        fun fromByte(byte: Int): Pattern {
            return entries.toTypedArray().sortedByDescending { it.value }.firstOrNull {
                byte and it.value == it.value
            } ?: DOES_NOT_EXIST
        }
    }
}



================================================================================
ðŸ“„ FICHIER : src\main\kotlin\server\protocol\PIODeserializer.kt
================================================================================

package server.protocol

import utils.LogConfigSocketError
import utils.LogSource
import utils.Logger
import utils.parseJsonToMap
import java.io.ByteArrayOutputStream
import java.nio.ByteBuffer
import java.nio.ByteOrder

object PIODeserializer {
    fun deserialize(data: ByteArray): List<Any> {
        var state = "init"
        var pattern = Pattern.DOES_NOT_EXIST
        val buffer = ByteArrayOutputStream()
        var partLength = 0
        val length = -1
        val message = mutableListOf<Any>()

        fun onValue(value: Any?) {
            if (length == -1 && value is Int) {
            } else {
                message.add(value ?: "null")
            }
        }

        fun ByteArray.padStart(size: Int): ByteArray {
            return ByteArray(size - this.size) { 0 } + this
        }

        try {
            for (byte in data) {
                when (state) {
                    "init" -> {
                        pattern = Pattern.fromByte(byte.toInt() and 0xFF)
                        val part = byte.toInt() and 0x3F

                        when (pattern) {
                            Pattern.STRING_SHORT_PATTERN,
                            Pattern.BYTE_ARRAY_SHORT_PATTERN -> {
                                partLength = part
                                state = if (partLength > 0) "data" else {
                                    val value = if (pattern == Pattern.STRING_SHORT_PATTERN) "" else ByteArray(0)
                                    onValue(value)
                                    "init"
                                }
                            }

                            Pattern.STRING_PATTERN,
                            Pattern.BYTE_ARRAY_PATTERN,
                            Pattern.UNSIGNED_INT_PATTERN,
                            Pattern.INT_PATTERN -> {
                                partLength = 4
                                state = "header"
                            }

                            Pattern.UNSIGNED_INT_SHORT_PATTERN -> {
                                onValue(part)
                            }

                            Pattern.UNSIGNED_LONG_SHORT_PATTERN,
                            Pattern.LONG_SHORT_PATTERN -> {
                                partLength = 1
                                state = "data"
                            }

                            Pattern.UNSIGNED_LONG_PATTERN,
                            Pattern.LONG_PATTERN -> {
                                partLength = 6
                                state = "data"
                            }

                            Pattern.DOUBLE_PATTERN -> {
                                partLength = 8
                                state = "data"
                            }

                            Pattern.FLOAT_PATTERN -> {
                                partLength = 4
                                state = "data"
                            }

                            Pattern.BOOLEAN_TRUE_PATTERN -> onValue(true)
                            Pattern.BOOLEAN_FALSE_PATTERN -> onValue(false)
                            else -> {} // unsupported
                        }
                    }

                    "header" -> {
                        buffer.write(byte.toInt())
                        if (buffer.size() == partLength) {
                            val padded = buffer.toByteArray().padStart(4)
                            partLength = ByteBuffer.wrap(padded).order(ByteOrder.LITTLE_ENDIAN).int

                            if (partLength !in 0..10_000_000) {
                                throw IllegalArgumentException("Invalid partLength = $partLength")
                            }

                            buffer.reset()
                            state = "data"
                        }
                    }

                    "data" -> {
                        buffer.write(byte.toInt())
                        if (buffer.size() == partLength) {
                            val bytes = buffer.toByteArray()
                            val padded = { b: ByteArray, size: Int -> b.padStart(size) }

                            val value = try {
                                when (pattern) {
                                    Pattern.STRING_SHORT_PATTERN,
                                    Pattern.STRING_PATTERN -> bytes.toString(Charsets.UTF_8)

                                    Pattern.UNSIGNED_INT_PATTERN,
                                    Pattern.INT_PATTERN -> ByteBuffer.wrap(padded(bytes, 4))
                                        .order(ByteOrder.BIG_ENDIAN).int

                                    Pattern.UNSIGNED_LONG_PATTERN,
                                    Pattern.UNSIGNED_LONG_SHORT_PATTERN,
                                    Pattern.LONG_PATTERN,
                                    Pattern.LONG_SHORT_PATTERN -> ByteBuffer.wrap(padded(bytes, 8))
                                        .order(ByteOrder.BIG_ENDIAN).long

                                    Pattern.DOUBLE_PATTERN -> ByteBuffer.wrap(padded(bytes, 8))
                                        .order(ByteOrder.BIG_ENDIAN).double

                                    Pattern.FLOAT_PATTERN -> ByteBuffer.wrap(padded(bytes, 4))
                                        .order(ByteOrder.BIG_ENDIAN).float

                                    Pattern.BYTE_ARRAY_SHORT_PATTERN,
                                    Pattern.BYTE_ARRAY_PATTERN -> bytes

                                    else -> null
                                }
                            } catch (e: Exception) {
                                Logger.error(LogConfigSocketError) { "Error deserializing pattern $pattern: ${e.message}" }
                                null
                            }

                            onValue(value)
                            buffer.reset()
                            state = "init"
                        }
                    }
                }
            }

            return message
        } catch (_: Exception) {
        }

        val offset = data.indexOfFirst { it == '{'.code.toByte() }

        return if (offset != -1) {
            try {
                val jsonBytes = data.copyOfRange(offset, data.size)
                val json = jsonBytes.toString(Charsets.UTF_8)
                val parsed = parseJsonToMap(json)
                val type = message.firstOrNull() as? String

                if (type != null) {
                    val isAlreadyWrapped = parsed.size == 1 && parsed.containsKey(type)

                    val final = if (isAlreadyWrapped) {
                        listOf(type, parsed[type]!!)
                    } else {
                        listOf(type, parsed)
                    }
                    final
                } else {
                    Logger.error(LogConfigSocketError) { "Cannot determine message type from partial data" }
                    emptyList()
                }
            } catch (e: Exception) {
                Logger.error(LogConfigSocketError) { "JSON fallback deserialization failed: ${e.message}" }
                emptyList()
            }
        } else {
            emptyList()
        }
    }
}



================================================================================
ðŸ“„ FICHIER : src\main\kotlin\server\protocol\PIOSerializer.kt
================================================================================

package server.protocol

import java.nio.ByteBuffer
import java.nio.ByteOrder

object PIOSerializer {
    fun serialize(message: List<Any>): ByteArray {
        val buffer = mutableListOf<Byte>()

        fun reverseBytes(bytes: ByteArray): ByteArray = bytes.reversedArray()

        fun writeTagWithLength(length: Int, shortPattern: Pattern, fullPattern: Pattern) {
            if (length in 0..63) {
                buffer.add((shortPattern.value or length).toByte())
            } else {
                val encoded = reverseBytes(ByteBuffer.allocate(4).order(ByteOrder.LITTLE_ENDIAN).putInt(length).array())
                val nonZero = encoded.indexOfFirst { it != 0.toByte() }.takeIf { it >= 0 } ?: 3
                val used = 4 - nonZero
                buffer.add((fullPattern.value or (used - 1)).toByte())
                buffer.addAll(encoded.drop(nonZero))
            }
        }

        fun writeLongPattern(value: Long, shortPattern: Pattern, longPattern: Pattern) {
            val encoded = reverseBytes(ByteBuffer.allocate(8).order(ByteOrder.LITTLE_ENDIAN).putLong(value).array())
            val nonZero = encoded.indexOfFirst { it != 0.toByte() }.takeIf { it >= 0 } ?: 7
            val used = 8 - nonZero
            val pattern = if (used > 4) longPattern else shortPattern
            val offset = if (used > 4) used - 5 else used - 1
            buffer.add((pattern.value or offset).toByte())
            buffer.addAll(encoded.drop(nonZero))
        }

        fun serializeValue(value: Any) {
            when (value) {
                is String -> {
                    val encoded = value.toByteArray(Charsets.UTF_8)
                    writeTagWithLength(encoded.size, Pattern.STRING_SHORT_PATTERN, Pattern.STRING_PATTERN)
                    buffer.addAll(encoded.toList())
                }

                is Boolean -> {
                    buffer.add(if (value) Pattern.BOOLEAN_TRUE_PATTERN.value.toByte() else Pattern.BOOLEAN_FALSE_PATTERN.value.toByte())
                }

                is Int -> {
                    writeTagWithLength(value, Pattern.UNSIGNED_INT_SHORT_PATTERN, Pattern.INT_PATTERN)
                }

                is Long -> {
                    writeLongPattern(value, Pattern.LONG_SHORT_PATTERN, Pattern.LONG_PATTERN)
                }

                is Float -> {
                    buffer.add(Pattern.DOUBLE_PATTERN.value.toByte())
                    buffer.addAll(
                        reverseBytes(
                            ByteBuffer.allocate(8).order(ByteOrder.LITTLE_ENDIAN).putDouble(value.toDouble()).array()
                        ).toList()
                    )
                }

                is Double -> {
                    buffer.add(Pattern.DOUBLE_PATTERN.value.toByte())
                    buffer.addAll(
                        reverseBytes(
                            ByteBuffer.allocate(8).order(ByteOrder.LITTLE_ENDIAN).putDouble(value).array()
                        ).toList()
                    )
                }

                is ByteArray -> {
                    writeTagWithLength(value.size, Pattern.BYTE_ARRAY_SHORT_PATTERN, Pattern.BYTE_ARRAY_PATTERN)
                    buffer.addAll(value.toList())
                }

                else -> throw IllegalArgumentException("Unsupported type: ${value::class}")
            }
        }

        serializeValue(message.size - 1)
        for (value in message) {
            serializeValue(value)
        }

        return buffer.toByteArray()
    }
}



================================================================================
ðŸ“„ FICHIER : src\main\kotlin\server\tasks\ServerTask.kt
================================================================================

package server.tasks

import server.core.Connection

/**
 * Represents a server-side task with a well-defined lifecycle.
 *
 * A task defines its timing, repetition, and behavior through [TaskConfig].
 * Each implementation should contain only the logic specific to that task type.
 *
 * Typically, tasks implement this interface as a reusable template,
 * allowing callers to run them easily without dealing with lower-level scheduling logic.
 *
 * [ServerTask] implementation should be able to provide `stopId`, a reproducible, deterministic identifier for the task.
 * The derived ID is used for referencing and cancelling tasks consistently across server components.
 * Typically it is derived from a combination of the player ID, [category], and [StopInput] instance (e.g., a `buildingId`).
 *
 * Example (register in GameServer.kt)
 * ```
 * context.taskDispatcher.registerStopId(
 *     category = TaskCategory.TimeUpdate,
 *     StopInputFactory = { BuildingStopInputeter() },
 *     deriveId = { playerId, category, _ ->
 *         // "TU-playerId123"
 *         "${category.code}-$playerId"
 *     }
 * )
 * ```
 *
 * ### Lifecycle Overview
 * A task may run once or repeatedly, depending on its configuration.
 *
 * **Non-repeatable task:**
 * ```
 * task.start()
 * â”œâ”€ onStart()
 * â”œâ”€ ...delay(startDelay) [optional]
 * â”œâ”€ execute()
 * â””â”€ onTaskComplete() / onCancelled()
 * ```
 *
 * **Repeatable task:**
 * ```
 * task.start()
 * â”œâ”€ onStart()
 * â”œâ”€ ...delay(startDelay) [optional]
 * â”œâ”€ repeat until cancelled, timeout, or maxRepeats reached:
 * â”‚   â”œâ”€ onIterationStart()
 * â”‚   â”œâ”€ execute()
 * â”‚   â”œâ”€ onIterationComplete()
 * â”‚   â””â”€ ...delay(repeatInterval) [optional]
 * â””â”€ onTaskComplete() / onCancelled()
 * ```
 *
 * Only [execute] must be implemented; all other lifecycle hooks are optional.
 * Each lifecycle callback receives a [Connection] instance, representing the player's connection this task belongs to.
 *
 * @property category  Logical grouping of this task or namespace for this task.
 * @property config    Defines timing, delay, and repetition rules for task execution.
 * @property scheduler Optional scheduler for this task.
 *                     Typically, when scheduling is complex, the [ServerTask] itself implements it.
 *
 * @param TaskInput The type of data required to execute this task.
 * @param StopInput The type of data used to identify and stop this task.
 *
 * @property taskInputBlock DSL block to produce [TaskInput] instance, to produce data needed to execute the task. **Make sure to set every variables here.**
 * @property stopInputBlock DSL block to produce [StopInput] instance, to produce data needed to cancel the task. **Make sure to set every variables here.**
 * @property createTaskInput Applies the [taskInputBlock] block to an empty [TaskInput].
 * @property stopInputBlock Applies the [stopInputBlock] block to an empty [StopInput].
 */
abstract class ServerTask<TaskInput : Any, StopInput : Any> {
    abstract val category: TaskCategory
    abstract val config: TaskConfig
    abstract val scheduler: TaskScheduler?

    abstract val taskInputBlock: TaskInput.() -> Unit
    abstract val stopInputBlock: StopInput.() -> Unit
    abstract fun createTaskInput(): TaskInput
    abstract fun createStopInput(): StopInput

    /**
     * Called once when the task is first scheduled.
     * Used for setup, initialization, or sending a "start" message to the client.
     */
    @InternalTaskAPI
    open suspend fun onStart(connection: Connection) = Unit

    /**
     * Main execution body of the task.
     * Called once or repeatedly depending on [config].
     */
    @InternalTaskAPI
    open suspend fun execute(connection: Connection) {
    }

    /**
     * Called before each execution cycle begins (only for repeatable tasks).
     * Useful for preparing per-iteration state or logging progress.
     */
    @InternalTaskAPI
    open suspend fun onIterationStart(connection: Connection) = Unit

    /**
     * Called after each execution cycle completes (only for repeatable tasks).
     * Useful for cleanup, progress tracking, or scheduling side effects.
     */
    @InternalTaskAPI
    open suspend fun onIterationComplete(connection: Connection) = Unit

    /**
     * Called once when the task finishes all scheduled iterations successfully.
     * For non-repeating tasks, this is invoked immediately after [execute].
     */
    @InternalTaskAPI
    open suspend fun onTaskComplete(connection: Connection) = Unit

    /**
     * Called when a completion is forced.
     *
     * This happens when the task is not yet finished (e.g., still repeating or its start delay has not yet elapsed),
     * but an external source forces the task to complete immediately.
     *
     * By default, it will just call [onTaskComplete] directly.
     * This makes it differ than cancelling the task, as it is not treated as an error or interruption,
     * and it skips to [onTaskComplete] rather than call the [onCancelled].
     *
     * [ServerTask] implementation can replace or add behaviors as needed.
     */
    @InternalTaskAPI
    open suspend fun onForceComplete(connection: Connection) {
        onTaskComplete(connection)
    }

    /**
     * Called if the task is stopped or cancelled before completing normally.
     * Use this to revert partial state or perform cleanup.
     *
     * @param reason The reason why the task was cancelled.
     *               `ServerTask` implementation may handle different cases as needed.
     */
    @InternalTaskAPI
    open suspend fun onCancelled(connection: Connection, reason: CancellationReason) = Unit
}

/**
 * Describe the reason a task is cancelled.
 */
enum class CancellationReason {
    /**
     * Cancelled explicitly by player or server.
     */
    MANUAL,

    /**
     * When a task has to be cancelled because it exceeded its timeout.
     */
    TIMEOUT,

    /**
     * Task failed due to server error.
     */
    ERROR
}



================================================================================
ðŸ“„ FICHIER : src\main\kotlin\server\tasks\ServerTaskDispatcher.kt
================================================================================

package server.tasks

import io.ktor.util.date.*
import kotlinx.coroutines.*
import server.core.Connection
import utils.LogConfigSocketError
import utils.LogSource
import utils.Logger
import kotlin.coroutines.cancellation.CancellationException
import kotlin.time.DurationUnit
import kotlin.time.toDuration

/**
 * Manages and dispatches task instances.
 *
 * This dispatcher is also a task scheduler (i.e., the default implementation of [TaskScheduler]).
 *
 * @property runningInstances Map of task IDs to currently running [TaskInstance]s.
 * @property stopIdProviders  Map of each [TaskCategory] to a function capable of deriving a task ID
 *                            from a `playerId`, [TaskCategory], and a generic [StopInput] type.
 *                            Every [ServerTask] implementation **must** call [registerStopId] (in GameServer.kt)
 *                            to register how the dispatcher should compute a task ID for that category when stopping tasks.
 * @property stopInputFactories Map of each [TaskCategory] to a factory function that
 *                              creates a new instance of its corresponding `StopInput` type.
 */
class ServerTaskDispatcher : TaskScheduler {
    private val runningInstances = mutableMapOf<String, TaskInstance>()

    private val stopIdProviders =
        mutableMapOf<TaskCategory, (playerId: String, category: TaskCategory, stopInput: Any) -> String>()

    private val stopInputFactories = mutableMapOf<TaskCategory, () -> Any>()

    /**
     * Registers a function that derives a task ID for a given task category.
     *
     * It always takes a `String` of [Connection.playerId] and a generic [StopInput] type.
     */
    @Suppress("UNCHECKED_CAST")
    fun <StopInput : Any> registerStopId(
        category: TaskCategory,
        stopInputFactory: () -> StopInput,
        deriveId: (playerId: String, category: TaskCategory, stopInput: StopInput) -> String
    ) {
        stopInputFactories[category] = stopInputFactory
        stopIdProviders[category] = { playerId, category, stopInput ->
            try {
                deriveId(playerId, category, stopInput as StopInput)
            } catch (e: ClassCastException) {
                val msg = buildString {
                    appendLine("[registerStopId] Type mismatch when deriving stop ID:")
                    appendLine("- Category: $category")
                    appendLine("- Most likely cause: duplicate registration in GameServer.kt for same category or wrong factory return type.")
                }

                throw IllegalStateException(msg, e)
            }
        }
    }

    /**
     * Run the selected [taskToRun] for the player's [Connection].
     */
    fun <TaskInput : Any, StopInput : Any> runTaskFor(
        connection: Connection,
        taskToRun: ServerTask<TaskInput, StopInput>,
    ) {
        val stopInput = taskToRun.createStopInput().apply(taskToRun.stopInputBlock)

        val deriveStopId = stopIdProviders[taskToRun.category]
            ?: error("stopIdProvider not registered for ${taskToRun.category.code} (register in GameServer.kt)")
        val taskId = deriveStopId(connection.playerId, taskToRun.category, stopInput)

        val job = connection.connectionScope.launch {
            try {
                Logger.info(LogSource.SOCKET) { "[runTask Hello] Task ${taskToRun.category.code} has been scheduled to run (waiting for startDelay) for playerId=${connection.playerId}, taskId=$taskId" }
                val scheduler = taskToRun.scheduler ?: this@ServerTaskDispatcher
                scheduler.schedule(connection, taskId, taskToRun)
            } catch (e: CancellationException) {
                when (e) {
                    is ForceCompleteException -> {
                        Logger.info(LogSource.SOCKET) { "[ForceCompleteException] Task '${taskToRun.category.code}' was forced to complete for playerId=${connection.playerId}, taskId=$taskId" }
                    }

                    is ManualCancellationException -> {
                        Logger.info(LogSource.SOCKET) { "[ManualCancellationException] Task '${taskToRun.category.code}' was manually cancelled for playerId=${connection.playerId}, taskId=$taskId" }
                    }

                    else -> {
                        Logger.warn(LogSource.SOCKET) { "[CancellationException] Task '${taskToRun.category.code}' was cancelled for playerId=${connection.playerId}, taskId=$taskId" }
                    }
                }
            } catch (e: Exception) {
                Logger.error(LogConfigSocketError) { "[runTask Exception] Error on task '${taskToRun.category.code}': $e for playerId=${connection.playerId}, taskId=$taskId" }
            } finally {
                Logger.info(LogSource.SOCKET) { "[runTask Goodbye] Task '${taskToRun.category.code}' no longer run for playerId=${connection.playerId}, taskId=$taskId" }
                runningInstances.remove(taskId)
            }
        }

        runningInstances[taskId] = TaskInstance(
            category = taskToRun.category,
            playerId = connection.playerId,
            config = taskToRun.config,
            job = job
        )
    }

    /**
     * Default implementation of [TaskScheduler].
     *
     * The process at how specifically task lifecycle is handled is documented in [ServerTask].
     */
    @OptIn(InternalTaskAPI::class)
    override suspend fun <TaskInput : Any, StopInput : Any> schedule(
        connection: Connection,
        taskId: String,
        task: ServerTask<TaskInput, StopInput>
    ) {
        val config = task.config
        val shouldRepeat = config.repeatInterval != null
        var iterationDone = 0
        val startTime = getTimeMillis().toDuration(DurationUnit.MILLISECONDS)

        try {
            task.onStart(connection)
            delay(config.startDelay)

            Logger.info("[runTask Working] Task '${task.category.code}' currently running for playerId=${connection.playerId}, taskId=$taskId")

            if (shouldRepeat) {
                while (currentCoroutineContext().isActive) {
                    // Check timeout
                    config.timeout?.let { timeout ->
                        val now = getTimeMillis().toDuration(DurationUnit.MILLISECONDS)
                        if (now - startTime >= timeout) {
                            task.onCancelled(connection, CancellationReason.TIMEOUT)
                            break
                        }
                    }

                    task.onIterationStart(connection)
                    task.execute(connection)
                    task.onIterationComplete(connection)

                    iterationDone++
                    // Check max repeat
                    config.maxRepeats?.let { max ->
                        if (iterationDone >= max) {
                            task.onTaskComplete(connection)
                            break
                        }
                    }

                    delay(config.repeatInterval)
                }
            } else {
                task.execute(connection)
                task.onTaskComplete(connection)
            }
        } catch (e: CancellationException) {
            when (e) {
                is ForceCompleteException -> task.onForceComplete(connection)

                is ManualCancellationException -> task.onCancelled(connection, CancellationReason.MANUAL)

                else -> {
                    task.onCancelled(connection, CancellationReason.ERROR)
                }
            }
            throw e
        } catch (e: Exception) {
            task.onCancelled(connection, CancellationReason.ERROR)
            throw e
        }
    }

    /**
     * Stop the task of [taskId] by cancelling the associated coroutine job.
     */
    private fun stopTask(taskId: String) {
        runningInstances.remove(taskId)?.job?.cancel()
    }

    /**
     * Stop the task with the given [Connection.playerId], [category], and [StopInput].
     */
    @Suppress("UNCHECKED_CAST")
    fun <StopInput : Any> stopTaskFor(
        connection: Connection,
        category: TaskCategory,
        forceComplete: Boolean = false,
        stopInputBlock: StopInput.() -> Unit = {}
    ) {
        val factory = stopInputFactories[category]
            ?: error("No stopInputFactory registered for $category (register in GameServer.kt)")

        try {
            val stopInput = (factory() as StopInput).apply(stopInputBlock)

            val deriveId = stopIdProviders[category]
                ?: error("No stopIdProvider registered for $category (register in GameServer.kt)")

            val taskId = deriveId(connection.playerId, category, stopInput)
            val instance = runningInstances.remove(taskId)

            if (instance == null) {
                Logger.warn(LogConfigSocketError) { "[stopTaskFor]: instance for taskId=$taskId is null." }
                return
            }

            val exception = if (forceComplete) {
                ForceCompleteException()
            } else {
                ManualCancellationException()
            }

            instance.job.cancel(exception)
        } catch (e: ClassCastException) {
            val msg = buildString {
                appendLine("[stopTaskFor] Type mismatch when casting factory stop ID:")
                appendLine("- Category: $category")
                appendLine("- Most likely cause: mismatch between registered StopInput in GameServer.kt and generic type used in stopTaskFor()")
            }

            throw IllegalStateException(msg, e)
        }
    }

    /**
     * Stop all tasks for the [playerId]
     */
    fun stopAllTasksForPlayer(playerId: String) {
        runningInstances
            .filterValues { it.playerId == playerId }
            .forEach { (taskId, _) -> stopTask(taskId) }
    }

    /**
     * Stop every running tasks instances in the server.
     */
    fun stopAllPushTasks() {
        runningInstances.forEach { (taskId, _) -> stopTask(taskId) }
    }

    fun shutdown() {
        stopAllPushTasks()
        runningInstances.clear()
        stopIdProviders.clear()
    }

}

data class TaskInstance(
    val category: TaskCategory,
    val playerId: String,
    val config: TaskConfig,
    val job: Job,
)

class ForceCompleteException : CancellationException("Force completion was requested")
class ManualCancellationException : CancellationException("Manual cancellation was done")



================================================================================
ðŸ“„ FICHIER : src\main\kotlin\server\tasks\TaskCategory.kt
================================================================================

package server.tasks

/**
 * Represents a category of tasks that correspond to implementations of [ServerTask].
 *
 * Each high-level category of tasks inherits from [TaskCategory], while subcategories
 * (specific task types within a category) inherit from their respective parent category.
 */
sealed interface TaskCategory {
    /**
     * Unique code to identify this task category, typically used to derive task ID.
     */
    val code: String

    object TimeUpdate : TaskCategory {
        override val code: String = "TU"
    }

    sealed interface Building : TaskCategory {
        object Create : Building {
            override val code: String = "BLD-CREATE"
        }

        object Repair : Building {
            override val code: String = "BLD-REPAIR"
        }

        object Upgrade : Building {
            override val code: String = "BLD-UPGRADE"
        }
    }

    sealed interface Mission : TaskCategory {
        object Return : Mission {
            override val code: String = "MIS-RETURN"
        }
    }

    sealed interface Task : TaskCategory {
        object JunkRemoval : Task {
            override val code: String = "TASK-JUNK"
        }
    }
}



================================================================================
ðŸ“„ FICHIER : src\main\kotlin\server\tasks\TaskConfig.kt
================================================================================

package server.tasks

import kotlin.time.Duration

/**
 * Configuration options for controlling task execution timing and repetition.
 *
 * @property startDelay The delay before the task starts its first execution.
 *                      Use `Duration.ZERO` for immediate execution.
 *
 * @property repeatInterval If set, the task will automatically repeat after each execution
 *                          with this interval. If null, the task runs only once.
 *
 * @property maxRepeats Maximum number of repetitions if [repeatInterval] is defined.
 *                      A null value means unlimited repetitions.
 *                      If the task repetition reached this limit, it will be considered as complete (call the `ServerTask.onComplete` hook)
 *
 * @property timeout Optional maximum lifetime of the task.
 *                   If the task runs longer than this duration, it will be automatically cancelled (call the `ServerTask.onCancelled` hook).
 *                   Can serve as a time-based alternative to [maxRepeats].
 *                   Useful as a safeguard against stalled coroutines (e.g., long I/O operations or unexpected hangs).
 *
 * Example:
 * ```
 * // Run once after 5 seconds
 * TaskConfig(startDelay = 5.seconds)
 *
 * // First run after 2 seconds, then every 10 seconds, for 3 times maximum
 * TaskConfig(startDelay = 2.seconds, repeatInterval = 10.seconds, maxRepeats = 3)
 * ```
 */
data class TaskConfig(
    val startDelay: Duration = Duration.ZERO,
    val repeatInterval: Duration? = null,
    val maxRepeats: Int? = null,
    val timeout: Duration? = null
)



================================================================================
ðŸ“„ FICHIER : src\main\kotlin\server\tasks\TaskScheduler.kt
================================================================================

package server.tasks

import server.core.Connection

/**
 * Represents a component that handles timing, repetition, and lifecycle of a task as defined by [TaskConfig].
 *
 * By default, scheduling is handled by [ServerTaskDispatcher].
 * However, individual [ServerTask] implementations may override this behavior
 * if they require custom scheduling logic or more complex timing control.
 */
interface TaskScheduler {
    suspend fun <TaskInput : Any, StopInput : Any> schedule(
        connection: Connection,
        taskId: String,
        task: ServerTask<TaskInput, StopInput>
    )
}

/**
 * [ServerTask] has lifecycle hooks (e.g., `onStart`, `onComplete`) which are intended to be used
 * by a [TaskScheduler] and the subclass itself implementing the methods.
 *
 * This annotation gives a warning for caller that tries to call lifecycle hooks directly from a [ServerTask] implementation.
 *
 * Don't do something like:
 * ```
 * BuildingTask.BuildingCreate {
 *     buildingId = "bld123"
 * }.execute()
 * ```
 */
@RequiresOptIn(
    level = RequiresOptIn.Level.ERROR,
    message = "This API is only intended to be called by task scheduler."
)
@Retention(AnnotationRetention.BINARY)
annotation class InternalTaskAPI



================================================================================
ðŸ“„ FICHIER : src\main\kotlin\server\tasks\impl\BuildingTask.kt
================================================================================

package server.tasks.impl

import context.ServerContext
import context.requirePlayerContext
import core.model.game.data.copy
import core.model.game.data.level
import core.model.game.data.upgrade
import core.model.game.data.repair
import server.core.Connection
import server.messaging.NetworkMessage
import server.tasks.*
import utils.LogConfigSocketError
import utils.Logger
import kotlin.time.Duration

class BuildingCreateTask(
    override val taskInputBlock: BuildingCreateParameter.() -> Unit,
    override val stopInputBlock: BuildingCreateStopParameter.() -> Unit
) : ServerTask<BuildingCreateParameter, BuildingCreateStopParameter>() {
    private val taskInput: BuildingCreateParameter by lazy {
        createTaskInput().apply(taskInputBlock)
    }

    override val category = TaskCategory.Building.Create
    override val config = TaskConfig(
        startDelay = taskInput.buildDuration
    )
    override val scheduler: TaskScheduler? = null

    override fun createTaskInput(): BuildingCreateParameter = BuildingCreateParameter()
    override fun createStopInput(): BuildingCreateStopParameter = BuildingCreateStopParameter()

    @InternalTaskAPI
    override suspend fun execute(connection: Connection) {
        val serverContext = taskInput.serverContext
        if (serverContext != null) {
            val compoundService = serverContext.requirePlayerContext(connection.playerId).services.compound
            val building = compoundService.getBuilding(taskInput.buildingId)
            if (building != null) {
                val upgradeData = building.upgrade?.data
                val newLevel = (upgradeData?.get("level") as? Int) ?: (building.level + 1)
                val updateResult = compoundService.updateBuilding(taskInput.buildingId) { bld ->
                    bld.copy(level = newLevel, upgrade = null)
                }
                if (updateResult.isFailure) {
                    Logger.error(LogConfigSocketError) {
                        "Failed to finalize building upgrade for bldId=${taskInput.buildingId}, playerId=${connection.playerId}: ${updateResult.exceptionOrNull()?.message}"
                    }
                }
            }
        }
        connection.sendMessage(NetworkMessage.BUILDING_COMPLETE, taskInput.buildingId)
    }
}

data class BuildingCreateParameter(
    var buildingId: String = "",
    var buildDuration: Duration = Duration.ZERO,
    var serverContext: ServerContext? = null
)

data class BuildingCreateStopParameter(
    var buildingId: String = "",
)

class BuildingRepairTask(
    override val taskInputBlock: BuildingRepairParameter.() -> Unit,
    override val stopInputBlock: BuildingRepairStopParameter.() -> Unit
) : ServerTask<BuildingRepairParameter, BuildingRepairStopParameter>() {
    private val taskInput: BuildingRepairParameter by lazy {
        createTaskInput().apply(taskInputBlock)
    }

    override val category = TaskCategory.Building.Repair
    override val config = TaskConfig(
        startDelay = taskInput.repairDuration
    )
    override val scheduler: TaskScheduler? = null

    override fun createTaskInput(): BuildingRepairParameter = BuildingRepairParameter()
    override fun createStopInput(): BuildingRepairStopParameter = BuildingRepairStopParameter()

    @InternalTaskAPI
    override suspend fun execute(connection: Connection) {
        val serverContext = taskInput.serverContext
        if (serverContext != null) {
            val compoundService = serverContext.requirePlayerContext(connection.playerId).services.compound
            val building = compoundService.getBuilding(taskInput.buildingId)
            if (building != null) {
                val updateResult = compoundService.updateBuilding(taskInput.buildingId) { bld ->
                    bld.copy(repair = null, destroyed = false)
                }
                if (updateResult.isFailure) {
                    Logger.error(LogConfigSocketError) {
                        "Failed to finalize building repair for bldId=${taskInput.buildingId}, playerId=${connection.playerId}: ${updateResult.exceptionOrNull()?.message}"
                    }
                }
            }
        }
        connection.sendMessage(NetworkMessage.BUILDING_COMPLETE, taskInput.buildingId)
    }
}

data class BuildingRepairParameter(
    var buildingId: String = "",
    var repairDuration: Duration = Duration.ZERO,
    var serverContext: ServerContext? = null
)

data class BuildingRepairStopParameter(
    var buildingId: String = "",
)



================================================================================
ðŸ“„ FICHIER : src\main\kotlin\server\tasks\impl\JunkRemovalTask.kt
================================================================================

package server.tasks.impl

import core.compound.CompoundService
import server.core.Connection
import server.messaging.NetworkMessage
import server.tasks.*
import kotlin.time.Duration

class JunkRemovalTask(
    private val compoundService: CompoundService,
    override val taskInputBlock: JunkRemovalParameter.() -> Unit,
    override val stopInputBlock: JunkRemovalStopParameter.() -> Unit
) : ServerTask<JunkRemovalParameter, JunkRemovalStopParameter>() {
    private val taskInput: JunkRemovalParameter by lazy {
        createTaskInput().apply(taskInputBlock)
    }

    override val category = TaskCategory.Task.JunkRemoval
    override val config = TaskConfig(
        startDelay = taskInput.removalDuration
    )
    override val scheduler: TaskScheduler? = null

    override fun createTaskInput(): JunkRemovalParameter = JunkRemovalParameter()
    override fun createStopInput(): JunkRemovalStopParameter = JunkRemovalStopParameter()

    @InternalTaskAPI
    override suspend fun execute(connection: Connection) {
        compoundService.deleteBuilding(taskInput.buildingId)
        connection.sendMessage(NetworkMessage.TASK_COMPLETE, taskInput.taskId)
    }
}

data class JunkRemovalParameter(
    var taskId: String = "",
    var buildingId: String = "",
    var removalDuration: Duration = Duration.ZERO
)

data class JunkRemovalStopParameter(
    var taskId: String = "",
)



================================================================================
ðŸ“„ FICHIER : src\main\kotlin\server\tasks\impl\MissionTask.kt
================================================================================

package dev.deadzone.socket.tasks.impl

import server.core.Connection
import server.messaging.NetworkMessage
import server.tasks.InternalTaskAPI
import server.tasks.ServerTask
import server.tasks.TaskCategory
import server.tasks.TaskConfig
import server.tasks.TaskScheduler
import kotlin.time.Duration

/**
 * Task for creating and upgrading building with or without cash option.
 *
 * This is used for:
 * - MISSION_RETURN_COMPLETE (used in MISSION_END)
 */
class MissionReturnTask(
    override val taskInputBlock: MissionReturnParameter.() -> Unit,
    override val stopInputBlock: MissionReturnStopParameter.() -> Unit
) : ServerTask<MissionReturnParameter, MissionReturnStopParameter>() {
    private val taskInput: MissionReturnParameter by lazy {
        createTaskInput().apply(taskInputBlock)
    }

    override val category = TaskCategory.Mission.Return
    override val config = TaskConfig(
        startDelay = taskInput.returnTime
    )
    override val scheduler: TaskScheduler? = null

    override fun createTaskInput(): MissionReturnParameter = MissionReturnParameter()
    override fun createStopInput(): MissionReturnStopParameter = MissionReturnStopParameter()

    /**
     * Main execution: waits until `buildDuration` then run `execute()`,
     * which will send BUILDING_COMPLETE message to client.
     */
    @InternalTaskAPI
    override suspend fun execute(connection: Connection) {
        connection.sendMessage(NetworkMessage.MISSION_RETURN_COMPLETE, taskInput.missionId)
    }
}

data class MissionReturnParameter(
    var missionId: String = "",
    var returnTime: Duration = Duration.ZERO
)

data class MissionReturnStopParameter(
    var missionId: String = ""
)


================================================================================
ðŸ“„ FICHIER : src\main\kotlin\server\tasks\impl\TimeUpdateTask.kt
================================================================================

package server.tasks.impl

import server.core.Connection
import server.messaging.NetworkMessage
import server.tasks.*
import utils.Time
import kotlin.time.Duration.Companion.seconds

/**
 * Sends a time update ('tu') message to client.
 *
 * The game doesn't maintain its own time; instead, it relies on the server for timekeeping.
 */
class TimeUpdateTask() : ServerTask<Unit, Unit>() {
    override val category: TaskCategory = TaskCategory.TimeUpdate
    override val config: TaskConfig = TaskConfig(repeatInterval = 1.seconds)
    override val scheduler: TaskScheduler? = null

    override val taskInputBlock: (Unit) -> Unit = { }
    override val stopInputBlock: (Unit) -> Unit = { }
    override fun createTaskInput() = Unit
    override fun createStopInput() = Unit

    @InternalTaskAPI
    override suspend fun execute(connection: Connection) {
        connection.sendMessage(NetworkMessage.TIME_UPDATE, Time.now(), enableLogging = false)
    }
}



================================================================================
ðŸ“„ FICHIER : src\main\kotlin\user\PlayerAccountRepository.kt
================================================================================

package user

import user.model.UserProfile
import data.collection.PlayerAccount

/**
 * Player account repository, analogous to game service's repo
 */
interface PlayerAccountRepository {
    suspend fun doesUserExist(username: String): Result<Boolean>

    suspend fun getUserDocByUsername(username: String): Result<PlayerAccount?>

    suspend fun getUserDocByPlayerId(playerId: String): Result<PlayerAccount?>

    suspend fun getPlayerIdOfUsername(username: String): Result<String?>

    suspend fun getProfileOfPlayerId(playerId: String): Result<UserProfile?>

    suspend fun updatePlayerAccount(playerId: String, account: PlayerAccount): Result<Unit>

    suspend fun updateLastLogin(playerId: String, lastLogin: Long): Result<Unit>

    /**
     * Verify credentials of the given username and password
     *
     * @return playerId for the corresponding username if success
     */
    suspend fun verifyCredentials(username: String, password: String): Result<String?>
}



================================================================================
ðŸ“„ FICHIER : src\main\kotlin\user\PlayerAccountRepositoryMaria.kt
================================================================================

package user

import com.toxicbakery.bcrypt.Bcrypt
import data.collection.PlayerAccount
import data.db.PlayerAccounts
import data.db.suspendedTransactionResult
import kotlinx.serialization.json.Json
import org.jetbrains.exposed.sql.Database
import org.jetbrains.exposed.sql.selectAll
import org.jetbrains.exposed.sql.update
import user.model.UserProfile
import utils.JSON
import utils.Logger
import kotlin.io.encoding.Base64

class PlayerAccountRepositoryMaria(private val database: Database, private val json: Json) : PlayerAccountRepository {
    override suspend fun verifyCredentials(username: String, password: String): Result<String?> {
        return database.suspendedTransactionResult {
            val row = PlayerAccounts.selectAll()
                .where { PlayerAccounts.displayName eq username }
                .singleOrNull()
            if (row == null) {
                Logger.info { "No account found for username=$username" }
                return@suspendedTransactionResult null
            }
            val hashedPassword = row[PlayerAccounts.hashedPassword]
            val decodedHash = Base64.decode(hashedPassword)
            if (Bcrypt.verify(password, decodedHash)) {
                row[PlayerAccounts.playerId]
            } else {
                Logger.info { "Password verification failed for username=$username" }
                null
            }
        }
    }

    override suspend fun doesUserExist(username: String): Result<Boolean> {
        return database.suspendedTransactionResult {
            PlayerAccounts.selectAll()
                .where { PlayerAccounts.displayName eq username }
                .count() > 0
        }
    }

    override suspend fun getProfileOfPlayerId(playerId: String): Result<UserProfile?> {
        return database.suspendedTransactionResult {
            PlayerAccounts.selectAll()
                .where { PlayerAccounts.playerId eq playerId }
                .singleOrNull()?.let { row ->
                    UserProfile(
                        playerId = row[PlayerAccounts.playerId],
                        email = row[PlayerAccounts.email],
                        displayName = row[PlayerAccounts.displayName],
                        avatarUrl = row[PlayerAccounts.avatarUrl],
                        createdAt = row[PlayerAccounts.createdAt],
                        lastLogin = row[PlayerAccounts.lastLogin],
                        countryCode = row[PlayerAccounts.countryCode],
                        friends = emptySet(),
                        enemies = emptySet()
                    )
                }
        }
    }

    override suspend fun getUserDocByUsername(username: String): Result<PlayerAccount?> {
        return database.suspendedTransactionResult {
            PlayerAccounts.selectAll()
                .where { PlayerAccounts.displayName eq username }
                .singleOrNull()?.let { mapToPlayerAccount(it) }
        }
    }

    override suspend fun getUserDocByPlayerId(playerId: String): Result<PlayerAccount?> {
        return database.suspendedTransactionResult {
            PlayerAccounts.selectAll()
                .where { PlayerAccounts.playerId eq playerId }
                .singleOrNull()?.let { mapToPlayerAccount(it) }
        }
    }

    private fun mapToPlayerAccount(row: org.jetbrains.exposed.sql.ResultRow) = PlayerAccount(
        playerId = row[PlayerAccounts.playerId],
        hashedPassword = row[PlayerAccounts.hashedPassword],
        email = row[PlayerAccounts.email],
        displayName = row[PlayerAccounts.displayName],
        avatarUrl = row[PlayerAccounts.avatarUrl],
        createdAt = row[PlayerAccounts.createdAt],
        lastLogin = row[PlayerAccounts.lastLogin],
        countryCode = row[PlayerAccounts.countryCode],
        serverMetadata = JSON.decode(row[PlayerAccounts.serverMetadataJson])
    )

    override suspend fun getPlayerIdOfUsername(username: String): Result<String?> {
        return database.suspendedTransactionResult {
            PlayerAccounts.selectAll()
                .where { PlayerAccounts.displayName eq username }
                .singleOrNull()?.let { row ->
                    row[PlayerAccounts.playerId]
                }
        }
    }

    override suspend fun updatePlayerAccount(playerId: String, account: PlayerAccount): Result<Unit> {
        return database.suspendedTransactionResult {
            val rowsUpdated = PlayerAccounts.update({ PlayerAccounts.playerId eq playerId }) {
                it[hashedPassword] = account.hashedPassword
                it[email] = account.email
                it[displayName] = account.displayName
                it[avatarUrl] = account.avatarUrl
                it[createdAt] = account.createdAt
                it[lastLogin] = account.lastLogin
                it[countryCode] = account.countryCode
                it[serverMetadataJson] = JSON.encode(account.serverMetadata)
            }
            if (rowsUpdated == 0) {
                throw IllegalStateException("Failed to update player account for playerId=$playerId")
            }
        }
    }

    override suspend fun updateLastLogin(playerId: String, lastLogin: Long): Result<Unit> {
        return database.suspendedTransactionResult {
            val rowsUpdated = PlayerAccounts.update({ PlayerAccounts.playerId eq playerId }) {
                it[PlayerAccounts.lastLogin] = lastLogin
            }
            if (rowsUpdated == 0) {
                throw IllegalStateException("Failed to update last login for playerId=$playerId")
            }
        }
    }
}



================================================================================
ðŸ“„ FICHIER : src\main\kotlin\user\auth\AuthProvider.kt
================================================================================

package user.auth

import user.model.PlayerSession

interface AuthProvider {
    /**
     * Register a new account with [username] and [password].
     *
     * @return [PlayerSession] of the newly created account for further authentication.
     */
    suspend fun register(username: String, password: String): PlayerSession

    /**
     * Login with [username] and [password].
     *
     * @return [PlayerSession] which is used for further authentication, null if login is failed.
     */
    suspend fun login(username: String, password: String): PlayerSession?

    /**
     * Login with admin account, will always succeed.
     */
    suspend fun adminLogin(): PlayerSession?

    /**
     * Check whether a user with [username] exists.
     */
    suspend fun doesUserExist(username: String): Boolean
}



================================================================================
ðŸ“„ FICHIER : src\main\kotlin\user\auth\SessionManager.kt
================================================================================

package user.auth

import user.model.PlayerSession
import core.data.AdminData
import utils.UUID
import io.ktor.util.date.getTimeMillis
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.Job
import kotlinx.coroutines.delay
import kotlinx.coroutines.isActive
import kotlinx.coroutines.launch
import java.util.concurrent.ConcurrentHashMap

/**
 * Manages authentication sessions between web login and game client.
 *
 * - After a successful website login, this class issues a session token for the player.
 * - The client uses this token for API requests.
 * - On API requests, this class verifies if the token is valid and unexpired.
 * - Token will be refreshed upon successful verification.
 * - The client website makes API requests every 50 minutes to refresh the token.
 * This ensures that the token remains valid, even when the game is not actively making API requests.
 * - Session refreshes is limited to 6 hours. This means player will not be able to make API requests after 6 hours online.
 */
class SessionManager {
    private val sessions = ConcurrentHashMap<String, PlayerSession>()
    private val CLEANUP_INTERVAL_MS = 5 * 60 * 1000L
    private val cleanupJob = Job()
    private val SESSION_DURATION_MS = 1 * 60 * 60 * 1000L
    private val SESSION_LIFETIME_MS = 6 * 60 * 60 * 1000L
    private val scope = CoroutineScope(Dispatchers.IO + cleanupJob)

    init {
        scope.launch {
            while (isActive) {
                cleanupExpiredSessions()
                delay(CLEANUP_INTERVAL_MS)
            }
        }
    }

    fun create(playerId: String): PlayerSession {
        val now = getTimeMillis()

        val token = if (playerId == AdminData.PLAYER_ID) {
            AdminData.TOKEN
        } else {
            UUID.new()
        }

        val session = PlayerSession(
            playerId = playerId,
            token = token,
            issuedAt = now,
            expiresAt = now + SESSION_DURATION_MS,
            lifetime = SESSION_LIFETIME_MS
        )

        sessions[token] = session
        return session
    }

    fun verify(token: String): Boolean {
        val session = sessions[token] ?: return false
        val now = getTimeMillis()

        if (now >= session.expiresAt) {
            sessions.remove(token)
            return false
        }

        return true
    }

    fun refresh(token: String): Boolean {
        val session = sessions[token] ?: return false
        val now = getTimeMillis()

        val lifetime = now - session.issuedAt
        if (lifetime > SESSION_LIFETIME_MS) {
            sessions.remove(token)
            return false
        }

        session.expiresAt = now + SESSION_DURATION_MS
        return true
    }

    fun getPlayerId(token: String): String? {
        return sessions[token]?.takeIf { getTimeMillis() < it.expiresAt }?.playerId
    }

    fun cleanupExpiredSessions() {
        val now = getTimeMillis()
        val expiredKeys = sessions.filterValues { it.expiresAt <= now }.keys
        expiredKeys.forEach { sessions.remove(it) }
    }

    fun shutdown() {
        sessions.clear()
        cleanupJob.cancel()
    }
}



================================================================================
ðŸ“„ FICHIER : src\main\kotlin\user\auth\WebsiteAuthProvider.kt
================================================================================

package user.auth

import user.model.PlayerSession
import core.data.AdminData
import data.db.BigDB
import user.PlayerAccountRepository
import utils.LogConfigAPIError
import utils.Logger

class WebsiteAuthProvider(
    private val db: BigDB,
    private val playerAccountRepository: PlayerAccountRepository,
    private val sessionManager: SessionManager
) : AuthProvider {
    override suspend fun register(username: String, password: String): PlayerSession {
        val pid = db.createUser(username, password)
        return sessionManager.create(playerId = pid)
    }

    override suspend fun login(username: String, password: String): PlayerSession? {
        val result = playerAccountRepository.verifyCredentials(username, password)
        result.onFailure {
            Logger.error(LogConfigAPIError) { "Failure on verifyCredentials for username=$username: ${it.message}" }
            return null
        }
        val pid = result.getOrThrow()
        return if (pid != null) {
            sessionManager.create(pid)
        } else {
            null
        }
    }

    override suspend fun adminLogin(): PlayerSession {
        return sessionManager.create(AdminData.PLAYER_ID)
    }

    override suspend fun doesUserExist(username: String): Boolean {
        val result = playerAccountRepository.doesUserExist(username)
        result.onFailure {
            Logger.error(LogConfigAPIError) { "Failure on doesUserExist for username=$username: ${it.message}" }
        }
        val doesExist = requireNotNull(result.getOrThrow()) {
            "doesUserExist succeed but returned boolean is null"
        }
        return doesExist
    }
}


================================================================================
ðŸ“„ FICHIER : src\main\kotlin\user\model\PlayerSession.kt
================================================================================

package user.model

/**
 * Representation of a player's authentication session.
 *
 * This session is issued during website login and included in API 13 (Authenticate)
 * and API 601 (SocialRefresh) responses.
 *
 * When the game client connects to the game socket using a `playerId`,
 * the server must verify that a valid session with a matching token exists.
 *
 * @property playerId The internal ID, used for linking session to [data.collection.PlayerAccount].
 * @property token A unique prove for authentication; currently not much used.
 * @property issuedAt Epoch millis when this session was created.
 * @property expiresAt Epoch millis when this session is no longer valid.
 */
data class PlayerSession(
    val playerId: String,
    val token: String,
    val issuedAt: Long,
    var expiresAt: Long,
    var lifetime: Long,
)



================================================================================
ðŸ“„ FICHIER : src\main\kotlin\user\model\ServerMetadata.kt
================================================================================

package user.model

import kotlinx.serialization.Serializable

/**
 * Extra data for server. This is unused, but prepared just in case it is needed.
 *
 * May include cheat tracking or activity analysis here.
 */
@Serializable
data class ServerMetadata(
    val notes: String? = null,
    val flags: Map<String, Boolean> = emptyMap(),
    val extra: Map<String, String> = emptyMap(),
)



================================================================================
ðŸ“„ FICHIER : src\main\kotlin\user\model\UserProfile.kt
================================================================================

package user.model

import kotlinx.serialization.Serializable

@Serializable
data class UserProfile(
    val playerId: String,
    val email: String = "",
    val displayName: String,
    val avatarUrl: String,
    val createdAt: Long,
    val lastLogin: Long,
    val countryCode: String? = null,
    val friends: Set<UserProfile> = emptySet(),
    val enemies: Set<UserProfile> = emptySet(),
)


================================================================================
ðŸ“„ FICHIER : src\main\kotlin\utils\AnsiColors.kt
================================================================================

package dev.deadzone.utils

/**
 * Ansi colors (256) constants to style console.
 */
@Suppress("unused", "ConstPropertyName")
object AnsiColors {
    const val Reset = "\u001B[0m"

    const val BlackText = "\u001B[38;5;16m"
    const val WhiteText = "\u001B[38;5;255m"

    const val Success = "\u001B[48;5;120m"
    const val Debug = "\u001B[48;5;223m"
    const val Info = "\u001B[48;5;153m"
    const val Warn = "\u001B[48;5;221m"
    const val Error = "\u001B[48;5;203m"

    fun fg(n: Int) = "\u001B[38;5;${n}m"
    fun bg(n: Int) = "\u001B[48;5;${n}m"
}



================================================================================
ðŸ“„ FICHIER : src\main\kotlin\utils\AnyMapSerializer.kt
================================================================================

package dev.deadzone.utils

import kotlinx.serialization.KSerializer
import kotlinx.serialization.builtins.MapSerializer
import kotlinx.serialization.builtins.serializer
import kotlinx.serialization.descriptors.SerialDescriptor
import kotlinx.serialization.encoding.Decoder
import kotlinx.serialization.encoding.Encoder
import kotlinx.serialization.json.JsonArray
import kotlinx.serialization.json.JsonDecoder
import kotlinx.serialization.json.JsonElement
import kotlinx.serialization.json.JsonEncoder
import kotlinx.serialization.json.JsonObject
import kotlinx.serialization.json.JsonPrimitive
import kotlinx.serialization.json.jsonObject

object AnyMapSerializer : KSerializer<Map<String, Any>> {
    override val descriptor: SerialDescriptor =
        MapSerializer(String.serializer(), JsonElement.serializer()).descriptor

    @Suppress("UNCHECKED_CAST")
    override fun serialize(encoder: Encoder, value: Map<String, Any>) {
        val jsonEncoder = encoder as? JsonEncoder
            ?: error("This serializer only works with JSON")
        val converted = value.mapValues { (_, v) ->
            when (v) {
                is JsonElement -> v
                is String -> JsonPrimitive(v)
                is Number -> JsonPrimitive(v)
                is Boolean -> JsonPrimitive(v)
                is Map<*, *> -> JsonObject((v as Map<String, Any>).mapValues { JsonPrimitive(it.value.toString()) })
                is List<*> -> JsonArray(v.map { JsonPrimitive(it.toString()) })
                else -> JsonPrimitive(v.toString())
            }
        }
        jsonEncoder.encodeJsonElement(JsonObject(converted))
    }

    override fun deserialize(decoder: Decoder): Map<String, Any> {
        val jsonDecoder = decoder as? JsonDecoder
            ?: error("This serializer only works with JSON")
        val obj = jsonDecoder.decodeJsonElement().jsonObject
        return obj.mapValues { it.value }
    }
}


================================================================================
ðŸ“„ FICHIER : src\main\kotlin\utils\ByteArrayUtils.kt
================================================================================

package utils

fun ByteArray.sanitizedString(max: Int = 512, placeholder: Char = '.'): String {
    val decoded = String(this, Charsets.UTF_8)
    val sanitized = decoded.map { ch ->
        if (ch.isISOControl() && ch != '\n' && ch != '\r' && ch != '\t') placeholder
        else if (!ch.isDefined() || !ch.isLetterOrDigit() && ch !in setOf(
                ' ', '.', ',', ':', ';', '-', '_',
                '{', '}', '[', ']', '(', ')', '"',
                '\'', '/', '\\', '?', '=', '+', '*',
                '%', '&', '|', '<', '>', '!', '@',
                '#', '$', '^', '~'
            )
        ) placeholder
        else ch
    }.joinToString("")
    return sanitized.take(max) + if (sanitized.length > max) "..." else ""
}



================================================================================
ðŸ“„ FICHIER : src\main\kotlin\utils\Emoji.kt
================================================================================

package utils

/**
 * Emoji constants where each uses unicode character. Source: https://emojidb.org
 *
 * Use these constants to ensure that emojis are shown correctly everywhere.
 */
@Suppress("unused", "ConstPropertyName")
object Emoji {
    const val Red = "\uD83D\uDD34"              // ðŸ”´
    const val Orange = "\uD83D\uDFE0"           // ðŸŸ 
    const val Yellow = "\uD83D\uDFE1"           // ðŸŸ¡
    const val Green = "\uD83D\uDFE2"            // ðŸŸ¢
    const val Blue = "\uD83D\uDD35"             // ðŸ”µ
    const val Debug = "\uD83D\uDD0E"            // ðŸ”Ž
    const val Info = "â„¹\uFE0F"                 // â„¹ï¸
    const val Warn = "âš \uFE0F"                 // âš ï¸
    const val Error = "âŒ"                      // âŒ
    const val Party = "\uD83C\uDF89"            // ðŸŽ‰
    const val Satellite = "\uD83D\uDCE1"        // ðŸ“¡
    const val Internet = "\uD83C\uDF10"         // ðŸŒ
    const val Rocket = "\uD83D\uDE80"           // ðŸš€
    const val Database = "\uD83D\uDDC4\uFE0F"   // ðŸ—„ï¸
    const val Gaming = "\uD83D\uDD79\uFE0F"     // ðŸ•¹ï¸
    const val Save = "\uD83D\uDCBE"             // ðŸ’¾
    const val Phone = "\uD83D\uDCF1"            // ðŸ“±
}



================================================================================
ðŸ“„ FICHIER : src\main\kotlin\utils\Json.kt
================================================================================

@file:Suppress("UNCHECKED_CAST")

package utils

import kotlinx.serialization.DeserializationStrategy
import kotlinx.serialization.SerializationStrategy
import kotlinx.serialization.json.Json
import kotlinx.serialization.json.JsonArray
import kotlinx.serialization.json.JsonElement
import kotlinx.serialization.json.JsonNull
import kotlinx.serialization.json.JsonObject
import kotlinx.serialization.json.JsonPrimitive
import kotlinx.serialization.json.boolean
import kotlinx.serialization.json.booleanOrNull
import kotlinx.serialization.json.buildJsonArray
import kotlinx.serialization.json.buildJsonObject
import kotlinx.serialization.json.double
import kotlinx.serialization.json.doubleOrNull
import kotlinx.serialization.json.int
import kotlinx.serialization.json.intOrNull
import kotlinx.serialization.json.long
import kotlinx.serialization.json.longOrNull
import kotlin.collections.map
import kotlin.collections.mapValues

/**
 * Preset JSON serialization and deserialization.
 */
object JSON {
    lateinit var json: Json

    fun initialize(json: Json) {
        this.json = json
    }

    inline fun <reified T> encode(value: T): String {
        return json.encodeToString<T>(value)
    }

    inline fun <reified T> encode(serializer: SerializationStrategy<T>, value: T): String {
        return json.encodeToString(serializer, value)
    }

    inline fun <reified T> decode(value: String): T {
        return json.decodeFromString<T>(value)
    }

    inline fun <reified T> decode(deserializer: DeserializationStrategy<T>, value: String): T {
        return json.decodeFromString(deserializer, value)
    }
}

fun parseJsonToMap(json: String): Map<String, Any?> {
    return try {
        val parsed = JSON.decode<JsonObject>(json)
        parsed.mapValues { (_, v) -> parseJsonElement(v) }
    } catch (_: Exception) {
        emptyMap()
    }
}

fun parseJsonElement(el: JsonElement): Any = when (el) {
    is JsonPrimitive -> {
        when {
            el.isString -> el.content
            el.booleanOrNull != null -> el.boolean
            el.intOrNull != null -> el.int
            el.longOrNull != null -> el.long
            el.doubleOrNull != null -> el.double
            else -> el.content
        }
    }

    is JsonObject -> el.mapValues { parseJsonElement(it.value) }
    is JsonArray -> el.map { parseJsonElement(it) }
}

fun Map<String, *>?.toJsonElement(): JsonObject = buildJsonObject {
    this@toJsonElement?.forEach { (key, value) ->
        put(key, value.toJsonValue())
    }
}

fun Any?.toJsonValue(): JsonElement = when (this) {
    null -> JsonNull
    is String -> JsonPrimitive(this)
    is Number -> JsonPrimitive(this)
    is Boolean -> JsonPrimitive(this)
    is Map<*, *> -> {
        // Keys must be strings for JSON
        (this as? Map<String, *>)?.toJsonElement()
            ?: error("Map keys must be strings: $this")
    }
    is Iterable<*> -> buildJsonArray { this@toJsonValue.forEach { add(it.toJsonValue()) } }
    else -> JsonPrimitive(this.toString()) // fallback â€” stores as string
}



================================================================================
ðŸ“„ FICHIER : src\main\kotlin\utils\Logger.kt
================================================================================

package utils

import dev.deadzone.utils.AnsiColors
import io.ktor.server.routing.*
import io.ktor.util.date.*
import java.io.File
import java.io.FileDescriptor
import java.io.FileOutputStream
import java.io.PrintStream
import java.text.SimpleDateFormat

fun RoutingContext.logInput(txt: Any?, logFull: Boolean = false, disableLogging: Boolean = false) {
    if (!disableLogging) {
        Logger.info(LogSource.API, logFull = logFull) { "Received [API ${call.parameters["path"]}]: $txt" }
    }
}

fun RoutingContext.logOutput(txt: ByteArray?, logFull: Boolean = false, disableLogging: Boolean = false) {
    if (!disableLogging) {
        Logger.info(
            LogSource.API,
            logFull = logFull
        ) { "Sent [API ${call.parameters["path"]}]: ${txt?.decodeToString()}" }
    }
}

object Logger {
    private val logFileMap = mapOf(
        LogFile.CLIENT_WRITE_ERROR to File("logs/client_write_error-1.log"),
        LogFile.ASSETS_ERROR to File("logs/assets_error-1.log"),
        LogFile.API_SERVER_ERROR to File("logs/api_server_error-1.log"),
        LogFile.SOCKET_SERVER_ERROR to File("logs/socket_server_error-1.log"),
    ).also { File("logs").mkdirs() }

    private var level: LogLevel = LogLevel.DEBUG
    private var colorfulLog = true
    private const val MAX_LOG_LENGTH = 500
    private const val MAX_LOG_FILE_SIZE = 5 * 1024 * 1024
    private const val MAX_LOG_ROTATES = 5
    private val dateFormatter = SimpleDateFormat("yyyy-MM-dd HH:mm:ss")

    fun success(msg: String) = success { msg }
    fun success(config: LogConfig, forceLogFull: Boolean? = null, msg: () -> String) =
        success(config.src, config.targets, forceLogFull ?: config.logFull, msg)

    fun success(
        src: LogSource = LogSource.SOCKET,
        targets: Set<LogTarget> = setOf(LogTarget.PRINT),
        logFull: Boolean = false,
        msg: () -> String
    ) = log(src, targets, LogLevel.SUCCESS, msg, logFull)

    fun debug(msg: String) = debug { msg }
    fun debug(config: LogConfig, forceLogFull: Boolean? = null, msg: () -> String) =
        debug(config.src, config.targets, forceLogFull ?: config.logFull, msg)

    fun debug(
        src: LogSource = LogSource.SOCKET,
        targets: Set<LogTarget> = setOf(LogTarget.PRINT),
        logFull: Boolean = true,
        msg: () -> String
    ) = log(src, targets, LogLevel.DEBUG, msg, logFull)

    fun info(msg: String) = info { msg }
    fun info(config: LogConfig, forceLogFull: Boolean? = null, msg: () -> String) =
        info(config.src, config.targets, forceLogFull ?: config.logFull, msg)

    fun info(
        src: LogSource = LogSource.SOCKET,
        targets: Set<LogTarget> = setOf(LogTarget.PRINT),
        logFull: Boolean = false,
        msg: () -> String
    ) = log(src, targets, LogLevel.INFO, msg, logFull)

    fun warn(msg: String) = warn { msg }
    fun warn(config: LogConfig, forceLogFull: Boolean? = null, msg: () -> String) =
        warn(config.src, config.targets, forceLogFull ?: config.logFull, msg)

    fun warn(
        src: LogSource = LogSource.SOCKET,
        targets: Set<LogTarget> = setOf(LogTarget.PRINT),
        logFull: Boolean = false,
        msg: () -> String
    ) = log(src, targets, LogLevel.WARN, msg, logFull)

    fun error(msg: String) = error { msg }
    fun error(config: LogConfig, forceLogFull: Boolean? = null, msg: () -> String) =
        error(config.src, config.targets, forceLogFull ?: config.logFull, msg)

    fun error(
        src: LogSource = LogSource.SOCKET,
        targets: Set<LogTarget> = setOf(LogTarget.PRINT),
        logFull: Boolean = false,
        msg: () -> String
    ) = log(src, targets, LogLevel.ERROR, msg, logFull)

    private fun log(
        src: LogSource,
        targets: Set<LogTarget>,
        level: LogLevel,
        msg: () -> String,
        logFull: Boolean
    ) {
        if (level < this.level) return

        val msgString =
            msg().let { if (it.length > MAX_LOG_LENGTH && !logFull) "${it.take(MAX_LOG_LENGTH)}... [truncated]" else it }
        val timestamp = dateFormatter.format(getTimeMillis())
        val srcName = if (src != LogSource.ANY) src.name else ""

        val logMessage = if (srcName.isEmpty()) {
            "[$timestamp] [${level.name}] : $msgString"
        } else {
            "[$srcName | $timestamp] [${level.name}] : $msgString"
        }

        targets.forEach { target ->
            when (target) {
                LogTarget.PRINT -> {
                    if (this.colorfulLog) {
                        BypassJansi.println(colorizeLog(level, logMessage))
                    } else {
                        BypassJansi.println(logMessage)
                    }
                }
                is LogTarget.FILE -> writeToFile(target.file, logMessage)
                LogTarget.CLIENT -> {}
            }
        }
    }

    fun colorizeLog(level: LogLevel, text: String): String {
        val (fg, bg) = when (level) {
            LogLevel.SUCCESS -> AnsiColors.BlackText to AnsiColors.Success
            LogLevel.DEBUG -> AnsiColors.BlackText to AnsiColors.Debug
            LogLevel.INFO -> AnsiColors.BlackText to AnsiColors.Info
            LogLevel.WARN -> AnsiColors.BlackText to AnsiColors.Warn
            LogLevel.ERROR -> AnsiColors.WhiteText to AnsiColors.Error
        }
        return "$bg$fg$text${AnsiColors.Reset}"
    }

    private fun writeToFile(file: LogFile, message: String) {
        logFileMap[file]?.let { targetFile ->
            if (targetFile.exists() && targetFile.length() > MAX_LOG_FILE_SIZE) {
                rotateLogFile(targetFile)
            }
            targetFile.appendText("$message\n")
        }
    }

    private fun rotateLogFile(file: File): File {
        val match = Regex("""(.+)-(\d+)\.log""").matchEntire(file.name) ?: return file
        val (baseName, currentIndexStr) = match.destructured
        val nextIndex = (currentIndexStr.toInt() % MAX_LOG_ROTATES) + 1
        val newFile = File(file.parentFile, "$baseName-$nextIndex.log")
        if (newFile.exists()) newFile.delete()
        return newFile
    }

    fun enableColorfulLog(useColor: Boolean) {
        this.colorfulLog = useColor
    }

    fun setLevel(level: String) {
        when (level) {
            "0" -> setLevel(LogLevel.SUCCESS)
            "1" -> setLevel(LogLevel.DEBUG)
            "2" -> setLevel(LogLevel.INFO)
            "3" -> setLevel(LogLevel.WARN)
            "4" -> setLevel(LogLevel.ERROR)
            else -> setLevel(LogLevel.DEBUG)
        }
    }

    fun setLevel(logLevel: LogLevel) {
        level = logLevel
    }
}

/**
 * Raw console access that bypass Jansi.
 *
 * This is only needed when you want to style the console (e.g., colored text, emoji display)
 */
object BypassJansi {
    private val rawOut = PrintStream(FileOutputStream(FileDescriptor.out), true, Charsets.UTF_8)
    fun println(msg: String) = rawOut.println(msg)
}

enum class LogLevel { SUCCESS, DEBUG, INFO, WARN, ERROR }

sealed class LogTarget {
    object PRINT : LogTarget()
    object CLIENT : LogTarget()
    data class FILE(val file: LogFile) : LogTarget()
}

enum class LogFile { CLIENT_WRITE_ERROR, ASSETS_ERROR, API_SERVER_ERROR, SOCKET_SERVER_ERROR }
enum class LogSource { SOCKET, API, ANY }

data class LogConfig(
    val src: LogSource,
    val targets: Set<LogTarget> = setOf(LogTarget.PRINT),
    val logFull: Boolean = false
)

val LogConfigWriteError =
    LogConfig(LogSource.API, setOf(LogTarget.PRINT, LogTarget.FILE(LogFile.CLIENT_WRITE_ERROR)), true)
val LogConfigAPIError = LogConfig(LogSource.API, setOf(LogTarget.PRINT, LogTarget.FILE(LogFile.API_SERVER_ERROR)), true)
val LogConfigSocketToClient =
    LogConfig(LogSource.SOCKET, setOf(LogTarget.PRINT, LogTarget.FILE(LogFile.SOCKET_SERVER_ERROR)))
val LogConfigSocketError =
    LogConfig(LogSource.SOCKET, setOf(LogTarget.PRINT, LogTarget.FILE(LogFile.SOCKET_SERVER_ERROR)), true)
val LogConfigAssetsError = LogConfig(LogSource.ANY, setOf(LogTarget.PRINT, LogTarget.FILE(LogFile.ASSETS_ERROR)), true)



================================================================================
ðŸ“„ FICHIER : src\main\kotlin\utils\SpeedUpCostCalculator.kt
================================================================================

package utils

import kotlin.math.ceil
import kotlin.math.max

object SpeedUpCostCalculator {
    fun calculateCost(option: String, secondsRemaining: Int): Int {
        return when (option) {
            "SpeedUpOneHour" -> {
                val costPerMin = 0.35
                val minCost = 25
                val timeInMinutes = secondsRemaining / 60.0
                max(minCost, ceil(costPerMin * timeInMinutes).toInt())
            }
            "SpeedUpTwoHour" -> {
                val costPerMin = 0.3
                val minCost = 40
                val timeInMinutes = secondsRemaining / 60.0
                max(minCost, ceil(costPerMin * timeInMinutes).toInt())
            }
            "SpeedUpHalf" -> {
                val costPerMin = 0.4
                val minCost = 60
                val timeInMinutes = (secondsRemaining * 0.5) / 60.0
                max(minCost, ceil(costPerMin * timeInMinutes).toInt())
            }
            "SpeedUpComplete" -> {
                val costPerMin = 0.5
                val minCost = 80
                val timeInMinutes = secondsRemaining / 60.0
                max(minCost, ceil(costPerMin * timeInMinutes).toInt())
            }
            "SpeedUpFree" -> {
                0
            }
            else -> {
                0
            }
        }
    }
}


================================================================================
ðŸ“„ FICHIER : src\main\kotlin\utils\Time.kt
================================================================================

package utils

import io.ktor.util.date.getTimeMillis

object Time {
    /**
     * Return the epoch millis in Double type.
     *
     * IMPORTANT! TLSDZ AS3 code uses msg.getNumber(n++) to get the serverTime
     * If we send the epoch in Long, this means getNumber will fail and will default to 0 instead
     * Using Double type is better because it won't fail.
     */
    fun now(): Double {
        return getTimeMillis().toDouble()
    }
}



================================================================================
ðŸ“„ FICHIER : src\main\kotlin\utils\UUID.kt
================================================================================

package utils

import java.util.UUID

object UUID {
    /**
     * Returns an uppercased UUID from java.util.uuid.
     *
     * game used uppercase UUID so make sure to ignorecase when comparing or just use uppercase UUID too
     */
    fun new(): String {
        return UUID.randomUUID().toString().uppercase()
    }
}



================================================================================
ðŸ“„ FICHIER : src\test\kotlin\TestBroadcastService.kt
================================================================================

import dev.deadzone.socket.core.BroadcastServer
import kotlinx.coroutines.runBlocking
import server.broadcast.BroadcastMessage
import server.broadcast.BroadcastService
import kotlin.test.Test
import kotlin.test.assertEquals
import kotlin.test.assertTrue

class TestBroadcastService {

    @Test
    fun testBroadcastMessage() = runBlocking {
        val mockServer = MockBroadcastServer()
        BroadcastService.initialize(mockServer)

        BroadcastService.broadcast(BroadcastMessage.plainText("test"))

        assertEquals(1, mockServer.messageCount)
    }

    @Test
    fun testBroadcastString() = runBlocking {
        val mockServer = MockBroadcastServer()
        BroadcastService.initialize(mockServer)

        BroadcastService.broadcast("test message")

        assertEquals(1, mockServer.messageCount)
    }

    @Test
    fun testBroadcastPlainText() = runBlocking {
        val mockServer = MockBroadcastServer()
        BroadcastService.initialize(mockServer)

        BroadcastService.broadcastPlainText("plain text")

        assertEquals(1, mockServer.messageCount)
    }

    @Test
    fun testBroadcastAdmin() = runBlocking {
        val mockServer = MockBroadcastServer()
        BroadcastService.initialize(mockServer)

        BroadcastService.broadcastAdmin("admin message")

        assertEquals(1, mockServer.messageCount)
    }

    @Test
    fun testBroadcastWarning() = runBlocking {
        val mockServer = MockBroadcastServer()
        BroadcastService.initialize(mockServer)

        BroadcastService.broadcastWarning("warning message")

        assertEquals(1, mockServer.messageCount)
    }

    @Test
    fun testBroadcastShutdown() = runBlocking {
        val mockServer = MockBroadcastServer()
        BroadcastService.initialize(mockServer)

        BroadcastService.broadcastShutdown("Server maintenance")

        assertEquals(1, mockServer.messageCount)
    }

    @Test
    fun testBroadcastItemFound() = runBlocking {
        val mockServer = MockBroadcastServer()
        BroadcastService.initialize(mockServer)

        BroadcastService.broadcastItemFound("Player1", "Sword", "Legendary")

        assertEquals(1, mockServer.messageCount)
    }

    @Test
    fun testBroadcastItemCrafted() = runBlocking {
        val mockServer = MockBroadcastServer()
        BroadcastService.initialize(mockServer)

        BroadcastService.broadcastItemCrafted("Player1", "Armor")

        assertEquals(1, mockServer.messageCount)
    }

    @Test
    fun testBroadcastAchievement() = runBlocking {
        val mockServer = MockBroadcastServer()
        BroadcastService.initialize(mockServer)

        BroadcastService.broadcastAchievement("Player1", "First Blood")

        assertEquals(1, mockServer.messageCount)
    }

    @Test
    fun testGetClientCount() = runBlocking {
        val mockServer = MockBroadcastServer()
        BroadcastService.initialize(mockServer)

        val count = BroadcastService.getClientCount()

        assertEquals(5, count)
    }

    @Test
    fun testIsEnabled() = runBlocking {
        val mockServer = MockBroadcastServer()
        BroadcastService.initialize(mockServer)

        assertTrue(BroadcastService.isEnabled())
    }
}

class MockBroadcastServer : BroadcastServer {
    var messageCount = 0

    override suspend fun broadcast(message: BroadcastMessage) {
        messageCount++
    }

    override suspend fun broadcast(message: String) {
        messageCount++
    }

    override fun getClientCount(): Int = 5
}



================================================================================
ðŸ“„ FICHIER : src\test\kotlin\TestCompoundService.kt
================================================================================

import core.compound.CompoundRepository
import core.compound.CompoundService
import core.model.game.data.Building
import core.model.game.data.BuildingLike
import core.model.game.data.GameResources
import kotlinx.coroutines.runBlocking
import kotlin.test.Test
import kotlin.test.assertEquals
import kotlin.test.assertNotNull
import kotlin.test.assertTrue
import kotlin.time.Duration.Companion.seconds

class TestCompoundService {

    @Test
    fun testInitLoadsResourcesAndBuildings() = runBlocking {
        val mockRepo = MockCompoundRepository()
        val service = CompoundService(mockRepo)

        val result = service.init("player1")

        assertTrue(result.isSuccess)
        assertEquals(100, service.getResources().wood)
        assertEquals(50, service.getResources().metal)
    }

    @Test
    fun testGetBuilding() = runBlocking {
        val mockRepo = MockCompoundRepository()
        val service = CompoundService(mockRepo)
        service.init("player1")

        val building = service.getBuilding("bld1")

        assertNotNull(building)
        assertEquals("bld1", building.id)
    }

    @Test
    fun testUpdateBuildingSuccess() = runBlocking {
        val mockRepo = MockCompoundRepository()
        val service = CompoundService(mockRepo)
        service.init("player1")

        val result = service.updateBuilding("bld1") { building ->
            building.copy(level = 2)
        }

        assertTrue(result.isSuccess)
        val updated = service.getBuilding("bld1")
        assertNotNull(updated)
        assertEquals(2, updated.level)
    }

    @Test
    fun testUpdateBuildingNotFound() = runBlocking {
        val mockRepo = MockCompoundRepository()
        val service = CompoundService(mockRepo)
        service.init("player1")

        val result = service.updateBuilding("nonexistent") { it }

        assertTrue(result.isFailure)
    }

    @Test
    fun testUpdateBuildingFailure() = runBlocking {
        val mockRepo = MockCompoundRepository(shouldFail = true)
        val service = CompoundService(mockRepo)
        service.init("player1")

        val result = service.updateBuilding("bld1") { building ->
            building.copy(level = 2)
        }

        assertTrue(result.isFailure)
    }

    @Test
    fun testCreateBuildingSuccess() = runBlocking {
        val mockRepo = MockCompoundRepository()
        val service = CompoundService(mockRepo)
        service.init("player1")

        val result = service.createBuilding {
            Building(
                id = "bld3",
                type = "house",
                level = 1
            )
        }

        assertTrue(result.isSuccess)
        val created = service.getBuilding("bld3")
        assertNotNull(created)
    }

    @Test
    fun testCreateBuildingFailure() = runBlocking {
        val mockRepo = MockCompoundRepository(shouldFail = true)
        val service = CompoundService(mockRepo)
        service.init("player1")

        val result = service.createBuilding {
            Building(
                id = "bld3",
                type = "house",
                level = 1
            )
        }

        assertTrue(result.isFailure)
    }

    @Test
    fun testDeleteBuildingSuccess() = runBlocking {
        val mockRepo = MockCompoundRepository()
        val service = CompoundService(mockRepo)
        service.init("player1")

        val result = service.deleteBuilding("bld1")

        assertTrue(result.isSuccess)
        assertEquals(null, service.getBuilding("bld1"))
    }

    @Test
    fun testDeleteBuildingFailure() = runBlocking {
        val mockRepo = MockCompoundRepository(shouldFail = true)
        val service = CompoundService(mockRepo)
        service.init("player1")

        val result = service.deleteBuilding("bld1")

        assertTrue(result.isFailure)
        assertNotNull(service.getBuilding("bld1"))
    }

    @Test
    fun testUpdateResourceSuccess() = runBlocking {
        val mockRepo = MockCompoundRepository()
        val service = CompoundService(mockRepo)
        service.init("player1")

        val result = service.updateResource { resources ->
            resources.copy(wood = resources.wood + 50)
        }

        assertTrue(result.isSuccess)
        assertEquals(150, service.getResources().wood)
    }

    @Test
    fun testUpdateResourceFailure() = runBlocking {
        val mockRepo = MockCompoundRepository(shouldFail = true)
        val service = CompoundService(mockRepo)
        service.init("player1")

        val result = service.updateResource { resources ->
            resources.copy(wood = resources.wood + 50)
        }

        assertTrue(result.isFailure)
        assertEquals(100, service.getResources().wood)
    }

    @Test
    fun testCalculateResource() = runBlocking {
        val mockRepo = MockCompoundRepository()
        val service = CompoundService(mockRepo)
        service.init("player1")

        val amount = service.calculateResource(120.seconds)

        assertEquals(18.0, amount)
    }

    @Test
    fun testUpdateAllBuildingsSuccess() = runBlocking {
        val mockRepo = MockCompoundRepository()
        val service = CompoundService(mockRepo)
        service.init("player1")

        val updatedBuildings = listOf(
            Building(id = "bld1", type = "storage", level = 5)
        )

        val result = service.updateAllBuildings(updatedBuildings)

        assertTrue(result.isSuccess)
        assertEquals(1, service.getBuilding("bld1")?.let { 1 } ?: 0)
    }
}

class MockCompoundRepository(private val shouldFail: Boolean = false) : CompoundRepository {
    override suspend fun getGameResources(playerId: String): Result<GameResources> {
        return Result.success(GameResources(
            wood = 100,
            metal = 50,
            cloth = 30,
            water = 200,
            food = 150,
            ammunition = 80,
            cash = 1000
        ))
    }

    override suspend fun getBuildings(playerId: String): Result<List<BuildingLike>> {
        return Result.success(listOf(
            Building(
                id = "bld1",
                type = "storage",
                level = 1
            ),
            Building(
                id = "bld2",
                type = "resource_wood",
                level = 1
            )
        ))
    }

    override suspend fun updateBuilding(playerId: String, buildingId: String, building: BuildingLike): Result<Unit> {
        return if (shouldFail) Result.failure(Exception("Update failed"))
        else Result.success(Unit)
    }

    override suspend fun updateAllBuildings(playerId: String, buildings: List<BuildingLike>): Result<Unit> {
        return if (shouldFail) Result.failure(Exception("Update failed"))
        else Result.success(Unit)
    }

    override suspend fun createBuilding(playerId: String, building: BuildingLike): Result<Unit> {
        return if (shouldFail) Result.failure(Exception("Create failed"))
        else Result.success(Unit)
    }

    override suspend fun deleteBuilding(playerId: String, buildingId: String): Result<Unit> {
        return if (shouldFail) Result.failure(Exception("Delete failed"))
        else Result.success(Unit)
    }

    override suspend fun updateGameResources(playerId: String, resources: GameResources): Result<Unit> {
        return if (shouldFail) Result.failure(Exception("Update failed"))
        else Result.success(Unit)
    }
}



================================================================================
ðŸ“„ FICHIER : src\test\kotlin\TestInventoryService.kt
================================================================================

import core.items.InventoryRepository
import core.items.InventoryService
import core.items.model.InventoryObject
import core.items.model.Item
import kotlinx.coroutines.runBlocking
import kotlin.test.Test
import kotlin.test.assertEquals
import kotlin.test.assertTrue

class TestInventoryService {

    @Test
    fun testInitLoadsInventory() = runBlocking {
        val mockRepo = MockInventoryRepository()
        val service = InventoryService(mockRepo)

        val result = service.init("player1")

        assertTrue(result.isSuccess)
        assertEquals(2, service.getInventory().size)
        assertEquals(3, service.getSchematics().size)
    }

    @Test
    fun testUpdateInventorySuccess() = runBlocking {
        val mockRepo = MockInventoryRepository()
        val service = InventoryService(mockRepo)
        service.init("player1")

        val result = service.updateInventory { items ->
            items + Item(type = "wood", qty = 10u)
        }

        assertTrue(result.isSuccess)
        assertEquals(3, service.getInventory().size)
    }

    @Test
    fun testUpdateInventoryFailure() = runBlocking {
        val mockRepo = MockInventoryRepository(shouldFail = true)
        val service = InventoryService(mockRepo)
        service.init("player1")

        val result = service.updateInventory { items ->
            items + Item(type = "wood", qty = 10u)
        }

        assertTrue(result.isFailure)
        assertEquals(2, service.getInventory().size)
    }

    @Test
    fun testUpdateSchematicsSuccess() = runBlocking {
        val mockRepo = MockInventoryRepository()
        val service = InventoryService(mockRepo)
        service.init("player1")

        val result = service.updateSchematics { schematics ->
            schematics + byteArrayOf(1, 2, 3)
        }

        assertTrue(result.isSuccess)
        assertEquals(6, service.getSchematics().size)
    }

    @Test
    fun testUpdateSchematicsFailure() = runBlocking {
        val mockRepo = MockInventoryRepository(shouldFail = true)
        val service = InventoryService(mockRepo)
        service.init("player1")

        val result = service.updateSchematics { schematics ->
            schematics + byteArrayOf(1, 2, 3)
        }

        assertTrue(result.isFailure)
        assertEquals(3, service.getSchematics().size)
    }
}

class MockInventoryRepository(private val shouldFail: Boolean = false) : InventoryRepository {
    override suspend fun getInventory(playerId: String): Result<InventoryObject> {
        return Result.success(InventoryObject(
            inventory = listOf(
                Item(type = "pipe", qty = 5u),
                Item(type = "metal", qty = 10u)
            ),
            schematics = byteArrayOf(1, 2, 3)
        ))
    }

    override suspend fun updateInventory(playerId: String, inventory: List<Item>): Result<Unit> {
        return if (shouldFail) Result.failure(Exception("Update failed"))
        else Result.success(Unit)
    }

    override suspend fun updateSchematics(playerId: String, schematics: ByteArray): Result<Unit> {
        return if (shouldFail) Result.failure(Exception("Update failed"))
        else Result.success(Unit)
    }
}



================================================================================
ðŸ“„ FICHIER : src\test\kotlin\TestLootService.kt
================================================================================

import core.mission.LootService
import core.mission.model.LootParameter
import kotlin.test.Test
import kotlin.test.assertTrue

class TestLootService {

    private val sampleSceneXML = """
        <?xml version="1.0"?>
        <scene>
            <e>
                <opt>
                    <srch>random,weapon</srch>
                </opt>
            </e>
            <e>
                <opt>
                    <srch>food,water</srch>
                </opt>
            </e>
        </scene>
    """.trimIndent()

    @Test
    fun testLootServiceInitialization() {
        val parameter = LootParameter(
            areaLevel = 1,
            baseWeight = 100.0
        )

        val service = LootService(sampleSceneXML, parameter)

        assertTrue(service.cumulativeLootsPerLoc.isNotEmpty())
    }

    @Test
    fun testInsertLoots() {
        val parameter = LootParameter(
            areaLevel = 1,
            baseWeight = 100.0
        )

        val service = LootService(sampleSceneXML, parameter)
        val (updatedXML, loots) = service.insertLoots()

        assertTrue(updatedXML.contains("<itms"))
        assertTrue(loots.size >= 0)
    }

    @Test
    fun testInsertLootsWithExistingItems() {
        val sceneWithItems = """
            <?xml version="1.0"?>
            <scene>
                <e>
                    <opt>
                        <srch>random</srch>
                    </opt>
                    <itms>
                        <itm id="existing" type="sword" q="1"/>
                    </itms>
                </e>
            </scene>
        """.trimIndent()

        val parameter = LootParameter(
            areaLevel = 1,
            baseWeight = 100.0
        )

        val service = LootService(sceneWithItems, parameter)
        val (_, loots) = service.insertLoots()

        assertTrue(loots.isEmpty())
    }

    @Test
    fun testLootParameterWithBoosts() {
        val parameter = LootParameter(
            areaLevel = 5,
            baseWeight = 100.0,
            specificItemBoost = mapOf("pipe" to 2.0),
            itemTypeBoost = mapOf("weapon" to 1.5),
            itemQualityBoost = mapOf("rare" to 1.2)
        )

        val service = LootService(sampleSceneXML, parameter)

        assertTrue(service.totalWeightPerLoc.isNotEmpty())
    }

    @Test
    fun testLootParameterWithOverrides() {
        val parameter = LootParameter(
            areaLevel = 1,
            baseWeight = 100.0,
            itemWeightOverrides = mapOf("pipe" to 500.0)
        )

        val service = LootService(sampleSceneXML, parameter)

        assertTrue(service.cumulativeLootsPerLoc.isNotEmpty())
    }

    @Test
    fun testInsertedLootsTracking() {
        val parameter = LootParameter(
            areaLevel = 1,
            baseWeight = 100.0
        )

        val service = LootService(sampleSceneXML, parameter)
        service.insertLoots()

        assertTrue(service.insertedLoots.size >= 0)
    }

    @Test
    fun testEmptySceneXML() {
        val emptyScene = """
            <?xml version="1.0"?>
            <scene>
            </scene>
        """.trimIndent()

        val parameter = LootParameter(
            areaLevel = 1,
            baseWeight = 100.0
        )

        val service = LootService(emptyScene, parameter)
        val (_, loots) = service.insertLoots()

        assertTrue(loots.isEmpty())
    }

    @Test
    fun testHighLevelAreaFiltering() {
        val parameter = LootParameter(
            areaLevel = 50,
            baseWeight = 100.0
        )

        val service = LootService(sampleSceneXML, parameter)

        assertTrue(service.cumulativeLootsPerLoc.size >= 0)
    }
}



================================================================================
ðŸ“„ FICHIER : src\test\kotlin\TestPlayerObjectsMetadataService.kt
================================================================================

import core.metadata.PlayerObjectsMetadataRepository
import core.metadata.PlayerObjectsMetadataService
import kotlinx.coroutines.runBlocking
import kotlin.test.Test
import kotlin.test.assertContentEquals
import kotlin.test.assertTrue

class TestPlayerObjectsMetadataService {

    @Test
    fun testInitLoadsFlags() = runBlocking {
        val mockRepo = MockPlayerObjectsMetadataRepository()
        val service = PlayerObjectsMetadataService(mockRepo)

        val result = service.init("player1")

        assertTrue(result.isSuccess)
        assertContentEquals(byteArrayOf(1, 2, 3), service.getPlayerFlags())
    }

    @Test
    fun testUpdatePlayerFlagsSuccess() = runBlocking {
        val mockRepo = MockPlayerObjectsMetadataRepository()
        val service = PlayerObjectsMetadataService(mockRepo)
        service.init("player1")

        val newFlags = byteArrayOf(4, 5, 6)
        val result = service.updatePlayerFlags(newFlags)

        assertTrue(result.isSuccess)
        assertContentEquals(newFlags, service.getPlayerFlags())
    }

    @Test
    fun testUpdatePlayerFlagsFailure() = runBlocking {
        val mockRepo = MockPlayerObjectsMetadataRepository(shouldFail = true)
        val service = PlayerObjectsMetadataService(mockRepo)
        service.init("player1")

        val originalFlags = service.getPlayerFlags().copyOf()
        val newFlags = byteArrayOf(4, 5, 6)
        val result = service.updatePlayerFlags(newFlags)

        assertTrue(result.isFailure)
        assertContentEquals(originalFlags, service.getPlayerFlags())
    }

    @Test
    fun testUpdatePlayerNicknameSuccess() = runBlocking {
        val mockRepo = MockPlayerObjectsMetadataRepository()
        val service = PlayerObjectsMetadataService(mockRepo)
        service.init("player1")

        val result = service.updatePlayerNickname("NewNickname")

        assertTrue(result.isSuccess)
    }

    @Test
    fun testUpdatePlayerNicknameFailure() = runBlocking {
        val mockRepo = MockPlayerObjectsMetadataRepository(shouldFail = true)
        val service = PlayerObjectsMetadataService(mockRepo)
        service.init("player1")

        val result = service.updatePlayerNickname("NewNickname")

        assertTrue(result.isFailure)
    }
}

class MockPlayerObjectsMetadataRepository(private val shouldFail: Boolean = false) : PlayerObjectsMetadataRepository {
    override suspend fun getPlayerFlags(playerId: String): Result<ByteArray> {
        return Result.success(byteArrayOf(1, 2, 3))
    }

    override suspend fun getPlayerNickname(playerId: String): Result<String?> {
        return Result.success("TestPlayer")
    }

    override suspend fun updatePlayerFlags(playerId: String, flags: ByteArray): Result<Unit> {
        return if (shouldFail) Result.failure(Exception("Update failed"))
        else Result.success(Unit)
    }

    override suspend fun updatePlayerNickname(playerId: String, nickname: String): Result<Unit> {
        return if (shouldFail) Result.failure(Exception("Update failed"))
        else Result.success(Unit)
    }
}



================================================================================
ðŸ“„ FICHIER : src\test\kotlin\TestSurvivorService.kt
================================================================================

import core.model.game.data.Survivor
import core.survivor.SurvivorRepository
import core.survivor.SurvivorService
import kotlinx.coroutines.runBlocking
import kotlin.test.Test
import kotlin.test.assertEquals
import kotlin.test.assertNotNull
import kotlin.test.assertTrue

class TestSurvivorService {

    @Test
    fun testInitLoadsSurvivors() = runBlocking {
        val mockRepo = MockSurvivorRepository()
        val service = SurvivorService("leader1", mockRepo)

        val result = service.init("player1")

        assertTrue(result.isSuccess)
        assertEquals(2, service.getAllSurvivors().size)
    }

    @Test
    fun testGetSurvivorLeader() = runBlocking {
        val mockRepo = MockSurvivorRepository()
        val service = SurvivorService("leader1", mockRepo)
        service.init("player1")

        val leader = service.getSurvivorLeader()

        assertNotNull(leader)
        assertEquals("leader1", leader.id)
        assertEquals("Leader", leader.firstName)
    }

    @Test
    fun testAddNewSurvivorSuccess() = runBlocking {
        val mockRepo = MockSurvivorRepository()
        val service = SurvivorService("leader1", mockRepo)
        service.init("player1")

        val newSurvivor = Survivor(
            id = "srv3",
            title = "Scout",
            firstName = "John",
            lastName = "Doe",
            gender = "male",
            classId = "scout",
            voice = "male1"
        )

        val result = service.addNewSurvivor(newSurvivor)

        assertTrue(result.isSuccess)
        assertEquals(3, service.getAllSurvivors().size)
    }

    @Test
    fun testAddNewSurvivorFailure() = runBlocking {
        val mockRepo = MockSurvivorRepository(shouldFail = true)
        val service = SurvivorService("leader1", mockRepo)
        service.init("player1")

        val newSurvivor = Survivor(
            id = "srv3",
            title = "Scout",
            firstName = "John",
            lastName = "Doe",
            gender = "male",
            classId = "scout",
            voice = "male1"
        )

        val result = service.addNewSurvivor(newSurvivor)

        assertTrue(result.isFailure)
        assertEquals(2, service.getAllSurvivors().size)
    }

    @Test
    fun testUpdateSurvivorSuccess() = runBlocking {
        val mockRepo = MockSurvivorRepository()
        val service = SurvivorService("leader1", mockRepo)
        service.init("player1")

        val result = service.updateSurvivor("srv2") { survivor ->
            survivor.copy(level = 10, xp = 500)
        }

        assertTrue(result.isSuccess)
        val updated = service.getAllSurvivors().find { it.id == "srv2" }
        assertNotNull(updated)
        assertEquals(10, updated.level)
        assertEquals(500, updated.xp)
    }

    @Test
    fun testUpdateSurvivorNotFound() = runBlocking {
        val mockRepo = MockSurvivorRepository()
        val service = SurvivorService("leader1", mockRepo)
        service.init("player1")

        val result = service.updateSurvivor("nonexistent") { it }

        assertTrue(result.isFailure)
    }

    @Test
    fun testUpdateSurvivorFailure() = runBlocking {
        val mockRepo = MockSurvivorRepository(shouldFail = true)
        val service = SurvivorService("leader1", mockRepo)
        service.init("player1")

        val result = service.updateSurvivor("srv2") { survivor ->
            survivor.copy(level = 10)
        }

        assertTrue(result.isFailure)
    }

    @Test
    fun testUpdateSurvivorsSuccess() = runBlocking {
        val mockRepo = MockSurvivorRepository()
        val service = SurvivorService("leader1", mockRepo)
        service.init("player1")

        val updatedList = listOf(
            Survivor(
                id = "leader1",
                title = "Leader",
                firstName = "Leader",
                lastName = "Updated",
                gender = "male",
                classId = "leader",
                voice = "male1"
            )
        )

        val result = service.updateSurvivors(updatedList)

        assertTrue(result.isSuccess)
        assertEquals(1, service.getAllSurvivors().size)
    }

    @Test
    fun testInitAppliesDefaultLastName() = runBlocking {
        val mockRepo = MockSurvivorRepository(includeEmptyLastName = true)
        val service = SurvivorService("leader1", mockRepo)

        service.init("player1")

        val survivor = service.getAllSurvivors().find { it.id == "srv2" }
        assertNotNull(survivor)
        assertEquals("DZ", survivor.lastName)
    }
}

class MockSurvivorRepository(
    private val shouldFail: Boolean = false,
    private val includeEmptyLastName: Boolean = false
) : SurvivorRepository {
    override suspend fun getSurvivors(playerId: String): Result<List<Survivor>> {
        val survivors = listOf(
            Survivor(
                id = "leader1",
                title = "Leader",
                firstName = "Leader",
                lastName = "Smith",
                gender = "male",
                classId = "leader",
                voice = "male1"
            ),
            Survivor(
                id = "srv2",
                title = "Fighter",
                firstName = "Fighter",
                lastName = if (includeEmptyLastName) "" else "Jones",
                gender = "female",
                classId = "fighter",
                voice = "female1"
            )
        )
        return Result.success(survivors)
    }

    override suspend fun addSurvivor(playerId: String, survivor: Survivor): Result<Unit> {
        return if (shouldFail) Result.failure(Exception("Add failed"))
        else Result.success(Unit)
    }

    override suspend fun updateSurvivor(playerId: String, survivorId: String, survivor: Survivor): Result<Unit> {
        return if (shouldFail) Result.failure(Exception("Update failed"))
        else Result.success(Unit)
    }

    override suspend fun updateSurvivors(playerId: String, survivors: List<Survivor>): Result<Unit> {
        return if (shouldFail) Result.failure(Exception("Update failed"))
        else Result.success(Unit)
    }
}


