===== C:\Users\Sulivan\Desktop\Projects\DeadZone-Private-Server\src\main\kotlin\Application.kt =====
package dev.deadzone
import dev.deadzone.api.routes.*
import dev.deadzone.context.GlobalContext
import dev.deadzone.context.PlayerContextTracker
import dev.deadzone.context.ServerConfig
import dev.deadzone.context.ServerContext
import dev.deadzone.core.auth.SessionManager
import dev.deadzone.core.data.GameDefinitions
import dev.deadzone.core.model.game.data.Building
import dev.deadzone.core.model.game.data.BuildingLike
import dev.deadzone.core.model.game.data.JunkBuilding
import dev.deadzone.data.db.BigDBMariaImpl
import dev.deadzone.socket.core.OnlinePlayerRegistry
import dev.deadzone.socket.core.Server
import dev.deadzone.socket.handler.save.arena.ArenaSaveHandler
import dev.deadzone.socket.handler.save.bounty.BountySaveHandler
import dev.deadzone.socket.handler.save.chat.ChatSaveHandler
import dev.deadzone.socket.handler.save.command.CommandSaveHandler
import dev.deadzone.socket.handler.save.compound.building.BuildingSaveHandler
import dev.deadzone.socket.handler.save.compound.misc.CmpMiscSaveHandler
import dev.deadzone.socket.handler.save.crate.CrateSaveHandler
import dev.deadzone.socket.handler.save.item.ItemSaveHandler
import dev.deadzone.socket.handler.save.misc.MiscSaveHandler
import dev.deadzone.socket.handler.save.mission.MissionSaveHandler
import dev.deadzone.socket.handler.save.purchase.PurchaseSaveHandler
import dev.deadzone.socket.handler.save.quest.QuestSaveHandler
import dev.deadzone.socket.handler.save.raid.RaidSaveHandler
import dev.deadzone.socket.handler.save.survivor.SurvivorSaveHandler
import dev.deadzone.socket.tasks.ServerTaskDispatcher
import dev.deadzone.user.PlayerAccountRepositoryMaria
import dev.deadzone.user.auth.WebsiteAuthProvider
import dev.deadzone.utils.LogLevel
import dev.deadzone.utils.Logger
import dev.deadzone.websocket.WebsocketManager
import dev.deadzone.websocket.WsMessage
import io.ktor.http.*
import io.ktor.serialization.kotlinx.json.*
import io.ktor.serialization.kotlinx.protobuf.*
import io.ktor.server.application.*
import io.ktor.server.netty.*
import io.ktor.server.plugins.calllogging.*
import io.ktor.server.plugins.contentnegotiation.*
import io.ktor.server.plugins.cors.routing.*
import io.ktor.server.plugins.statuspages.*
import io.ktor.server.response.*
import io.ktor.server.routing.*
import io.ktor.server.websocket.*
import io.ktor.websocket.*
import kotlinx.coroutines.launch
import kotlinx.serialization.ExperimentalSerializationApi
import kotlinx.serialization.json.Json
import kotlinx.serialization.json.encodeToJsonElement
import kotlinx.serialization.modules.SerializersModule
import kotlinx.serialization.modules.polymorphic
import kotlinx.serialization.protobuf.ProtoBuf
import org.jetbrains.exposed.sql.Database
import socket.handler.save.compound.task.TaskSaveHandler
import java.io.File
import kotlin.time.Duration.Companion.seconds

fun main(args: Array<String>) = EngineMain.main(args)

const val SERVER_HOST = "127.0.0.1"
const val API_SERVER_HOST = "127.0.0.1:8080"
const val SOCKET_SERVER_HOST = "127.0.0.1:7777"
const val SOCKET_SERVER_PORT = 7777

fun Application.module() {
    install(WebSockets) {
        pingPeriod = 15.seconds
        timeout = 15.seconds
        masking = true
    }
    Logger.info("üöÄ Starting DeadZone server")
    val wsManager = WebsocketManager()
    val module = SerializersModule {
        polymorphic(BuildingLike::class) {
            subclass(Building::class, Building.serializer())
            subclass(JunkBuilding::class, JunkBuilding.serializer())
        }
    }
    val json = Json {
        serializersModule = module
        classDiscriminator = "_t"
        prettyPrint = true
        isLenient = true
        ignoreUnknownKeys = true
        encodeDefaults = true
    }
    @OptIn(ExperimentalSerializationApi::class)
    install(ContentNegotiation) {
        json(json)
        protobuf(ProtoBuf)
    }
    GlobalContext.init(
        json = json,
        gameDefinitions = GameDefinitions(onResourceLoadComplete = {
            launch { wsManager.onResourceLoadComplete() }
            Logger.info("üéÆ Game resources loaded")
        })
    )
    val config = ServerConfig(
        adminEnabled = environment.config.propertyOrNull("game.enableAdmin")?.getString()?.toBooleanStrictOrNull() ?: false,
        useMaria = true,
        mariaUrl = environment.config.propertyOrNull("maria.url")?.getString() ?: "jdbc:mariadb://localhost:3306/deadzone",
        mariaUser = environment.config.propertyOrNull("maria.user")?.getString() ?: "root",
        mariaPassword = environment.config.propertyOrNull("maria.password")?.getString() ?: "",
        isProd = !developmentMode,
    )
    Logger.info("üóÉÔ∏è Connecting to MariaDB...")
    val database = try {
        val mariaDb = Database.connect(
            url = config.mariaUrl,
            driver = "org.mariadb.jdbc.Driver",
            user = config.mariaUser,
            password = config.mariaPassword
        )
        Logger.info("üü¢ MariaDB connected")
        BigDBMariaImpl(mariaDb, config.adminEnabled)
    } catch (e: Exception) {
        Logger.error("üî¥ MariaDB connection failed: ${e.message}")
        throw e
    }
    val sessionManager = SessionManager()
    val playerAccountRepository = PlayerAccountRepositoryMaria(database.database)
    val onlinePlayerRegistry = OnlinePlayerRegistry()
    val authProvider = WebsiteAuthProvider(database, playerAccountRepository, sessionManager)
    val taskDispatcher = ServerTaskDispatcher()
    val playerContextTracker = PlayerContextTracker()
    val saveHandlers = listOf(
        ArenaSaveHandler(), BountySaveHandler(), ChatSaveHandler(), CommandSaveHandler(),
        BuildingSaveHandler(), CmpMiscSaveHandler(), TaskSaveHandler(), CrateSaveHandler(),
        ItemSaveHandler(), MiscSaveHandler(), MissionSaveHandler(), PurchaseSaveHandler(),
        QuestSaveHandler(), RaidSaveHandler(), SurvivorSaveHandler()
    )
    val serverContext = ServerContext(
        db = database,
        playerAccountRepository = playerAccountRepository,
        sessionManager = sessionManager,
        onlinePlayerRegistry = onlinePlayerRegistry,
        authProvider = authProvider,
        taskDispatcher = taskDispatcher,
        playerContextTracker = playerContextTracker,
        saveHandlers = saveHandlers,
        config = config,
    )
    install(CORS) {
        allowHost(API_SERVER_HOST, schemes = listOf("http"))
        allowHost(SOCKET_SERVER_HOST, schemes = listOf("http"))
        allowHeader(HttpHeaders.ContentType)
        allowMethod(HttpMethod.Get)
    }
    install(StatusPages) {
        exception<Throwable> { call, cause ->
            Logger.error("‚ö†Ô∏è Server error: ${cause.message}")
            call.respondText(text = "500: ${cause.message}", status = HttpStatusCode.InternalServerError)
        }
    }
    Logger.level = LogLevel.DEBUG
    install(CallLogging)
    Logger.init { logMessage ->
        wsManager.getAllClients().forEach { (clientId, session) ->
            try {
                val logJson = Json.encodeToJsonElement(logMessage)
                session.send(
                    Frame.Text(
                        Json.encodeToString(
                            WsMessage(
                                type = "log",
                                payload = logJson
                            )
                        )
                    )
                )
            } catch (e: Exception) {
                Logger.error("üì° Failed to send log to client $clientId: ${e.message}")
                wsManager.removeClient(clientId)
            }
        }
    }
    Logger.info("üìú Real-time logging enabled")
    routing {
        fileRoutes()
        caseInsensitiveStaticResources("/game/data", File("static"))
        authRoutes(serverContext)
        apiRoutes(serverContext)
        debugLogRoutes(wsManager)
    }
    val server = Server(context = serverContext).also { it.start() }
    Logger.info("üéâ Server started successfully")
    Logger.info("üì° Socket server listening on $SOCKET_SERVER_HOST")
    Logger.info("üåê API server available at $API_SERVER_HOST")
    Runtime.getRuntime().addShutdownHook(Thread {
        server.shutdown()
        Logger.info("üõë Server shutdown complete")
    })
}

===== C:\Users\Sulivan\Desktop\Projects\DeadZone-Private-Server\src\main\kotlin\api\handler\Authenticate.kt =====
package dev.deadzone.api.handler
import dev.deadzone.API_SERVER_HOST
import dev.deadzone.api.message.auth.AuthenticateArgs
import dev.deadzone.api.message.auth.AuthenticateOutput
import dev.deadzone.api.utils.pioFraming
import dev.deadzone.context.ServerContext
import dev.deadzone.core.data.AdminData
import dev.deadzone.utils.Logger
import dev.deadzone.utils.logInput
import dev.deadzone.utils.logOutput
import io.ktor.http.*
import io.ktor.server.request.*
import io.ktor.server.response.*
import io.ktor.server.routing.*
import io.ktor.utils.io.*
import kotlinx.serialization.ExperimentalSerializationApi
import kotlinx.serialization.decodeFromByteArray
import kotlinx.serialization.encodeToByteArray
import kotlinx.serialization.protobuf.ProtoBuf

@OptIn(ExperimentalSerializationApi::class)
suspend fun RoutingContext.authenticate(serverContext: ServerContext) {
    val authenticateArgs = ProtoBuf.decodeFromByteArray<AuthenticateArgs>(
        call.receiveChannel().toByteArray()
    )
    logInput(authenticateArgs)
    val userToken = authenticateArgs
        .authenticationArguments
        .find { it.key == "userToken" }?.value
    if (userToken == null) {
        Logger.error { "Missing userToken in API 13 request" }
        call.respond(HttpStatusCode.BadRequest, "userToken is missing")
        return
    }
    val authenticateOutput = if (userToken == AdminData.TOKEN) {
        Logger.info { "auth by admin" }
        AuthenticateOutput.admin()
    } else {
        val isValidToken = serverContext.sessionManager.verify(userToken)
        if (isValidToken) {
            AuthenticateOutput(
                token = userToken,
                userId = serverContext.sessionManager.getPlayerId(userToken)!!,
                apiServerHosts = listOf(API_SERVER_HOST)
            )
        } else {
            call.respond(HttpStatusCode.Unauthorized, "token is invalid")
            null
        }
    } ?: return
    val encodedOutput = ProtoBuf.encodeToByteArray<AuthenticateOutput>(
        authenticateOutput
    )
    logOutput(encodedOutput)
    call.respondBytes(encodedOutput.pioFraming())
}

===== C:\Users\Sulivan\Desktop\Projects\DeadZone-Private-Server\src\main\kotlin\api\handler\CreateJoinRoom.kt =====
package dev.deadzone.api.handler
import dev.deadzone.api.message.client.CreateJoinRoomArgs
import dev.deadzone.api.message.client.CreateJoinRoomOutput
import dev.deadzone.api.utils.pioFraming
import dev.deadzone.utils.logInput
import dev.deadzone.utils.logOutput
import io.ktor.server.request.*
import io.ktor.server.response.*
import io.ktor.server.routing.*
import io.ktor.utils.io.*
import kotlinx.serialization.ExperimentalSerializationApi
import kotlinx.serialization.decodeFromByteArray
import kotlinx.serialization.encodeToByteArray
import kotlinx.serialization.protobuf.ProtoBuf

@OptIn(ExperimentalSerializationApi::class)
suspend fun RoutingContext.createJoinRoom() {
    val createJoinRoomArgs = ProtoBuf.decodeFromByteArray<CreateJoinRoomArgs>(
        call.receiveChannel().toByteArray()
    )
    logInput(createJoinRoomArgs)
    val createJoinRoomOutput = ProtoBuf.encodeToByteArray<CreateJoinRoomOutput>(
        CreateJoinRoomOutput.defaultRoom()
    )
    logOutput(createJoinRoomOutput)
    call.respondBytes(createJoinRoomOutput.pioFraming())
}

===== C:\Users\Sulivan\Desktop\Projects\DeadZone-Private-Server\src\main\kotlin\api\handler\LoadIndexRange.kt =====
package dev.deadzone.api.handler
import dev.deadzone.api.message.db.LoadIndexRangeArgs
import dev.deadzone.api.message.db.LoadObjectsOutput
import dev.deadzone.api.utils.pioFraming
import dev.deadzone.utils.logInput
import io.ktor.server.request.receiveChannel
import io.ktor.server.response.respondBytes
import io.ktor.server.routing.RoutingContext
import io.ktor.utils.io.toByteArray
import kotlinx.serialization.ExperimentalSerializationApi
import kotlinx.serialization.decodeFromByteArray
import kotlinx.serialization.encodeToByteArray
import kotlinx.serialization.protobuf.ProtoBuf

@OptIn(ExperimentalSerializationApi::class)
suspend fun RoutingContext.loadIndexRange() {
    val args = ProtoBuf.decodeFromByteArray<LoadIndexRangeArgs>(
        call.receiveChannel().toByteArray()
    )
    logInput(args)
    val outputBytes = ProtoBuf.encodeToByteArray(
        LoadObjectsOutput(objects = emptyList())
    )
    call.respondBytes(outputBytes.pioFraming())
}

===== C:\Users\Sulivan\Desktop\Projects\DeadZone-Private-Server\src\main\kotlin\api\handler\LoadObjects.kt =====
package dev.deadzone.api.handler
import dev.deadzone.api.message.db.BigDBObject
import dev.deadzone.api.message.db.LoadObjectsArgs
import dev.deadzone.api.message.db.LoadObjectsOutput
import dev.deadzone.api.utils.pioFraming
import dev.deadzone.context.ServerContext
import core.LazyDataUpdater
import dev.deadzone.data.collection.NeighborHistory
import dev.deadzone.utils.LogConfigAPIError
import dev.deadzone.utils.LogConfigSocketToClient
import dev.deadzone.utils.LogSource
import dev.deadzone.utils.Logger
import dev.deadzone.utils.logInput
import io.ktor.server.request.*
import io.ktor.server.response.*
import io.ktor.server.routing.*
import io.ktor.utils.io.*
import kotlinx.serialization.ExperimentalSerializationApi
import kotlinx.serialization.decodeFromByteArray
import kotlinx.serialization.encodeToByteArray
import kotlinx.serialization.protobuf.ProtoBuf

@OptIn(ExperimentalSerializationApi::class)
suspend fun RoutingContext.loadObjects(serverContext: ServerContext) {
    val loadObjectsArgs = ProtoBuf.decodeFromByteArray<LoadObjectsArgs>(
        call.receiveChannel().toByteArray()
    )
    logInput(loadObjectsArgs)
    val objs = mutableListOf<BigDBObject>()
    for (objId in loadObjectsArgs.objectIds) {
        val playerId = objId.keys.firstOrNull() ?: continue
        val result = serverContext.playerAccountRepository.getProfileOfPlayerId(playerId)
        result.onFailure {
            Logger.warn(LogConfigAPIError) { "Failure on getProfileOfPlayerId for playerId=$playerId: ${it.message}" }
            continue
        }
        val profile = requireNotNull(result.getOrThrow()) {
            "getProfileOfPlayerId succeed but returned profile is null"
        }
        Logger.debug(src = LogSource.API) { "Found object for playerId: $playerId" }
        val playerObjects = serverContext.db.loadPlayerObjects(playerId)!!
        val neighborHistory = serverContext.db.loadNeighborHistory(playerId)!!
        val inventory = serverContext.db.loadInventory(playerId)!!
        val obj: BigDBObject? = when (objId.table) {
            "PlayerObjects" -> {
                val updatedBuildings = LazyDataUpdater.updateBuildingTimers(playerObjects.buildings)
                val depletedResources = LazyDataUpdater.depleteResources(profile.lastLogin, playerObjects.resources)
                try {
                    serverContext.db.updatePlayerObjectsField(playerId, "buildings", updatedBuildings)
                    serverContext.db.updatePlayerObjectsField(playerId, "resources", depletedResources)
                } catch (e: Exception) {
                    Logger.error(LogConfigSocketToClient) { "Error while updating time-dynamic data: ${e.message}" }
                    return
                }
                LoadObjectsOutput.fromData(
                    playerObjects.copy(
                        buildings = updatedBuildings,
                        resources = depletedResources
                    )
                )
            }
            "NeighborHistory" -> LoadObjectsOutput.fromData(
                NeighborHistory(
                    playerId = playerId,
                    map = neighborHistory.map
                )
            )
            "Inventory" -> LoadObjectsOutput.fromData(inventory)
            else -> {
                Logger.error(LogConfigAPIError) { "UNIMPLEMENTED table for ${objId.table}" }
                null
            }
        }
        if (obj != null) objs.add(obj)
    }
    val loadObjectsOutput = ProtoBuf.encodeToByteArray(LoadObjectsOutput(objects = objs))
    call.respondBytes(loadObjectsOutput.pioFraming())
}

===== C:\Users\Sulivan\Desktop\Projects\DeadZone-Private-Server\src\main\kotlin\api\handler\SocialRefresh.kt =====
package dev.deadzone.api.handler
import dev.deadzone.api.message.social.SocialProfile
import dev.deadzone.api.message.social.SocialRefreshOutput
import dev.deadzone.api.utils.pioFraming
import dev.deadzone.context.ServerContext
import dev.deadzone.core.data.AdminData
import dev.deadzone.utils.LogConfigAPIError
import dev.deadzone.utils.Logger
import dev.deadzone.utils.logInput
import dev.deadzone.utils.logOutput
import io.ktor.server.request.*
import io.ktor.server.response.*
import io.ktor.server.routing.*
import io.ktor.utils.io.*
import kotlinx.serialization.ExperimentalSerializationApi
import kotlinx.serialization.encodeToByteArray
import kotlinx.serialization.protobuf.ProtoBuf

@OptIn(ExperimentalSerializationApi::class)
suspend fun RoutingContext.socialRefresh(serverContext: ServerContext, token: String) {
    val socialRefreshArgs = call.receiveChannel().toByteArray() // Actually no input is given
    logInput(socialRefreshArgs.decodeToString())
    val pid = serverContext.sessionManager.getPlayerId(token)!!
    val result = serverContext.playerAccountRepository.getProfileOfPlayerId(pid)
    result.onFailure {
        Logger.error(LogConfigAPIError) { "Failure on getProfileOfPlayerId for playerId=$pid: ${it.message}" }
    }
    val userProfile = requireNotNull(result.getOrThrow()) {
        "getProfileOfPlayerId succeed but returned profile is null"
    }
    val socialRefreshOutput = if (pid == AdminData.PLAYER_ID) {
        SocialRefreshOutput.admin()
    } else {
        SocialRefreshOutput(
            myProfile = SocialProfile(
                userId = pid,
                displayName = userProfile.displayName,
                avatarUrl = userProfile.avatarUrl,
                lastOnline = userProfile.lastLogin,
                countryCode = userProfile.countryCode ?: "",
                userToken = token,
            ),
            friends = emptyList(),
            blocked = ""
        )
    }
    val encodedOutput = ProtoBuf.encodeToByteArray<SocialRefreshOutput>(socialRefreshOutput)
    logOutput(encodedOutput)
    call.respondBytes(encodedOutput.pioFraming())
}

===== C:\Users\Sulivan\Desktop\Projects\DeadZone-Private-Server\src\main\kotlin\api\handler\WriteError.kt =====
package dev.deadzone.api.handler
import dev.deadzone.api.message.utils.WriteErrorArgs
import dev.deadzone.api.message.utils.WriteErrorError
import dev.deadzone.api.utils.pioFraming
import dev.deadzone.utils.*
import io.ktor.server.request.*
import io.ktor.server.response.*
import io.ktor.server.routing.*
import io.ktor.utils.io.*
import kotlinx.serialization.ExperimentalSerializationApi
import kotlinx.serialization.decodeFromByteArray
import kotlinx.serialization.encodeToByteArray
import kotlinx.serialization.protobuf.ProtoBuf

@OptIn(ExperimentalSerializationApi::class)
suspend fun RoutingContext.writeError() {
    val writeErrorArgs = ProtoBuf.decodeFromByteArray<WriteErrorArgs>(
        call.receiveChannel().toByteArray()
    )
    logInput("\n" + writeErrorArgs)
    Logger.error(LogConfigWriteError) { writeErrorArgs.toString() }
    if (writeErrorArgs.details.contains("Load Never Completed", ignoreCase = true) ||
        writeErrorArgs.details.contains("Resource not found", ignoreCase = true) ||
        writeErrorArgs.details.contains("Resource load fail", ignoreCase = true) ||
        writeErrorArgs.details.contains("2036", ignoreCase = true) ||
        writeErrorArgs.details.contains("Stream error", ignoreCase = true)
    ) {
        Logger.error(LogConfigAssetsError) { writeErrorArgs.details }
    }
    val loadObjectsOutput = ProtoBuf.encodeToByteArray(WriteErrorError.dummy())
    call.respondBytes(loadObjectsOutput.pioFraming())
}

===== C:\Users\Sulivan\Desktop\Projects\DeadZone-Private-Server\src\main\kotlin\api\message\auth\AuthenticateArgs.kt =====
package dev.deadzone.api.message.auth

import dev.deadzone.api.message.utils.KeyValuePair
import kotlinx.serialization.Serializable

@Serializable
data class AuthenticateArgs(
    val gameId: String = "",
    val connectionId: String = "",
    val authenticationArguments: List<KeyValuePair> = emptyList(),
    val playerInsightSegments: List<String> = emptyList(),
    val clientAPI: String = "",
    val clientInfo: List<KeyValuePair> = emptyList(),
    val playCodes: List<String> = emptyList()
)

===== C:\Users\Sulivan\Desktop\Projects\DeadZone-Private-Server\src\main\kotlin\api\message\auth\AuthenticateOutput.kt =====
package dev.deadzone.api.message.auth

import dev.deadzone.API_SERVER_HOST
import dev.deadzone.api.message.social.PlayerInsightState
import dev.deadzone.core.data.AdminData
import kotlinx.serialization.Serializable

@Serializable
data class AuthenticateOutput(
    val token: String = "",
    val userId: String = "",
    val showBranding: Boolean = false,
    val gameFSRedirectMap: String = "",
    val playerInsightState: PlayerInsightState? = null,
    val startDialogs: List<AuthenticateStartDialog> = emptyList(),
    val isSocialNetworkUser: Boolean = false,
    val newPlayCodes: List<String> = emptyList(),
    val notificationClickPayload: String = "",
    val isInstalledByPublishingNetwork: Boolean = false,
    val deprecated1: List<String> = emptyList(),
    val apiSecurity: Int = 0, // ENUM: depends on enum definition
    val apiServerHosts: List<String> = emptyList()
) {
    companion object {
        fun admin(): AuthenticateOutput {
            return AuthenticateOutput(
                token = AdminData.TOKEN,
                userId = AdminData.PLAYER_ID,
                apiServerHosts = listOf(API_SERVER_HOST)
            )
        }
    }
}

===== C:\Users\Sulivan\Desktop\Projects\DeadZone-Private-Server\src\main\kotlin\api\message\auth\AuthenticateStartDialog.kt =====
package dev.deadzone.api.message.auth

import dev.deadzone.api.message.utils.KeyValuePair
import kotlinx.serialization.Serializable

@Serializable
data class AuthenticateStartDialog(
    val name: String = "",
    val arguments: List<KeyValuePair> = emptyList()
)

===== C:\Users\Sulivan\Desktop\Projects\DeadZone-Private-Server\src\main\kotlin\api\message\db\ArrayProperty.kt =====
package dev.deadzone.api.message.db

import kotlinx.serialization.Serializable

@Serializable
data class ArrayProperty(
    val index: Int = 0,
    val value: ValueObject = ValueObject()
)

===== C:\Users\Sulivan\Desktop\Projects\DeadZone-Private-Server\src\main\kotlin\api\message\db\BigDBObject.kt =====
package dev.deadzone.api.message.db

import kotlinx.serialization.Serializable

@Serializable
data class BigDBObject(
    val key: String = "",
    val version: String = "",
    val properties: List<ObjectProperty> = listOf(),
    val creator: UInt = 0u,
)

===== C:\Users\Sulivan\Desktop\Projects\DeadZone-Private-Server\src\main\kotlin\api\message\db\BigDBObjectId.kt =====
package dev.deadzone.api.message.db

import kotlinx.serialization.Serializable

@Serializable
data class BigDBObjectId(
    val table: String = "",
    val keys: List<String> = listOf()
)

===== C:\Users\Sulivan\Desktop\Projects\DeadZone-Private-Server\src\main\kotlin\api\message\db\LoadIndexRangeArgs.kt =====
package dev.deadzone.api.message.db

import kotlinx.serialization.Serializable

/**
 * Mirrors PlayerIO BigDB LoadIndexRange args:
 * - table: BigDB table name
 * - index: index name within the table
 * - startIndexValue: inclusive start of index (composite allowed)
 * - stopIndexValue: inclusive stop of index (composite allowed)
 * - limit: maximum number of objects to return
 */
@Serializable
data class LoadIndexRangeArgs(
    val table: String,
    val index: String,
    val startIndexValue: List<ValueObject> = emptyList(),
    val stopIndexValue: List<ValueObject> = emptyList(),
    val limit: Int = 0
)

===== C:\Users\Sulivan\Desktop\Projects\DeadZone-Private-Server\src\main\kotlin\api\message\db\LoadObjectsArgs.kt =====
package dev.deadzone.api.message.db

import kotlinx.serialization.Serializable

@Serializable
data class LoadObjectsArgs(
    val objectIds: List<BigDBObjectId> = listOf()
)

===== C:\Users\Sulivan\Desktop\Projects\DeadZone-Private-Server\src\main\kotlin\api\message\db\LoadObjectsOutput.kt =====
package dev.deadzone.api.message.db

import dev.deadzone.api.utils.BigDBConverter
import kotlinx.serialization.Serializable

@Serializable
data class LoadObjectsOutput(
    val objects: List<BigDBObject> = listOf()
) {
    companion object {
        inline fun <reified T : Any> fromData(obj: T): BigDBObject {
            return BigDBConverter.toBigDBObject(obj = obj)
        }
    }
}

===== C:\Users\Sulivan\Desktop\Projects\DeadZone-Private-Server\src\main\kotlin\api\message\db\ObjectProperty.kt =====
package dev.deadzone.api.message.db

import kotlinx.serialization.Serializable

@Serializable
data class ObjectProperty(
    val name: String = "",
    val value: ValueObject = ValueObject()
)

===== C:\Users\Sulivan\Desktop\Projects\DeadZone-Private-Server\src\main\kotlin\api\message\db\ValueObject.kt =====
package dev.deadzone.api.message.db

import kotlinx.serialization.Serializable

@Serializable
data class ValueObject(
    val valueType: ValueType = ValueType.STRING,
    val string: String = "",
    val int32: Int = 0,
    val uInt: UInt = 0u,
    val long: Long = 0L,
    val bool: Boolean = false,
    val float: Float = 0f,
    val double: Double = 0.0,
    val byteArray: ByteArray = byteArrayOf(),
    val dateTime: Long = 0L,
    val arrayProperties: List<ArrayProperty> = listOf(),
    val objectProperties: List<ObjectProperty> = listOf()
)

===== C:\Users\Sulivan\Desktop\Projects\DeadZone-Private-Server\src\main\kotlin\api\message\db\ValueType.kt =====
package dev.deadzone.api.message.db

import kotlinx.serialization.Serializable

@Serializable
enum class ValueType {
    STRING,
    INT32,
    UINT,
    LONG,
    BOOL,
    FLOAT,
    DOUBLE,
    BYTE_ARRAY,
    DATETIME,
    ARRAY,
    OBJECT
}

===== C:\Users\Sulivan\Desktop\Projects\DeadZone-Private-Server\src\main\kotlin\api\message\server\CreateJoinRoomArgs.kt =====
package dev.deadzone.api.message.client

import dev.deadzone.api.message.utils.KeyValuePair
import kotlinx.serialization.Serializable

@Serializable
data class CreateJoinRoomArgs(
    val roomId: String = "",
    val roomType: String = "",
    val visible: Boolean = false,
    val roomData: KeyValuePair = KeyValuePair(),
    val joinData: KeyValuePair = KeyValuePair(),
    val isDevRoom: Boolean = false,
)

===== C:\Users\Sulivan\Desktop\Projects\DeadZone-Private-Server\src\main\kotlin\api\message\server\CreateJoinRoomError.kt =====
package dev.deadzone.api.message.client

import kotlinx.serialization.Serializable

@Serializable
data class CreateJoinRoomError(
    val message: String = "",
    val errorCode: Int = 0,
) {
    fun dummy(): CreateJoinRoomError {
        return CreateJoinRoomError(
            message = "create-join-room-error-ex",
            errorCode = 42,
        )
    }
}

===== C:\Users\Sulivan\Desktop\Projects\DeadZone-Private-Server\src\main\kotlin\api\message\server\CreateJoinRoomOutput.kt =====
package dev.deadzone.api.message.client

import dev.deadzone.api.message.server.ServerEndpoint
import kotlinx.serialization.Serializable

@Serializable
data class CreateJoinRoomOutput(
    val roomId: String = "",
    val joinKey: String = "",
    val endpoints: ServerEndpoint,
) {
    companion object {
        fun defaultRoom(): CreateJoinRoomOutput {
            return CreateJoinRoomOutput(
                roomId = "defaultRoomId",
                joinKey = "defaultJoinKey",
                endpoints = ServerEndpoint.socketServer()
            )
        }
    }
}

===== C:\Users\Sulivan\Desktop\Projects\DeadZone-Private-Server\src\main\kotlin\api\message\server\ServerEndpoint.kt =====
package dev.deadzone.api.message.server

import dev.deadzone.SERVER_HOST
import dev.deadzone.SOCKET_SERVER_PORT
import kotlinx.serialization.Serializable

@Serializable
data class ServerEndpoint(
    val address: String = "",
    val port: Int = 0,
) {
    companion object {
        fun socketServer(): ServerEndpoint {
            return ServerEndpoint(
                address = SERVER_HOST,
                port = SOCKET_SERVER_PORT
            )
        }
    }
}

===== C:\Users\Sulivan\Desktop\Projects\DeadZone-Private-Server\src\main\kotlin\api\message\social\PlayerInsightState.kt =====
package dev.deadzone.api.message.social

import dev.deadzone.api.message.utils.KeyValuePair
import kotlinx.serialization.Serializable

@Serializable
data class PlayerInsightState(
    val playersOnline: Int = 0,
    val segments: List<KeyValuePair> = emptyList()
)

===== C:\Users\Sulivan\Desktop\Projects\DeadZone-Private-Server\src\main\kotlin\api\message\social\SocialProfile.kt =====
package dev.deadzone.api.message.social

import dev.deadzone.core.data.AdminData
import io.ktor.util.date.getTimeMillis
import kotlinx.serialization.Serializable

@Serializable
data class SocialProfile(
    val userId: String = "",
    val displayName: String = "",
    val avatarUrl: String = "",
    val lastOnline: Long = 0,
    val countryCode: String = "",
    val userToken: String = "",
) {
    companion object {
        fun admin(): SocialProfile {
            return SocialProfile(
                userId = AdminData.PLAYER_ID,
                displayName = AdminData.DISPLAY_NAME,
                avatarUrl = AdminData.AVATAR_URL,
                lastOnline = getTimeMillis() - (1000L * 2000),
                countryCode = AdminData.COUNTRY_CODE,
                userToken = AdminData.TOKEN,
            )
        }
    }
}

===== C:\Users\Sulivan\Desktop\Projects\DeadZone-Private-Server\src\main\kotlin\api\message\social\SocialRefreshOutput.kt =====
package dev.deadzone.api.message.social

import kotlinx.serialization.Serializable

@Serializable
data class SocialRefreshOutput(
    val myProfile: SocialProfile = SocialProfile(),
    val friends: List<SocialProfile> = emptyList(),
    val blocked: String = "",
) {
    companion object {
        fun admin(): SocialRefreshOutput {
            return SocialRefreshOutput(
                myProfile = SocialProfile.admin(),
                friends = listOf(SocialProfile.admin()),
                blocked = "No one"
            )
        }
    }
}

===== C:\Users\Sulivan\Desktop\Projects\DeadZone-Private-Server\src\main\kotlin\api\message\utils\KeyValuePair.kt =====
package dev.deadzone.api.message.utils

import kotlinx.serialization.Serializable

@Serializable
data class KeyValuePair(
    val key: String = "",
    val value: String = "",
) {
    companion object {
        fun dummy(): KeyValuePair {
            return KeyValuePair(
                key = "examplekey",
                value = "examplevalue",
            )
        }
    }
}

===== C:\Users\Sulivan\Desktop\Projects\DeadZone-Private-Server\src\main\kotlin\api\message\utils\TypicalPIOError.kt =====
package dev.deadzone.api.message.utils

import kotlinx.serialization.Serializable

@Serializable
data class TypicalPIOError(
    val message: String = "",
    val errorCode: Int = 0,
) {
    companion object {
        fun dummy(): TypicalPIOError {
            return TypicalPIOError(
                message = "A generic error example",
                errorCode = 42,
            )
        }
    }
}

===== C:\Users\Sulivan\Desktop\Projects\DeadZone-Private-Server\src\main\kotlin\api\message\utils\WriteErrorArgs.kt =====
package dev.deadzone.api.message.utils

import kotlinx.serialization.Serializable

@Serializable
data class WriteErrorArgs(
    val source: String = "",
    val error: String = "",
    val details: String = "",
    val stacktrace: String = "",
    val extraData: List<KeyValuePair> = listOf(),
)

===== C:\Users\Sulivan\Desktop\Projects\DeadZone-Private-Server\src\main\kotlin\api\message\utils\WriteErrorError.kt =====
package dev.deadzone.api.message.utils

import kotlinx.serialization.Serializable

@Serializable
data class WriteErrorError(
    val errorCode: Int = 0,
    val message: String = "",
) {
    companion object {
        fun dummy(): WriteErrorError {
            return WriteErrorError(
                errorCode = 42,
                message = "Write error, error"
            )
        }
    }
}

===== C:\Users\Sulivan\Desktop\Projects\DeadZone-Private-Server\src\main\kotlin\api\routes\ApiRoutes.kt =====
package dev.deadzone.api.routes

import dev.deadzone.api.handler.authenticate
import dev.deadzone.api.handler.createJoinRoom
import dev.deadzone.api.handler.loadObjects
import dev.deadzone.api.handler.loadIndexRange
import dev.deadzone.api.handler.socialRefresh
import dev.deadzone.api.handler.writeError
import dev.deadzone.context.ServerContext
import dev.deadzone.utils.LogConfigAPIError
import dev.deadzone.utils.Logger
import io.ktor.http.HttpStatusCode
import io.ktor.server.response.respond
import io.ktor.server.routing.Route
import io.ktor.server.routing.post

fun Route.apiRoutes(serverContext: ServerContext) {
    post("/api/{path}") {
        val path = call.parameters["path"] ?: return@post call.respond(HttpStatusCode.BadRequest)

        val playerToken = if (path != "13" && path != "50") {
            call.request.queryParameters["playertoken"]
                ?: call.request.headers["playertoken"]
                ?: return@post call.respond(HttpStatusCode.Unauthorized, "Missing playertoken")
        } else {
            null
        }

        when (path) {
            "13" -> authenticate(serverContext)
            "601" -> socialRefresh(serverContext, playerToken!!)
            "27" -> createJoinRoom()
            "50" -> writeError()
            "85" -> loadObjects(serverContext)
            "97" -> loadIndexRange()
            else -> {
                Logger.error(LogConfigAPIError) { "Unimplemented API route: $path" }
                call.respond(HttpStatusCode.NotFound, "Unimplemented API: $path")
            }
        }
    }
}

===== C:\Users\Sulivan\Desktop\Projects\DeadZone-Private-Server\src\main\kotlin\api\routes\AuthRoutes.kt =====
package dev.deadzone.api.routes

import dev.deadzone.context.ServerContext
import dev.deadzone.core.data.AdminData
import dev.deadzone.utils.Logger
import io.ktor.http.*
import io.ktor.server.request.*
import io.ktor.server.response.*
import io.ktor.server.routing.*

fun Route.authRoutes(serverContext: ServerContext) {
    post("/api/login") {
        val data = call.receive<Map<String, String>>()
        val username = data["username"]
        val password = data["password"]

        if (username == null || password == null) {
            call.respond(HttpStatusCode.BadRequest, mapOf("reason" to "Missing credentials"))
            return@post
        }

        if (username == AdminData.ADMIN_RESERVED_NAME) {
            if (serverContext.config.adminEnabled) {
                val session = serverContext.authProvider.adminLogin()
                if (session != null) {
                    call.respond(HttpStatusCode.OK, mapOf("playerId" to session.playerId, "token" to session.token))
                } else {
                    call.respond(
                        HttpStatusCode.InternalServerError,
                        mapOf("reason" to "unexpected error: admin account doesn't exist")
                    )
                }
            } else {
                call.respond(HttpStatusCode.Forbidden, mapOf("reason" to "admin account not enabled"))
            }
            return@post
        }

        val usernameExist = serverContext.authProvider.doesUserExist(username)
        if (usernameExist) {
            val loginSession = serverContext.authProvider.login(username, password)
            val passwordRight = loginSession != null
            if (passwordRight) {
                call.respond(
                    HttpStatusCode.OK,
                    mapOf("playerId" to loginSession.playerId, "token" to loginSession.token)
                )
            } else {
                call.respond(
                    HttpStatusCode.Unauthorized,
                    mapOf("reason" to "wrong password")
                )
            }
        } else {
            val session = serverContext.authProvider.register(username, password)
            call.respond(
                HttpStatusCode.OK,
                mapOf("playerId" to session.playerId, "token" to session.token)
            )
        }
    }

    get("/api/userexist") {
        val username = call.parameters["username"]
        if (username.isNullOrBlank()) {
            call.respondText("no", status = HttpStatusCode.BadRequest)
            return@get
        }

        if (username == AdminData.ADMIN_RESERVED_NAME) {
            if (serverContext.config.adminEnabled) {
                call.respondText("granted")
            } else {
                call.respondText("reserved")
            }
            return@get
        }

        try {
            val exists = serverContext.authProvider.doesUserExist(username)
            call.respondText(if (exists) "yes" else "no")
        } catch (e: Exception) {
            Logger.error { "Failed to check if user exists: $username, e.message:${e.message}" }
            call.respond(HttpStatusCode.InternalServerError, mapOf("reason" to "Database error"))
        }
    }

    get("/keepalive") {
        val token = call.parameters["token"] ?: return@get call.respond(HttpStatusCode.BadRequest, "missing token")
        if (serverContext.sessionManager.refresh(token)) {
            return@get call.respond(HttpStatusCode.OK)
        } else {
            return@get call.respond(HttpStatusCode.Unauthorized, "Session expired, please login again")
        }
    }
}

===== C:\Users\Sulivan\Desktop\Projects\DeadZone-Private-Server\src\main\kotlin\api\routes\CaseInsensitiveStaticResources.kt =====
package dev.deadzone.api.routes

import io.ktor.http.ContentType
import io.ktor.http.HttpStatusCode
import io.ktor.http.defaultForFileExtension
import io.ktor.server.request.path
import io.ktor.server.response.respond
import io.ktor.server.response.respondFile
import io.ktor.server.routing.Route
import io.ktor.server.routing.contentType
import io.ktor.server.routing.get
import java.io.File
import kotlin.io.extension

fun Route.caseInsensitiveStaticResources(baseUrl: String, rootFolder: File) {
    val fileMap = scanFileSystemResources(rootFolder)

    get("$baseUrl/{...}") {
        val rawPath = call.request.path().replace(Regex("/+"), "/")
        val relativePath = rawPath.removePrefix(baseUrl).trimStart('/')
        val lookupKey = "$baseUrl/${relativePath}".lowercase()

        val file = fileMap[lookupKey]
        if (file != null && file.exists()) {
            val contentType = ContentType.defaultForFileExtension(file.extension)
            return@get call.respondFile(file, configure = {
                contentType(contentType) {}
            })
        }

        call.respond(HttpStatusCode.NotFound)
    }
}

fun scanFileSystemResources(resourceRoot: File): Map<String, File> {
    val map = mutableMapOf<String, File>()

    resourceRoot.walkTopDown()
        .filter { it.isFile }
        .forEach { file ->
            val relativePath = file.relativeTo(resourceRoot).invariantSeparatorsPath
            val key = ("/$relativePath").lowercase()
            map[key] = file
        }

    return map
}

===== C:\Users\Sulivan\Desktop\Projects\DeadZone-Private-Server\src\main\kotlin\api\routes\DebugLogRoutes.kt =====
package dev.deadzone.api.routes

import dev.deadzone.utils.Logger
import dev.deadzone.websocket.WebsocketManager
import dev.deadzone.websocket.WsMessage
import io.ktor.http.*
import io.ktor.server.response.*
import io.ktor.server.routing.*
import io.ktor.server.websocket.*
import io.ktor.websocket.*
import kotlinx.serialization.json.Json
import java.io.File

fun Route.debugLogRoutes(wsManager: WebsocketManager) {
    get("/debuglog") {
        val file = File("static/debuglog.html")
        if (file.exists()) {
            call.respondFile(file)
        } else {
            call.respond(HttpStatusCode.NotFound, "debuglog.html not found")
        }
    }

    webSocket("/debuglog") {
        val clientId = call.parameters["clientId"]
        if (clientId == null) {
            close(CloseReason(CloseReason.Codes.CANNOT_ACCEPT, "Missing clientId"))
            return@webSocket
        }

        wsManager.addClient(clientId, this)

        try {
            for (frame in incoming) {
                if (frame is Frame.Text) {
                    val msg = frame.readText()
                    try {
                        val wsMessage = Json.decodeFromString<WsMessage>(msg)
                        if (wsMessage.type == "close") break
                        wsManager.handleMessage(this, wsMessage)
                    } catch (e: Exception) {
                        Logger.error { "Failed to parse WS message: $msg\n$e" }
                    }
                }
            }
        } catch (e: Exception) {
            Logger.error { "Error in websocket for client $this: $e" }
        } finally {
            wsManager.removeClient(clientId)
            Logger.info { "Client $this disconnected from websocket debug." }
        }
    }
}

===== C:\Users\Sulivan\Desktop\Projects\DeadZone-Private-Server\src\main\kotlin\api\routes\FileRoutes.kt =====
package dev.deadzone.api.routes

import io.ktor.http.*
import io.ktor.server.http.content.*
import io.ktor.server.response.*
import io.ktor.server.routing.*
import java.io.File

fun Route.fileRoutes() {
    get("/") {
        val indexFile = File("static/index.html")
        if (indexFile.exists()) {
            call.respondFile(indexFile)
        } else {
            call.respond(HttpStatusCode.NotFound)
        }
    }

    staticFiles("/game", File("static/game/"))
    staticFiles("/assets", File("static/assets"))
    staticFiles("/crossdomain.xml", File("static/crossdomain.xml"))
}

===== C:\Users\Sulivan\Desktop\Projects\DeadZone-Private-Server\src\main\kotlin\api\utils\BigDBConverter.kt =====
package dev.deadzone.api.utils

import dev.deadzone.api.message.db.ArrayProperty
import dev.deadzone.api.message.db.BigDBObject
import dev.deadzone.api.message.db.ObjectProperty
import dev.deadzone.api.message.db.ValueObject
import dev.deadzone.api.message.db.ValueType
import kotlin.reflect.KProperty1
import kotlin.reflect.KVisibility

object BigDBConverter {
    inline fun <reified T : Any> toBigDBObject(key: String = "", obj: T, creator: UInt = 0u): BigDBObject {
        val props = toObjectProperties(obj)
        return BigDBObject(
            key = key,
            version = "1",
            properties = props,
            creator = creator
        )
    }

    fun toValueObject(value: Any?, isDate: Boolean? = null): ValueObject {
        return when (value) {
            null -> ValueObject(valueType = ValueType.STRING, string = "")
            is String -> ValueObject(valueType = ValueType.STRING, string = value)
            is Int -> ValueObject(valueType = ValueType.INT32, int32 = value)
            is UInt -> ValueObject(valueType = ValueType.UINT, uInt = value)
            is Long -> {
                if (isDate == true) {
                    ValueObject(valueType = ValueType.DATETIME, dateTime = value)
                } else {
                    ValueObject(valueType = ValueType.LONG, long = value)
                }
            }
            is Boolean -> ValueObject(valueType = ValueType.BOOL, bool = value)
            is Float -> ValueObject(valueType = ValueType.FLOAT, float = value)
            is Double -> ValueObject(valueType = ValueType.DOUBLE, double = value)
            is ByteArray -> ValueObject(valueType = ValueType.BYTE_ARRAY, byteArray = value)
            is List<*> -> ValueObject(
                valueType = ValueType.ARRAY,
                arrayProperties = value.mapIndexed { idx, v ->
                    ArrayProperty(index = idx, value = toValueObject(v))
                }
            )

            is Map<*, *> -> {
                val props = value.entries.mapNotNull { (k, v) ->
                    k?.toString()?.let { ObjectProperty(it, toValueObject(v)) }
                }
                ValueObject(valueType = ValueType.OBJECT, objectProperties = props)
            }

            is Enum<*> -> ValueObject(valueType = ValueType.STRING, string = value.name)
            else -> {
                val props = toObjectProperties(value)
                ValueObject(valueType = ValueType.OBJECT, objectProperties = props)
            }
        }
    }

    fun toObjectProperties(obj: Any): List<ObjectProperty> {
        val reserved = setOf("key", "creator", "version")
        val knownDateKeys = setOf("nextDZBountyIssue", "lastLogout", "lastLogin", "prevLogin")

        return obj::class.members
            .filterIsInstance<KProperty1<Any, *>>()
            .filter { it.visibility == KVisibility.PUBLIC }
            .mapNotNull { prop ->
                val name = prop.name
                if (name in reserved) return@mapNotNull null
                val value = try {
                    prop.get(obj)
                } catch (_: Exception) {
                    null
                }

                if (value == null) return@mapNotNull null

                if (name in knownDateKeys) {
                    ObjectProperty(name, toValueObject(value, true))
                } else {
                    ObjectProperty(name, toValueObject(value))
                }
            }
    }
}

===== C:\Users\Sulivan\Desktop\Projects\DeadZone-Private-Server\src\main\kotlin\api\utils\PIOFraming.kt =====
package dev.deadzone.api.utils

/**
 * Adds a PlayerIO framing prefix to the byte array.
 *
 * This is required by the PlayerIO API message convention, which expects each request and response
 * to be prefixed with two specific bytes: `0x00` and `0x01`.
 *
 * @receiver The original unframed [ByteArray] representing a protocol buffer message.
 * @return A new [ByteArray] with `0x00` and `0x01` prepended.
 */
fun ByteArray.pioFraming(): ByteArray {
    return byteArrayOf(0, 1) + this
}

===== C:\Users\Sulivan\Desktop\Projects\DeadZone-Private-Server\src\main\kotlin\context\GlobalContext.kt =====
package dev.deadzone.context

import dev.deadzone.core.data.GameDefinitions
import kotlinx.serialization.json.Json

/**
 * Singleton object that holds the server's global context.
 * It is initialized on server startup.
 *
 * @property json pre-configured JSON serializer/deserializer.
 * @property gameDefinitions contains game definitions from XML resources.
 */
object GlobalContext {
    lateinit var json: Json
        private set
    lateinit var gameDefinitions: GameDefinitions
        private set

    fun init(json: Json, gameDefinitions: GameDefinitions) {
        this.json = json
        this.gameDefinitions = gameDefinitions
    }
}

===== C:\Users\Sulivan\Desktop\Projects\DeadZone-Private-Server\src\main\kotlin\context\PlayerContext.kt =====
package dev.deadzone.context

import dev.deadzone.core.compound.CompoundService
import dev.deadzone.core.items.InventoryService
import dev.deadzone.core.metadata.PlayerObjectsMetadataService
import core.survivor.SurvivorService
import dev.deadzone.data.collection.PlayerAccount
import dev.deadzone.socket.core.Connection

/**
 * A player-scoped data holder. This includes player's socket connection, metadata,
 * and the player's game data, which isn't directly, but found in various [PlayerService].
 *
 * A PlayerContext, including its services, is initialized in the [JoinHandler].
 */
data class PlayerContext(
    val playerId: String,
    val connection: Connection,
    val onlineSince: Long,
    val playerAccount: PlayerAccount,
    val services: PlayerServices
)

data class PlayerServices(
    val survivor: SurvivorService,
    val compound: CompoundService,
    val inventory: InventoryService,
    val playerObjectMetadata: PlayerObjectsMetadataService
)

===== C:\Users\Sulivan\Desktop\Projects\DeadZone-Private-Server\src\main\kotlin\context\PlayerContextTracker.kt =====
package dev.deadzone.context

import dev.deadzone.core.compound.CompoundRepositoryMaria
import dev.deadzone.core.compound.CompoundService
import dev.deadzone.core.items.InventoryRepositoryMaria
import dev.deadzone.core.items.InventoryService
import dev.deadzone.core.metadata.PlayerObjectsMetadataRepositoryMaria
import dev.deadzone.core.metadata.PlayerObjectsMetadataService
import dev.deadzone.core.survivor.SurvivorRepositoryMaria
import core.survivor.SurvivorService
import dev.deadzone.data.db.BigDB
import dev.deadzone.socket.core.Connection
import io.ktor.util.date.getTimeMillis
import org.jetbrains.exposed.sql.Database
import java.util.concurrent.ConcurrentHashMap

class PlayerContextTracker {
    val players = ConcurrentHashMap<String, PlayerContext>()
    
    suspend fun createContext(playerId: String, connection: Connection, db: BigDB) {
        val playerAccount = requireNotNull(db.loadPlayerAccount(playerId)) { 
            "Missing PlayerAccount for playerid=$playerId" 
        }
        
        val context = PlayerContext(
            playerId = playerId,
            connection = connection,
            onlineSince = getTimeMillis(),
            playerAccount = playerAccount,
            services = initializeServices(playerId, db)
        )
        players[playerId] = context
    }
    
    private suspend fun initializeServices(playerId: String, db: BigDB): PlayerServices {
        val database = (db as dev.deadzone.data.db.BigDBMariaImpl).database
        
        requireNotNull(db.loadPlayerAccount(playerId)) { 
            "Weird, PlayerAccount for playerId=$playerId is null" 
        }
        
        val playerObjects = requireNotNull(db.loadPlayerObjects(playerId)) { 
            "Weird, PlayerObjects for playerId=$playerId is null" 
        }
        
        val survivor = SurvivorService(
            survivorLeaderId = playerObjects.playerSurvivor!!,
            survivorRepository = SurvivorRepositoryMaria(database)
        )
        
        val inventory = InventoryService(inventoryRepository = InventoryRepositoryMaria())
        val compound = CompoundService(compoundRepository = CompoundRepositoryMaria(database))
        val playerObjectMetadata = PlayerObjectsMetadataService(
            playerObjectsMetadataRepository = PlayerObjectsMetadataRepositoryMaria(database)
        )
        
        survivor.init(playerId)
        inventory.init(playerId)
        compound.init(playerId)
        playerObjectMetadata.init(playerId)
        
        return PlayerServices(
            survivor = survivor,
            compound = compound,
            inventory = inventory,
            playerObjectMetadata = playerObjectMetadata
        )
    }
    
    fun getContext(playerId: String): PlayerContext? {
        return players[playerId]
    }
    
    fun removePlayer(playerId: String) {
        players.remove(playerId)
    }
    
    fun shutdown() {
        players.values.forEach {
            it.connection.shutdown()
        }
        players.clear()
    }
}

===== C:\Users\Sulivan\Desktop\Projects\DeadZone-Private-Server\src\main\kotlin\context\ServerContext.kt =====
package dev.deadzone.context

import dev.deadzone.core.auth.AuthProvider
import dev.deadzone.core.auth.SessionManager
import dev.deadzone.data.db.BigDB
import dev.deadzone.socket.core.OnlinePlayerRegistry
import dev.deadzone.socket.handler.save.SaveSubHandler
import dev.deadzone.socket.tasks.ServerTaskDispatcher
import dev.deadzone.user.PlayerAccountRepository

data class ServerContext(
    val db: BigDB,
    val playerAccountRepository: PlayerAccountRepository,
    val sessionManager: SessionManager,
    val onlinePlayerRegistry: OnlinePlayerRegistry,
    val authProvider: AuthProvider,
    val taskDispatcher: ServerTaskDispatcher,
    val playerContextTracker: PlayerContextTracker,
    val saveHandlers: List<SaveSubHandler>,
    val config: ServerConfig,
)

fun ServerContext.getPlayerContextOrNull(playerId: String): PlayerContext? =
    playerContextTracker.getContext(playerId)

fun ServerContext.requirePlayerContext(playerId: String): PlayerContext =
    getPlayerContextOrNull(playerId)
        ?: error("PlayerContext not found for pid=$playerId")

data class ServerConfig(
    val adminEnabled: Boolean,
    val useMaria: Boolean,
    val mariaUrl: String,
    val mariaUser: String,
    val mariaPassword: String,
    val isProd: Boolean,
)

===== C:\Users\Sulivan\Desktop\Projects\DeadZone-Private-Server\src\main\kotlin\core\LazyDataUpdater.kt =====
package core

import dev.deadzone.core.model.game.data.*
import io.ktor.util.date.*
import kotlin.math.min
import kotlin.time.Duration.Companion.milliseconds

/**
 * Lazily update player's data based on timer or lastLogin
 */
object LazyDataUpdater {
    fun depleteResources(lastLogin: Long, res: GameResources): GameResources {
        val minutesPassed = min(0, (getTimeMillis() - lastLogin).milliseconds.inWholeMinutes)
        val depletionRate = 0.02

        val depleted = depletionRate * minutesPassed

        return res.copy(
            food = min(1, res.food - (depleted).toInt()),
            water = min(1, res.water - (depleted).toInt())
        )
    }

    @Suppress("CAST_NEVER_SUCCEEDS")
    fun updateBuildingTimers(buildings: List<BuildingLike>): List<BuildingLike> {
        return buildings.map { bld ->
            val upgradeDone = bld.upgrade?.hasEnded() ?: false
            val repairDone = bld.repair?.hasEnded() ?: false

            when (bld) {
                is Building -> when {
                    upgradeDone -> {
                        val level = (bld.upgrade?.data?.get("level") as? Int ?: 1)
                        bld.copy(level = level, upgrade = null)
                    }
                    repairDone -> bld.copy(repair = null)
                    else -> bld
                }
                is JunkBuilding -> when {
                    upgradeDone -> {
                        val level = (bld.upgrade?.data?.get("level") as? Int ?: 1)
                        bld.copy(level = level, upgrade = null)
                    }
                    repairDone -> bld.copy(repair = null)
                    else -> bld
                }
            }
        }
    }
}

===== C:\Users\Sulivan\Desktop\Projects\DeadZone-Private-Server\src\main\kotlin\core\LoginStateBuilder.kt =====
package core

import dev.deadzone.context.GlobalContext
import dev.deadzone.context.ServerContext
import dev.deadzone.core.data.PlayerLoginState

/**
 * Per-player dynamic updates.
 *
 * Assumption:
 *   Some fields come from PlayerObjects and represent values that change over time.
 *   When a player logs out, their data is stored in the database, but certain values
 *   (e.g., resources) can change while they‚Äôre offline due to natural depletion or
 *   external events such as PvP attacks.
 *
 *   Therefore, when the player logs in, we must recalculate these values to reflect
 *   the time elapsed since their last session. The updated values should then be
 *   written back to the database before proceeding, since API 85 (the load request)
 *   will immediately send this data to the client.
 */
object LoginStateBuilder {
    /**
     * Build login state for the given [pid], returning the raw JSON string.
     */
    fun build(serverContext: ServerContext, pid: String): String {
        val context = serverContext.playerContextTracker.getContext(playerId = pid)!!

        return GlobalContext.json.encodeToString(
            PlayerLoginState(
                settings = emptyMap(),
                news = emptyMap(),
                sales = emptyList(),
                allianceWinnings = emptyMap(),
                recentPVPList = emptyList(),

                invsize = 500, // the default inventory size
                upgrades = "",

                allianceId = null,
                allianceTag = null,

                longSession = false,

                leveledUp = false,

                promos = emptyList(),
                promoSale = null,
                dealItem = null,

                leaderResets = 0,
                unequipItemBinds = emptyList(),

                globalStats = emptyMap(),

                resources = context.services.compound.getResources(),
                survivors = context.services.survivor.getAllSurvivors(),
                tasks = null,
                missions = null,
                bountyCap = null,
                bountyCapTimestamp = null,
                research = null
            )
        )
    }
}

===== C:\Users\Sulivan\Desktop\Projects\DeadZone-Private-Server\src\main\kotlin\core\PlayerService.kt =====
package core

/**
 * Represents a player-scoped game service.
 *
 * This service manages data and domain logic related to a specific game domain for a particular player,
 * such as survivors, inventory, or loot. It is not responsible for low-level database operations,
 * nor should it handle player identification on each operations. Instead, it stores domain data and provides
 * operations to callers.
 *
 * Typically, the service initializes local data through the [init] method.
 * It receives a repository specific to the domain (e.g., [SurvivorRepository]) to delegates the
 * low-level database work. Each repository is preferred to be wrapped in try-catch
 * and always return a Result<T> type. This is to ensure consistency on error handling across repository.
 *
 * Repository may define CRUD operations only, letting the service define the more complex operations.
 *
 * See examples: [SurvivorService]
 */
interface PlayerService {
    /**
     * Initializes the service for the specified [playerId].
     *
     * This method should be used to load or prepare all data related to the player
     * in this service's domain.
     *
     * @return An empty result just for denoting success or failure.
     */
    suspend fun init(playerId: String): Result<Unit>

    /**
     * Closes the service for the specified [playerId].
     *
     * This method is called when the player logs off or disconnects.
     * It should synchronize any in-memory state with persistent storage
     * to ensure no progress or transient data is lost.
     *
     * For example, [CompoundService] maintains additional timing data to enable lazy
     * calculation of building resource production without storing additional time data
     * in the DB and doing more query. This also avoid the need of server running
     * an increment resource task on each production building.
     *
     * However, without a server-initiated task, the DB wouldn't keep the latest data at all time.
     * The `close` method would update fields such as `resourceValue` on production buildings,
     * to reflect the final accumulated resources since the last time resources was collected.
     *
     * @return An empty result just for denoting success or failure.
     */
    suspend fun close(playerId: String): Result<Unit>
}

===== C:\Users\Sulivan\Desktop\Projects\DeadZone-Private-Server\src\main\kotlin\core\compound\CompoundRepository.kt =====
package dev.deadzone.core.compound

import dev.deadzone.core.model.game.data.BuildingLike
import dev.deadzone.core.model.game.data.GameResources

interface CompoundRepository {
    suspend fun getGameResources(playerId: String): Result<GameResources>
    suspend fun updateGameResources(
        playerId: String,
        newResources: GameResources
    ): Result<Unit>

    suspend fun createBuilding(
        playerId: String,
        newBuilding: BuildingLike
    ): Result<Unit>
    suspend fun getBuildings(playerId: String): Result<List<BuildingLike>>
    suspend fun updateBuilding(
        playerId: String,
        bldId: String,
        updatedBuilding: BuildingLike
    ): Result<Unit>
    suspend fun deleteBuilding(playerId: String, bldId: String): Result<Unit>
}

===== C:\Users\Sulivan\Desktop\Projects\DeadZone-Private-Server\src\main\kotlin\core\compound\CompoundRepositoryMaria.kt =====
package dev.deadzone.core.compound

import dev.deadzone.core.model.game.data.BuildingLike
import dev.deadzone.core.model.game.data.GameResources
import dev.deadzone.core.model.game.data.id
import dev.deadzone.data.collection.PlayerObjects
import dev.deadzone.data.db.PlayerObjectsTable
import kotlinx.serialization.json.Json
import org.jetbrains.exposed.sql.*
import org.jetbrains.exposed.sql.SqlExpressionBuilder.eq
import org.jetbrains.exposed.sql.transactions.transaction

class CompoundRepositoryMaria(private val database: Database) : CompoundRepository {
    private val json = Json { ignoreUnknownKeys = true }

    override suspend fun getGameResources(playerId: String): Result<GameResources> {
        return runCatching {
            transaction(database) {
                PlayerObjectsTable.select { PlayerObjectsTable.playerId eq playerId }
                    .singleOrNull()?.let { row ->
                        json.decodeFromString(PlayerObjects.serializer(), row[PlayerObjectsTable.dataJson]).resources
                    } ?: throw NoSuchElementException("No player found with id=$playerId")
            }
        }
    }

    override suspend fun updateGameResources(playerId: String, newResources: GameResources): Result<Unit> {
        return runCatching {
            transaction(database) {
                val currentData = PlayerObjectsTable.select { PlayerObjectsTable.playerId eq playerId }
                    .singleOrNull()?.let { row ->
                        json.decodeFromString(PlayerObjects.serializer(), row[PlayerObjectsTable.dataJson])
                    } ?: throw NoSuchElementException("No player found with id=$playerId")
                val updatedData = currentData.copy(resources = newResources)
                PlayerObjectsTable.update({ PlayerObjectsTable.playerId eq playerId }) {
                    it[dataJson] = json.encodeToString(PlayerObjects.serializer(), updatedData)
                }
            }
        }
    }

    override suspend fun createBuilding(playerId: String, newBuilding: BuildingLike): Result<Unit> {
        return runCatching {
            transaction(database) {
                val currentData = PlayerObjectsTable.select { PlayerObjectsTable.playerId eq playerId }
                    .singleOrNull()?.let { row ->
                        json.decodeFromString(PlayerObjects.serializer(), row[PlayerObjectsTable.dataJson])
                    } ?: throw NoSuchElementException("No player found with id=$playerId")
                val updatedBuildings = currentData.buildings.toMutableList().apply { add(newBuilding) }
                val updatedData = currentData.copy(buildings = updatedBuildings)
                PlayerObjectsTable.update({ PlayerObjectsTable.playerId eq playerId }) {
                    it[dataJson] = json.encodeToString(PlayerObjects.serializer(), updatedData)
                }
            }
        }
    }

    override suspend fun getBuildings(playerId: String): Result<List<BuildingLike>> {
        return runCatching {
            transaction(database) {
                PlayerObjectsTable.select { PlayerObjectsTable.playerId eq playerId }
                    .singleOrNull()?.let { row ->
                        json.decodeFromString(PlayerObjects.serializer(), row[PlayerObjectsTable.dataJson]).buildings
                    } ?: throw NoSuchElementException("No player found with id=$playerId")
            }
        }
    }

    override suspend fun updateBuilding(playerId: String, bldId: String, updatedBuilding: BuildingLike): Result<Unit> {
        return runCatching {
            transaction(database) {
                val currentData = PlayerObjectsTable.select { PlayerObjectsTable.playerId eq playerId }
                    .singleOrNull()?.let { row ->
                        json.decodeFromString(PlayerObjects.serializer(), row[PlayerObjectsTable.dataJson])
                    } ?: throw NoSuchElementException("No player found with id=$playerId")
                val updatedBuildings = currentData.buildings.toMutableList()
                val buildingIndex = updatedBuildings.indexOfFirst { it.id == bldId }
                if (buildingIndex == -1) {
                    throw NoSuchElementException("No building found for bldId=$bldId on playerId=$playerId")
                }
                updatedBuildings[buildingIndex] = updatedBuilding
                val updatedData = currentData.copy(buildings = updatedBuildings)
                PlayerObjectsTable.update({ PlayerObjectsTable.playerId eq playerId }) {
                    it[dataJson] = json.encodeToString(PlayerObjects.serializer(), updatedData)
                }
            }
        }
    }

    override suspend fun deleteBuilding(playerId: String, bldId: String): Result<Unit> {
        return runCatching {
            transaction(database) {
                val currentData = PlayerObjectsTable.select { PlayerObjectsTable.playerId eq playerId }
                    .singleOrNull()?.let { row ->
                        json.decodeFromString(PlayerObjects.serializer(), row[PlayerObjectsTable.dataJson])
                    } ?: throw NoSuchElementException("No player found with id=$playerId")
                val updatedBuildings = currentData.buildings.toMutableList()
                val removed = updatedBuildings.removeIf { it.id == bldId }
                if (!removed) {
                    throw NoSuchElementException("No building found for bldId=$bldId on playerId=$playerId")
                }
                val updatedData = currentData.copy(buildings = updatedBuildings)
                PlayerObjectsTable.update({ PlayerObjectsTable.playerId eq playerId }) {
                    it[dataJson] = json.encodeToString(PlayerObjects.serializer(), updatedData)
                }
            }
        }
    }

    suspend fun getPlayerObjects(playerId: String): Result<PlayerObjects> = runCatching {
        transaction(database) {
            PlayerObjectsTable.select { PlayerObjectsTable.playerId eq playerId }
                .singleOrNull()?.let { row ->
                    json.decodeFromString(PlayerObjects.serializer(), row[PlayerObjectsTable.dataJson])
                } ?: throw NoSuchElementException("No player found with id=$playerId")
        }
    }

    suspend fun updatePlayerObjects(playerId: String, playerObjects: PlayerObjects): Result<Unit> = runCatching {
        transaction(database) {
            PlayerObjectsTable.update({ PlayerObjectsTable.playerId eq playerId }) {
                it[dataJson] = json.encodeToString(PlayerObjects.serializer(), playerObjects)
            }
        }
    }
}

===== C:\Users\Sulivan\Desktop\Projects\DeadZone-Private-Server\src\main\kotlin\core\compound\CompoundService.kt =====
package dev.deadzone.core.compound

import core.PlayerService
import dev.deadzone.core.model.game.data.*
import dev.deadzone.utils.LogConfigSocketError
import dev.deadzone.utils.Logger
import io.ktor.util.date.*
import kotlin.time.Duration
import kotlin.time.Duration.Companion.seconds

class CompoundService(private val compoundRepository: CompoundRepository) : PlayerService {
    private lateinit var resources: GameResources
    private val buildings = mutableListOf<BuildingLike>()
    private val lastResourceValueUpdated = mutableMapOf<String, Long>()
    private lateinit var playerId: String

    fun getResources() = resources

    fun getIndexOfBuilding(bldId: String): Result<Int> {
        val idx = buildings.indexOfFirst { it.id == bldId }
        return if (idx == -1) {
            Logger.error(LogConfigSocketError) { "Building bldId=$bldId not found for playerId=$playerId" }
            Result.failure(NoSuchElementException("Building bldId=$bldId not found for playerId=$playerId"))
        } else {
            Result.success(idx)
        }
    }

    suspend fun updateBuilding(
        bldId: String,
        updateAction: suspend (BuildingLike) -> BuildingLike
    ): Result<Unit> {
        return try {
            val idxResult = getIndexOfBuilding(bldId)
            var idx: Int? = null
            idxResult.onSuccess { index ->
                idx = index
            }
            idxResult.onFailure { return Result.failure(it) }
            val update = updateAction(buildings[idx!!])
            val result = compoundRepository.updateBuilding(playerId, bldId, update)
            result.onFailure {
                Logger.error(LogConfigSocketError) { "Error on updateBuilding: ${it.message}" }
            }
            result.onSuccess {
                buildings[idx] = update
            }
            result
        } catch (e: Exception) {
            Logger.error(LogConfigSocketError) { "Failed to update building bldId=$bldId for playerId=$playerId: ${e.message}" }
            Result.failure(e)
        }
    }

    suspend fun createBuilding(createAction: suspend () -> (BuildingLike)) {
        val create = createAction()
        val result = compoundRepository.createBuilding(playerId, create)
        result.onFailure {
            Logger.error(LogConfigSocketError) { "Error on createBuilding: ${it.message}" }
        }
        result.onSuccess {
            this.buildings.add(create)
        }
    }

    suspend fun deleteBuilding(bldId: String): Result<Unit> {
        return try {
            val result = compoundRepository.deleteBuilding(playerId, bldId)
            result.onFailure {
                Logger.error(LogConfigSocketError) { "Error on deleteBuilding: ${it.message}" }
            }
            result.onSuccess {
                this.buildings.removeIf { it.id == bldId }
            }
            result
        } catch (e: Exception) {
            Logger.error(LogConfigSocketError) { "Failed to delete building bldId=$bldId for playerId=$playerId: ${e.message}" }
            Result.failure(e)
        }
    }

    suspend fun cancelBuilding(bldId: String) {
        val result = compoundRepository.deleteBuilding(playerId, bldId)
        result.onFailure {
            Logger.error(LogConfigSocketError) { "Error on cancelBuilding: ${it.message}" }
        }
        result.onSuccess {
            buildings.removeIf { it.id == bldId }
        }
    }

    suspend fun collectBuilding(bldId: String): Result<GameResources> {
        return try {
            val lastUpdate = lastResourceValueUpdated[bldId]
                ?: return Result.failure(NoSuchElementException("Building bldId=$bldId is not categorized as production buildings"))

            val collectedAmount = calculateResource(lastUpdate.seconds)
            lastResourceValueUpdated[bldId] = getTimeMillis()

            lateinit var prod: String
            val updateResult = updateBuilding(bldId) { oldBld ->
                prod = "wood" // Lookup to GameDefinitions, what does the building produce in 'prod' element
                oldBld.copy(resourceValue = 0.0)
            }
            updateResult.onFailure { return Result.failure(it) }

            val res = when (prod) {
                "wood" -> GameResources(wood = collectedAmount.toInt())
                "metal" -> GameResources(metal = collectedAmount.toInt())
                "cloth" -> GameResources(cloth = collectedAmount.toInt())
                "food" -> GameResources(food = collectedAmount.toInt())
                "water" -> GameResources(water = collectedAmount.toInt())
                "cash" -> GameResources(cash = collectedAmount.toInt())
                "ammunition" -> GameResources(ammunition = collectedAmount.toInt())
                else -> {
                    return Result.failure(IllegalArgumentException("Error during collectBuilding, type $prod doesn't exist"))
                }
            }
            Result.success(res)
        } catch (e: Exception) {
            Logger.error(LogConfigSocketError) { "Failed to collect building bldId=$bldId for playerId=$playerId: ${e.message}" }
            Result.failure(e)
        }
    }

    fun calculateResource(durationSec: Duration): Double {
        val productionRate = 4
        return 10.0 + (productionRate * durationSec.inWholeMinutes)
    }

    override suspend fun init(playerId: String): Result<Unit> {
        return runCatching {
            this.playerId = playerId
            val _resources = compoundRepository.getGameResources(playerId).getOrThrow()
            val _buildings = compoundRepository.getBuildings(playerId).getOrThrow()
            this.resources = _resources
            buildings.addAll(_buildings)

            val now = getTimeMillis()

            for (bldLike in buildings) {
                if (isProductionBuilding(bldLike.type)) {
                    lastResourceValueUpdated[bldLike.id] = now
                }
            }
            Result.success(Unit)
        }.getOrElse { e ->
            Logger.error(LogConfigSocketError) { "Failed to initialize CompoundService for playerId=$playerId: ${e.message}" }
            Result.failure(e)
        }
    }

    override suspend fun close(playerId: String): Result<Unit> {
        return runCatching {
            val now = getTimeMillis()

            for (bldLike in buildings) {
                val lastUpdate = lastResourceValueUpdated[bldLike.id] ?: continue
                val updateResult = updateBuilding(bldLike.id) { oldBld ->
                    oldBld.copy(resourceValue = calculateResource((now - lastUpdate).seconds))
                }
                updateResult.onFailure {
                    Logger.error(LogConfigSocketError) { "Failed to update building ${bldLike.id} during close for playerId=$playerId: ${it.message}" }
                }
            }
            Result.success(Unit)
        }.getOrElse { e ->
            Logger.error(LogConfigSocketError) { "Failed to close CompoundService for playerId=$playerId: ${e.message}" }
            Result.failure(e)
        }
    }

    private fun isProductionBuilding(idInXML: String): Boolean {
        return idInXML.contains("resource")
    }
}

===== C:\Users\Sulivan\Desktop\Projects\DeadZone-Private-Server\src\main\kotlin\core\compound\model\Building.kt =====
package dev.deadzone.core.model.game.data

import dev.deadzone.core.items.model.Item
import dev.deadzone.utils.LogConfigSocketToClient
import dev.deadzone.utils.Logger
import dev.deadzone.utils.UUID
import kotlinx.serialization.DeserializationStrategy
import kotlinx.serialization.ExperimentalSerializationApi
import kotlinx.serialization.Serializable
import kotlinx.serialization.SerializationException
import kotlinx.serialization.json.*

@OptIn(ExperimentalSerializationApi::class)
@Serializable(with = BuildingLikeSerializer::class)
@JsonClassDiscriminator("_t")
sealed class BuildingLike

val BuildingLike.id: String
    get() = when (this) {
        is Building -> this.id
        is JunkBuilding -> this.id
    }

val BuildingLike.type: String
    get() = when (this) {
        is Building -> this.type
        is JunkBuilding -> this.type
    }

val BuildingLike.level: Int
    get() = when(this) {
        is Building -> this.level
        is JunkBuilding -> this.level
    }

val BuildingLike.upgrade: TimerData?
    get() = when (this) {
        is Building -> this.upgrade
        is JunkBuilding -> this.upgrade
    }

val BuildingLike.repair: TimerData?
    get() = when (this) {
        is Building -> this.repair
        is JunkBuilding -> this.repair
    }

fun BuildingLike.copy(
    id: String? = null,
    name: String? = null,
    type: String? = null,
    level: Int? = null,
    rotation: Int? = null,
    tx: Int? = null,
    ty: Int? = null,
    destroyed: Boolean? = null,
    resourceValue: Double? = null,
    upgrade: TimerData? = null,
    repair: TimerData? = null,
    items: List<Item>? = null,
    pos: String? = null,
    rot: String? = null
): BuildingLike = when (this) {
    is Building -> this.copy(
        id = id ?: this.id,
        name = name ?: this.name,
        type = type ?: this.type,
        level = level ?: this.level,
        rotation = rotation ?: this.rotation,
        tx = tx ?: this.tx,
        ty = ty ?: this.ty,
        destroyed = destroyed ?: this.destroyed,
        resourceValue = resourceValue ?: this.resourceValue,
        upgrade = upgrade ?: this.upgrade,
        repair = repair ?: this.repair
    )

    is JunkBuilding -> this.copy(
        id = id ?: this.id,
        name = name ?: this.name,
        type = type ?: this.type,
        level = level ?: this.level,
        rotation = rotation ?: this.rotation,
        tx = tx ?: this.tx,
        ty = ty ?: this.ty,
        destroyed = destroyed ?: this.destroyed,
        resourceValue = resourceValue ?: this.resourceValue,
        upgrade = upgrade ?: this.upgrade,
        repair = repair ?: this.repair,
        items = items ?: this.items,
        pos = pos ?: this.pos,
        rot = rot ?: this.rot
    )
}


@Serializable
data class Building(
    val id: String = UUID.new(),    // building's unique ID
    val name: String? = null,
    val type: String,  // building's ID in buildings.xml, not to be confused with type in XML
    val level: Int = 0,
    val rotation: Int = 0,
    val tx: Int = 0,
    val ty: Int = 0,
    val destroyed: Boolean = false,
    val resourceValue: Double = 0.0,
    val upgrade: TimerData? = null,
    val repair: TimerData? = null
) : BuildingLike()

object BuildingLikeSerializer : JsonContentPolymorphicSerializer<BuildingLike>(BuildingLike::class) {
    override fun selectDeserializer(element: JsonElement): DeserializationStrategy<BuildingLike> {
        return when (val discriminator = element.jsonObject["_t"]?.jsonPrimitive?.contentOrNull) {
            "dev.deadzone.core.model.game.data.Building" -> Building.serializer()
            "dev.deadzone.core.model.game.data.JunkBuilding" -> JunkBuilding.serializer()
            null -> {
                val obj = element.jsonObject
                return when {
                    obj.containsKey("items") && obj.containsKey("pos") && obj.containsKey("rot") ->
                        JunkBuilding.serializer()

                    else ->
                        Building.serializer()
                }
            }

            else -> {
                Logger.error(
                    LogConfigSocketToClient,
                    forceLogFull = true
                ) { "Error during serialization of BuildingLike type: $element" }
                throw SerializationException("Unknown type: '$discriminator'")
            }
        }
    }
}

===== C:\Users\Sulivan\Desktop\Projects\DeadZone-Private-Server\src\main\kotlin\core\compound\model\BuildingCollection.kt =====
package dev.deadzone.core.model.game.data

import kotlinx.serialization.Serializable

@Serializable
data class BuildingCollection(
    val list: List<BuildingLike> = listOf()
) {
    companion object {
        fun starterBase(): List<BuildingLike> {
            val junks = listOf(
                JunkBuilding(name = "junk", type = "junk-tutorial", pos = "-650,950,-1", rot = "0,0,0"),
                JunkBuilding(name = "junk1", type = "junk-pile-corner", pos = "-927,-1026,0", rot = "0,0,90"),
                JunkBuilding(name = "junk2", type = "junk-drums", pos = "-974,-323,0", rot = "0,0,90"),
                JunkBuilding(name = "junk3", type = "junk-machinery-small", pos = "1150,1150,0", rot = "0,0,0"),
                JunkBuilding(name = "junk4", type = "junk-pile-corner", pos = "-950,1150,0", rot = "0,0,0"),
                JunkBuilding(name = "junk5", type = "junk-pile-mid", pos = "-950,-639,0", rot = "0,0,180"),
                JunkBuilding(name = "junk6", type = "junk-machinery-large", pos = "-1050,150,0", rot = "0,0,270"),
                JunkBuilding(name = "junk7", type = "junk-pallets", pos = "-850,550,0", rot = "0,0,0"),
                JunkBuilding(name = "junk9", type = "junk-drums", pos = "-550,1150,0", rot = "0,0,0"),
                JunkBuilding(name = "junk11", type = "junk-drums", pos = "462,-1116,0", rot = "0,0,220"),
                JunkBuilding(name = "junk12", type = "junk-pile-small", pos = "950,-550,-1", rot = "0,0,180"),
                JunkBuilding(name = "junk14", type = "junk-pile-mid", pos = "650,-950,0", rot = "0,0,270"),
                JunkBuilding(name = "junk15", type = "junk-pallets", pos = "1048,-350,0", rot = "0,0,155"),
                JunkBuilding(name = "junk16", type = "junk-pile-mid", pos = "950,850,0", rot = "0,0,0"),
                JunkBuilding(name = "junk17", type = "junk-pallets", pos = "151,1161,0", rot = "0,0,270"),
                JunkBuilding(name = "junk20", type = "junk-machinery-small", pos = "1060,-1196,0", rot = "0,0,270"),
                JunkBuilding(name = "junk-outside-1", type = "junk-pile-small", pos = "950,-1950,-1", rot = "0,0,35"),
                JunkBuilding(name = "junk-outside-2", type = "junk-pallets", pos = "1214,-1984,0", rot = "0,0,0"),
                JunkBuilding(name = "junk-outside-3", type = "junk-pile-mid", pos = "1450,-1050,0", rot = "0,0,265"),
                JunkBuilding(name = "junk-outside-4", type = "junk-pile-car", pos = "1541,952,0", rot = "0,0,0"),
                JunkBuilding(name = "junk-outside-5", type = "junk-pile-small", pos = "1450,1850,-1", rot = "0,0,65"),
                JunkBuilding(name = "junk-outside-6", type = "junk-drums", pos = "1351,2149,0", rot = "0,0,90"),
                JunkBuilding(name = "junkCloth1", type = "junk-cloth", pos = "1420,-639,0", rot = "0,0,0"),
                JunkBuilding(name = "junkCloth2", type = "junk-cloth", pos = "-750,2750,0", rot = "0,0,180"),
                JunkBuilding(name = "junkCloth3", type = "junk-cloth", pos = "-850,-2350,0", rot = "0,0,90"),
                JunkBuilding(name = "junkCloth4", type = "junk-cloth", pos = "450,-450,0", rot = "0,0,0"),
                JunkBuilding(name = "junk-outside-25", type = "junk-pile-mid", pos = "2250,-52,0", rot = "0,0,0"),
                JunkBuilding(name = "junk-outside-26", type = "junk-pile-small", pos = "2350,2451,0", rot = "0,0,0"),
                JunkBuilding(name = "junk-outside-27", type = "junk-pile-mid", pos = "-450,-1650,0", rot = "0,0,0"),
                JunkBuilding(name = "junk-outside-wood-1", type = "junk-pallets", pos = "3392,2987,0", rot = "0,0,0"),
                JunkBuilding(name = "junk-outside-metal-1", type = "junk-drums", pos = "3550,-3050,0", rot = "0,0,0"),
                JunkBuilding(name = "junk-huge-1", type = "junk-pile-huge", pos = "2521,-2201,0", rot = "0,0,0"),
                JunkBuilding(name = "junk-huge-2", type = "junk-pile-huge-2", pos = "2441,-1635,0", rot = "0,0,0"),
                JunkBuilding(name = "junk-pile-huge-1-2", type = "junk-pile-huge", pos = "320,1982,0", rot = "0,0,180"),
                JunkBuilding(name = "junk-pile-huge-2-2", type = "junk-pile-huge-2", pos = "2600,1366,0", rot = "0,0,90"),
            )

            return buildList {
                addAll(junks)
                add(Building(type = "rally", tx = 15, ty = 33, rotation = 0))
                add(Building(type = "bed", tx = 15, ty = 42, rotation = 0))
                add(Building(type = "car", tx = 35, ty = 50, rotation = 0))
            }
        }

        fun simpleBase(): List<BuildingLike> {
            return listOf(
                Building(type = "bed", tx = 19, ty = 35, level = 2, rotation = 3),
                Building(type = "storage-ammunition", tx = 11, ty = 47, level = 5, rotation = 2),
                Building(type = "storage-cloth", tx = 12, ty = 38, level = 5, rotation = 0),
                Building(type = "storage-water", tx = 16, ty = 42, level = 5, rotation = 0),
                Building(type = "storage-metal", tx = 12, ty = 44, level = 5, rotation = 0),
                Building(type = "recycler", tx = 21, ty = 40, level = 9, rotation = 1),
                Building(type = "compound-barricade-small", tx = 17, ty = 62, level = 0, rotation = 3),
                Building(type = "compound-barricade-small", tx = 20, ty = 61, level = 0, rotation = 0),
                Building(type = "compound-barricade-small", tx = 15, ty = 59, level = 0, rotation = 2),
                Building(type = "compound-barricade-small", tx = 31, ty = 46, level = 0, rotation = 3),
                Building(type = "compound-barricade-small", tx = 33, ty = 42, level = 0, rotation = 1),
                Building(type = "compound-barricade-small", tx = 34, ty = 45, level = 0, rotation = 0),
                Building(type = "compound-barricade-small", tx = 18, ty = 29, level = 0, rotation = 0),
                Building(type = "compound-barricade-small", tx = 17, ty = 26, level = 0, rotation = 1),
                Building(type = "compound-barricade-small", tx = 14, ty = 27, level = 0, rotation = 2),
                Building(type = "deadend", tx = 31, ty = 51, level = 0, rotation = 0),
                Building(type = "deadend", tx = 32, ty = 38, level = 0, rotation = 0),
                Building(type = "deadend", tx = 25, ty = 60, level = 0, rotation = 3),
                Building(type = "rally", tx = 18, ty = 60, level = 0, rotation = 3),
                Building(type = "rally", tx = 32, ty = 44, level = 0, rotation = 0),
                Building(type = "rally", tx = 16, ty = 24, level = 0, rotation = 1),
            )
        }

        fun goodBase(): List<BuildingLike> {
            return listOf(
                Building(type = "bed", tx = 9, ty = 46, level = 4, rotation = 0),
                Building(type = "bed", tx = 9, ty = 43, level = 4, rotation = 0),
                Building(type = "bed", tx = 9, ty = 40, level = 4, rotation = 0),
                Building(type = "shower", tx = 15, ty = 50, level = 4, rotation = 0),
                Building(type = "shower", tx = 18, ty = 50, level = 4, rotation = 0),
                Building(type = "storage-ammunition", tx = 15, ty = 42, level = 5, rotation = 0),
                Building(type = "storage-ammunition", tx = 18, ty = 42, level = 5, rotation = 0),
                Building(type = "storage-cloth", tx = 7, ty = 34, level = 5, rotation = 3),
                Building(type = "storage-cloth", tx = 24, ty = 34, level = 5, rotation = 3),
                Building(type = "storage-water", tx = 8, ty = 55, level = 5, rotation = 0),
                Building(type = "storage-water", tx = 8, ty = 52, level = 5, rotation = 0),
                Building(type = "storage-metal", tx = 27, ty = 55, level = 5, rotation = 0),
                Building(type = "storage-metal", tx = 24, ty = 55, level = 5, rotation = 0),
                Building(type = "recycler", tx = 14, ty = 34, level = 9, rotation = 0),
                Building(type = "workbench", tx = 14, ty = 45, level = 4, rotation = 3),
                Building(type = "bench-engineering", tx = 19, ty = 34, level = 4, rotation = 3),
                Building(type = "bench-weapon", tx = 19, ty = 44, level = 4, rotation = 0),

                Building(type = "barricadeSmall", tx = 13, ty = 28, level = 4, rotation = 2),
                Building(type = "barricadeSmall", tx = 15, ty = 27, level = 4, rotation = 1),
                Building(type = "barricadeSmall", tx = 18, ty = 27, level = 4, rotation = 1),
                Building(type = "barricadeSmall", tx = 18, ty = 30, level = 4, rotation = 0),
                Building(type = "door", tx = 17, ty = 57, level = 4, rotation = 3),
                Building(type = "rally", tx = 16, ty = 24, level = 0, rotation = 1),

                Building(type = "defence-wire", tx = 26, ty = 15, level = 3, rotation = 1),
                Building(type = "defence-wire", tx = 32, ty = 15, level = 3, rotation = 1),
                Building(type = "defence-wire", tx = 38, ty = 15, level = 3, rotation = 1),
                Building(type = "defence-wire", tx = 38, ty = 21, level = 3, rotation = 0),
                Building(type = "defence-wire", tx = 38, ty = 27, level = 3, rotation = 0),
                Building(type = "windmill", tx = 33, ty = 20, level = 4, rotation = 1),
                Building(type = "trap-halloween-decoy", tx = 10, ty = 14, level = 0, rotation = 1),
                Building(type = "trap-halloween-decoy", tx = 8, ty = 14, level = 0, rotation = 1),

                Building(type = "barricadeSmall", tx = 32, ty = 35, level = 4, rotation = 1),
                Building(type = "barricadeSmall", tx = 35, ty = 35, level = 4, rotation = 1),
                Building(type = "barricadeLarge", tx = 30, ty = 57, level = 4, rotation = 3),
                Building(type = "barricadeLarge", tx = 36, ty = 57, level = 4, rotation = 3),
                Building(type = "barricadeLarge", tx = 41, ty = 56, level = 4, rotation = 0),
                Building(type = "barricadeLarge", tx = 41, ty = 47, level = 4, rotation = 0),
                Building(type = "barricadeLarge", tx = 41, ty = 41, level = 4, rotation = 0),
                Building(type = "barricadeLarge", tx = 41, ty = 35, level = 4, rotation = 1),
                Building(type = "watchtower", tx = 31, ty = 53, level = 3, rotation = 3),
                Building(type = "watchtower", tx = 33, ty = 39, level = 3, rotation = 0),
                Building(type = "gate", tx = 41, ty = 50, level = 4, rotation = 0),
                Building(type = "deadend", tx = 37, ty = 50, level = 0, rotation = 0),
                Building(type = "deadend", tx = 37, ty = 38, level = 0, rotation = 0),
                Building(type = "rally", tx = 32, ty = 44, level = 0, rotation = 0),

                Building(type = "barricadeLarge", tx = 14, ty = 58, level = 4, rotation = 2),
                Building(type = "barricadeLarge", tx = 15, ty = 63, level = 4, rotation = 3),
                Building(type = "barricadeLarge", tx = 21, ty = 63, level = 4, rotation = 0),
                Building(type = "construction-yard", tx = 28, ty = 59, level = 4, rotation = 1),
                Building(type = "door", tx = 16, ty = 31, level = 4, rotation = 1),
                Building(type = "deadend", tx = 18, ty = 67, level = 0, rotation = 3),
                Building(type = "rally", tx = 17, ty = 59, level = 0, rotation = 3),
            )
        }
    }
}

===== C:\Users\Sulivan\Desktop\Projects\DeadZone-Private-Server\src\main\kotlin\core\compound\model\CompoundData.kt =====
package dev.deadzone.core.model.game.data

import kotlinx.serialization.Serializable
import dev.deadzone.data.collection.PlayerObjects

@Serializable
data class CompoundData(
    val player: PlayerObjects?,
    val buildings: BuildingCollection = BuildingCollection(),
    val resources: GameResources = GameResources(),
    val survivors: SurvivorCollection = SurvivorCollection(),
    val tasks: TaskCollection = TaskCollection(),
    val effects: EffectCollection = EffectCollection(),
    val globalEffects: EffectCollection = EffectCollection(),
    val morale: Morale = Morale(),
    val moraleFilter: List<String> = listOf("food", "water", "security", "comfort")
)

===== C:\Users\Sulivan\Desktop\Projects\DeadZone-Private-Server\src\main\kotlin\core\compound\model\GameResources.kt =====
package dev.deadzone.core.model.game.data

import kotlinx.serialization.Serializable

@Serializable
data class GameResources(
    val wood: Int = 0,
    val metal: Int = 0,
    val cloth: Int = 0,
    val water: Int = 0,
    val food: Int = 0,
    val ammunition: Int = 0,
    val cash: Int = 0
)

fun GameResources.getNonEmptyResAmountOrNull(): Int? {
    val nonEmpty = listOf(
        wood, metal, cloth, food, water, ammunition, cash
    ).filter { it != 0 }

    return if (nonEmpty.size == 1) nonEmpty.first() else null
}

fun GameResources.getNonEmptyResTypeOrNull(): String? {
    val nonEmpty = listOf(
        "wood" to wood,
        "metal" to metal,
        "cloth" to cloth,
        "food" to food,
        "water" to water,
        "ammunition" to ammunition,
        "cash" to cash
    ).filter { it.second != 0 }

    return nonEmpty.singleOrNull()?.first
}

===== C:\Users\Sulivan\Desktop\Projects\DeadZone-Private-Server\src\main\kotlin\core\compound\model\GameResourcesConstants.kt =====
package dev.deadzone.core.model.game.data

import kotlinx.serialization.Serializable

@Serializable
@JvmInline
value class GameResourcesConstants(val value: String)

object GameResourcesConstants_Constants {
    val CASH = GameResourcesConstants("cash")
    val WOOD = GameResourcesConstants("wood")
    val METAL = GameResourcesConstants("metal")
    val CLOTH = GameResourcesConstants("cloth")
    val WATER = GameResourcesConstants("water")
    val FOOD = GameResourcesConstants("food")
    val AMMUNITION = GameResourcesConstants("ammunition")
}

===== C:\Users\Sulivan\Desktop\Projects\DeadZone-Private-Server\src\main\kotlin\core\compound\model\JunkBuilding.kt =====
package dev.deadzone.core.model.game.data

import kotlinx.serialization.Serializable
import dev.deadzone.core.items.model.Item
import dev.deadzone.utils.UUID

@Serializable
data class JunkBuilding(
    val id: String = UUID.new(),
    val name: String? = null,
    val type: String,
    val level: Int = 0,
    val rotation: Int = 0,
    val tx: Int = 0,
    val ty: Int = 0,
    val destroyed: Boolean = false,
    val resourceValue: Double = 0.0,
    val upgrade: TimerData? = null,
    val repair: TimerData? = null,

    val items: List<Item> = emptyList(),
    val pos: String,
    val rot: String
) : BuildingLike()

===== C:\Users\Sulivan\Desktop\Projects\DeadZone-Private-Server\src\main\kotlin\core\data\AdminData.kt =====
package dev.deadzone.core.data

/**
 * Dummy data ready to use, typically for admin account.
 */
object AdminData {
    const val ADMIN_RESERVED_NAME = "givemeadmin"
    const val PLAYER_ID = "adm-id-123456"
    const val DISPLAY_NAME = "AdminPlayer" // also known as username or nickname
    const val EMAIL = "admin@admin.com"
    const val PASSWORD = "admin"
    const val TOKEN = "admin-token-123456"
    const val COUNTRY_CODE = "US"
    const val AVATAR_URL = "https://picsum.photos/200"
    const val IS_ADMIN = true
    const val PLAYER_DATA_KEY = "admkey"
    const val PLAYER_SRV_ID = "srv-player"
    const val PLAYER_LEADER_TITLE = "MercifulLeader"
    const val PLAYER_LEVEL = 60
    const val PLAYER_EXP = 100
    const val FIGHTER_SRV_ID = "srv-fighter-m"
    const val RECON_SRV_ID = "srv-recon-f"
    const val PLAYER_WEP_ID = "deagle-replica"
    const val FIGHTER_WEP_ID = "bladesaw"
    const val RECON_WEP_ID = "fal3"
}

===== C:\Users\Sulivan\Desktop\Projects\DeadZone-Private-Server\src\main\kotlin\core\data\GameDefinitions.kt =====
package dev.deadzone.core.data

import dev.deadzone.core.data.assets.*
import dev.deadzone.utils.Logger
import io.ktor.util.date.getTimeMillis
import java.io.File
import java.util.zip.GZIPInputStream
import javax.xml.parsers.DocumentBuilderFactory
import kotlin.collections.iterator
import kotlin.time.Duration.Companion.milliseconds

/**
 * Global registry that holds game data and config from parsing the game XML resources.
 *
 * You will need to read the XML resources in data/xml/. This is to sync with client-side data.
 * Sometimes the client-side does not send every data (like what zombie it request or what loot it expects)
 * This is because it expects the server to handle it, including data lookup to those XMLs.
 *
 * - For example, items.xml read includes initializing in-memory index such as itemsById, itemsByType, allowing easy retrieval.
 * - zombie.xml may includes zombies of same type with different level (use this to choose which zombie to spawn depend on area level).
 * - zombie.xml also have rarity, use this to determine the rarity of spawning that zombie (Yes we need zombie system just like we have the loot system).
 * - For buildings.xml maybe you will need the data for some buildings like production (reading the prod element) to see its production rate, etc.
 * - badwords.xml contains useful badword utility. We may use it as verification (not very important here).
 * - I haven't checked other.
 *
 * VERY IMPORTANT: there is confusion around id, type for all XML resources.
 * - in the server, id is treated as unique identifier,
 * type as the 'id' in the XML,
 * and server does not store extra "type" which correspond to the 'type' in XML.
 * - in the game, lookup to XML is done in syntax like @id == type. This means that the id (at) XML must be equal to type sent from server.
 * - For type in XML lookup, you can make similar server index like itemsByType
 */
class GameDefinitions(onResourceLoadComplete: () -> Unit) {
    val itemsById = mutableMapOf<String, ItemResource>()
    val itemsByType = mutableMapOf<String, MutableList<ItemResource>>()
    val itemsByLootable = mutableMapOf<String, MutableList<ItemResource>>()

    init {
        val resourcesToLoad = mapOf(
            "static/game/data/xml/alliances.xml.gz" to AlliancesParser(),
            "static/game/data/xml/arenas.xml.gz" to ArenasParser(),
            "static/game/data/xml/attire.xml.gz" to AttireParser(),
            "static/game/data/xml/badwords.xml.gz" to BadwordsParser(),
            "static/game/data/xml/buildings.xml.gz" to BuildingsParser(),
            "static/game/data/xml/config.xml.gz" to ConfigParser(),
            "static/game/data/xml/crafting.xml.gz" to CraftingParser(),
            "static/game/data/xml/effects.xml.gz" to EffectsParser(),
            "static/game/data/xml/humanenemies.xml.gz" to HumanEnemiesParser(),
            "static/game/data/xml/injury.xml.gz" to InjuryParser(),
            "static/game/data/xml/itemmods.xml.gz" to ItemModsParser(),
            "static/game/data/xml/items.xml.gz" to ItemsParser(),
            "static/game/data/xml/quests.xml.gz" to QuestsGlobalParser(),
            "static/game/data/xml/quests_global.xml.gz" to RaidsParser(),
            "static/game/data/xml/raids.xml.gz" to SkillsParser(),
            "static/game/data/xml/skills.xml.gz" to StreetStructsParser(),
            "static/game/data/xml/streetstructs.xml.gz" to SurvivorParser(),
            "static/game/data/xml/survivor.xml.gz" to VehicleNamesParser(),
            "static/game/data/xml/vehiclenames.xml.gz" to ZombiesParser()
        )

        for ((path, parser) in resourcesToLoad) {
            val start = getTimeMillis()
            val file = File(path)

            if (path != "static/game/data/xml/items.xml.gz") continue // only parse items for now

            GZIPInputStream(file.inputStream()).use {
                val document = DocumentBuilderFactory.newInstance().newDocumentBuilder().parse(it)
                parser.parse(document, this)
            }

            val end = getTimeMillis()
            val resName = path.removePrefix("static/game/data/xml/").removeSuffix(".gz")

            Logger.info { "Finished parsing $resName in ${(end - start).milliseconds}" }
        }
        onResourceLoadComplete()
    }
}

===== C:\Users\Sulivan\Desktop\Projects\DeadZone-Private-Server\src\main\kotlin\core\data\PlayerLoginState.kt =====
package dev.deadzone.core.data

import dev.deadzone.core.model.game.data.GameResources
import dev.deadzone.core.model.game.data.Survivor
import kotlinx.serialization.Serializable

/**
 * Player login state is needed for [dev.deadzone.socket.handler.JoinHandler] result
 *
 * Structure still empty and assumption. See Network.as onGameReady and onPlayerDataLoaded
 */
@Serializable
data class PlayerLoginState(
    val settings: Map<String, String> = emptyMap(),
    val news: Map<String, String> = emptyMap(), // NewsArticle object
    val sales: List<String> = emptyList(), // assigned to sales category
    val allianceWinnings: Map<String, String> = emptyMap(),
    val recentPVPList: List<String> = emptyList(),

    val invsize: Int,
    val upgrades: String = "", // base64 encoded string
    val allianceId: String? = null,
    val allianceTag: String? = null,
    val longSession: Boolean = false, // if true: this will prompt captcha question in-game
    val leveledUp: Boolean = false,
    val promos: List<String> = emptyList(),
    val promoSale: String? = null,
    val dealItem: String? = null,
    val leaderResets: Int = 0,
    val unequipItemBinds: List<String> = emptyList(),
    val globalStats: Map<String, List<String>> = mapOf(
        "idList" to emptyList()
    ),

    val resources: GameResources? = null,
    val survivors: List<Survivor>? = null,
    val tasks: List<String>? = null,    // likely task id
    val missions: List<String>? = null, // likely mission id
    val bountyCap: Int? = null,
    val bountyCapTimestamp: Long? = null,
    val research: Map<String, Int>? = null,
) {
    companion object {
        fun admin(): PlayerLoginState {
            return PlayerLoginState(
                invsize = 3000
            )
        }

        fun newgame(): PlayerLoginState {
            return PlayerLoginState(
                invsize = 500
            )
        }
    }
}

===== C:\Users\Sulivan\Desktop\Projects\DeadZone-Private-Server\src\main\kotlin\core\data\parser\AlliancesParser.kt =====
package dev.deadzone.core.data.assets

import dev.deadzone.core.data.GameDefinitions
import org.w3c.dom.Document

class AlliancesParser() : GameResourcesParser {
    override fun parse(doc: Document, gameDefinitions: GameDefinitions) {

    }
}

===== C:\Users\Sulivan\Desktop\Projects\DeadZone-Private-Server\src\main\kotlin\core\data\parser\ArenasParser.kt =====
package dev.deadzone.core.data.assets

import dev.deadzone.core.data.GameDefinitions
import org.w3c.dom.Document

class ArenasParser() : GameResourcesParser {
    override fun parse(doc: Document, gameDefinitions: GameDefinitions) {

    }
}

===== C:\Users\Sulivan\Desktop\Projects\DeadZone-Private-Server\src\main\kotlin\core\data\parser\AttireParser.kt =====
package dev.deadzone.core.data.assets

import dev.deadzone.core.data.GameDefinitions
import org.w3c.dom.Document

class AttireParser() : GameResourcesParser {
    override fun parse(doc: Document, gameDefinitions: GameDefinitions) {

    }
}

===== C:\Users\Sulivan\Desktop\Projects\DeadZone-Private-Server\src\main\kotlin\core\data\parser\BadwordsParser.kt =====
package dev.deadzone.core.data.assets

import dev.deadzone.core.data.GameDefinitions
import org.w3c.dom.Document

class BadwordsParser() : GameResourcesParser {
    override fun parse(doc: Document, gameDefinitions: GameDefinitions) {

    }
}

===== C:\Users\Sulivan\Desktop\Projects\DeadZone-Private-Server\src\main\kotlin\core\data\parser\BuildingsParser.kt =====
package dev.deadzone.core.data.assets

import dev.deadzone.core.data.GameDefinitions
import org.w3c.dom.Document

class BuildingsParser() : GameResourcesParser {
    override fun parse(doc: Document, gameDefinitions: GameDefinitions) {

    }
}

===== C:\Users\Sulivan\Desktop\Projects\DeadZone-Private-Server\src\main\kotlin\core\data\parser\ConfigParser.kt =====
package dev.deadzone.core.data.assets

import dev.deadzone.core.data.GameDefinitions
import org.w3c.dom.Document

class ConfigParser() : GameResourcesParser {
    override fun parse(doc: Document, gameDefinitions: GameDefinitions) {

    }
}

===== C:\Users\Sulivan\Desktop\Projects\DeadZone-Private-Server\src\main\kotlin\core\data\parser\CraftingParser.kt =====
package dev.deadzone.core.data.assets

import dev.deadzone.core.data.GameDefinitions
import org.w3c.dom.Document

class CraftingParser() : GameResourcesParser {
    override fun parse(doc: Document, gameDefinitions: GameDefinitions) {

    }
}

===== C:\Users\Sulivan\Desktop\Projects\DeadZone-Private-Server\src\main\kotlin\core\data\parser\EffectsParser.kt =====
package dev.deadzone.core.data.assets

import dev.deadzone.core.data.GameDefinitions
import org.w3c.dom.Document

class EffectsParser() : GameResourcesParser {
    override fun parse(doc: Document, gameDefinitions: GameDefinitions) {

    }
}

===== C:\Users\Sulivan\Desktop\Projects\DeadZone-Private-Server\src\main\kotlin\core\data\parser\GameResourcesParser.kt =====
package dev.deadzone.core.data.assets

import dev.deadzone.core.data.GameDefinitions
import org.w3c.dom.Document

/**
 * Parser for the game XML resources (e.g., `items.xml`, `zombies.xml`)
 *
 * This is used to create code level representation from the game's data.
 *
 * As an example, [ItemsParser] reads the `items.xml` and depending on the item type
 * (e.g., `type="weapon"`, `type="junk"`), it chooses subparser (i.e., [WeaponItemParser])
 * and creates the corresponding [dev.deadzone.core.items.model.Item] object.
 */
interface GameResourcesParser {
    fun parse(doc: Document, gameDefinitions: GameDefinitions)
}

===== C:\Users\Sulivan\Desktop\Projects\DeadZone-Private-Server\src\main\kotlin\core\data\parser\HumanEnemiesParser.kt =====
package dev.deadzone.core.data.assets

import dev.deadzone.core.data.GameDefinitions
import org.w3c.dom.Document

class HumanEnemiesParser() : GameResourcesParser {
    override fun parse(doc: Document, gameDefinitions: GameDefinitions) {

    }
}

===== C:\Users\Sulivan\Desktop\Projects\DeadZone-Private-Server\src\main\kotlin\core\data\parser\InjuryParser.kt =====
package dev.deadzone.core.data.assets

import dev.deadzone.core.data.GameDefinitions
import org.w3c.dom.Document

class InjuryParser() : GameResourcesParser {
    override fun parse(doc: Document, gameDefinitions: GameDefinitions) {

    }
}

===== C:\Users\Sulivan\Desktop\Projects\DeadZone-Private-Server\src\main\kotlin\core\data\parser\ItemModsParser.kt =====
package dev.deadzone.core.data.assets

import dev.deadzone.core.data.GameDefinitions
import org.w3c.dom.Document

class ItemModsParser() : GameResourcesParser {
    override fun parse(doc: Document, gameDefinitions: GameDefinitions) {

    }
}

===== C:\Users\Sulivan\Desktop\Projects\DeadZone-Private-Server\src\main\kotlin\core\data\parser\ItemsParser.kt =====
package dev.deadzone.core.data.assets

import dev.deadzone.core.data.GameDefinitions
import org.w3c.dom.Document
import org.w3c.dom.Element

data class ItemResource(
    val idInXML: String, // id in xml
    val type: String,
    val element: Element
) {
    override fun toString(): String {
        return "ItemResource(idInXML=$idInXML, type=$type)"
    }
}

class ItemsParser() : GameResourcesParser {
    override fun parse(doc: Document, gameDefinitions: GameDefinitions) {
        val items = doc.getElementsByTagName("item")

        for (i in 0 until items.length) {
            val itemNode = items.item(i) as? Element ?: continue
            val itemId = itemNode.getAttribute("id").takeIf { it != "" } ?: continue
            val itemType = itemNode.getAttribute("type").takeIf { it != "" } ?: continue
            val itemLocs = itemNode.getAttribute("locs").takeIf { it != "" }

            val res = ItemResource(itemId, itemType, itemNode)

            gameDefinitions.itemsById.putIfAbsent(itemId, res)
            gameDefinitions.itemsByType.computeIfAbsent(itemId) { mutableListOf() }.add(res)
            if (itemLocs?.isNotEmpty() ?: false) {
                val locList = itemLocs.split(',').map { it.trim() }
                for (loc in locList) {
                    gameDefinitions.itemsByLootable.computeIfAbsent(loc) { mutableListOf() }.add(res)
                }
            }
        }
    }
}

===== C:\Users\Sulivan\Desktop\Projects\DeadZone-Private-Server\src\main\kotlin\core\data\parser\QuestsGlobalParser.kt =====
package dev.deadzone.core.data.assets

import dev.deadzone.core.data.GameDefinitions
import org.w3c.dom.Document

class QuestsGlobalParser() : GameResourcesParser {
    override fun parse(doc: Document, gameDefinitions: GameDefinitions) {

    }
}

===== C:\Users\Sulivan\Desktop\Projects\DeadZone-Private-Server\src\main\kotlin\core\data\parser\QuestsParser.kt =====
package dev.deadzone.core.data.assets

import dev.deadzone.core.data.GameDefinitions
import org.w3c.dom.Document

class QuestsParser() : GameResourcesParser {
    override fun parse(doc: Document, gameDefinitions: GameDefinitions) {

    }
}

===== C:\Users\Sulivan\Desktop\Projects\DeadZone-Private-Server\src\main\kotlin\core\data\parser\RaidsParser.kt =====
package dev.deadzone.core.data.assets

import dev.deadzone.core.data.GameDefinitions
import org.w3c.dom.Document

class RaidsParser() : GameResourcesParser {
    override fun parse(doc: Document, gameDefinitions: GameDefinitions) {

    }
}

===== C:\Users\Sulivan\Desktop\Projects\DeadZone-Private-Server\src\main\kotlin\core\data\parser\SkillsParser.kt =====
package dev.deadzone.core.data.assets

import dev.deadzone.core.data.GameDefinitions
import org.w3c.dom.Document

class SkillsParser() : GameResourcesParser {
    override fun parse(doc: Document, gameDefinitions: GameDefinitions) {

    }
}

===== C:\Users\Sulivan\Desktop\Projects\DeadZone-Private-Server\src\main\kotlin\core\data\parser\StreetStructsParser.kt =====
package dev.deadzone.core.data.assets

import dev.deadzone.core.data.GameDefinitions
import org.w3c.dom.Document

class StreetStructsParser() : GameResourcesParser {
    override fun parse(doc: Document, gameDefinitions: GameDefinitions) {

    }
}

===== C:\Users\Sulivan\Desktop\Projects\DeadZone-Private-Server\src\main\kotlin\core\data\parser\SurvivorParser.kt =====
package dev.deadzone.core.data.assets

import dev.deadzone.core.data.GameDefinitions
import org.w3c.dom.Document

class SurvivorParser() : GameResourcesParser {
    override fun parse(doc: Document, gameDefinitions: GameDefinitions) {

    }
}

===== C:\Users\Sulivan\Desktop\Projects\DeadZone-Private-Server\src\main\kotlin\core\data\parser\VehicleNamesParser.kt =====
package dev.deadzone.core.data.assets

import dev.deadzone.core.data.GameDefinitions
import org.w3c.dom.Document

class VehicleNamesParser() : GameResourcesParser {
    override fun parse(doc: Document, gameDefinitions: GameDefinitions) {

    }
}

===== C:\Users\Sulivan\Desktop\Projects\DeadZone-Private-Server\src\main\kotlin\core\data\parser\ZombiesParser.kt =====
package dev.deadzone.core.data.assets

import dev.deadzone.core.data.GameDefinitions
import org.w3c.dom.Document

class ZombiesParser() : GameResourcesParser {
    override fun parse(doc: Document, gameDefinitions: GameDefinitions) {

    }
}

===== C:\Users\Sulivan\Desktop\Projects\DeadZone-Private-Server\src\main\kotlin\core\items\InventoryRepository.kt =====
package dev.deadzone.core.items

interface InventoryRepository {
    fun placeholder()
}

===== C:\Users\Sulivan\Desktop\Projects\DeadZone-Private-Server\src\main\kotlin\core\items\InventoryRepositoryMaria.kt =====
package dev.deadzone.core.items

class InventoryRepositoryMaria: InventoryRepository {
    override fun placeholder() {
    }
}

===== C:\Users\Sulivan\Desktop\Projects\DeadZone-Private-Server\src\main\kotlin\core\items\InventoryService.kt =====
package dev.deadzone.core.items

import core.PlayerService

class InventoryService(
    private val inventoryRepository: InventoryRepository
) : PlayerService {
    override suspend fun init(playerId: String): Result<Unit> {
        return Result.success(Unit)
    }

    override suspend fun close(playerId: String): Result<Unit> {
        return Result.success(Unit)
    }
}

===== C:\Users\Sulivan\Desktop\Projects\DeadZone-Private-Server\src\main\kotlin\core\items\ItemFactory.kt =====
package dev.deadzone.core.items

import dev.deadzone.core.data.assets.ItemResource
import dev.deadzone.core.items.model.Item
import dev.deadzone.core.items.model.ItemQualityType
import dev.deadzone.context.GlobalContext
import dev.deadzone.utils.UUID
import org.w3c.dom.Element

object ItemFactory {
    private val gameResourceRegistry get() = GlobalContext.gameDefinitions

    fun getRandomItem(): Item {
        return createItemFromResource(res = gameResourceRegistry.itemsById.values.random())
    }

    fun createItemFromId(itemId: String = UUID.new(), idInXML: String): Item {
        val res =
            gameResourceRegistry.itemsById[idInXML]
                ?: throw IllegalArgumentException("Failed creating Item id=$itemId from xml id=$idInXML (xml id not found)")
        return createItemFromResource(itemId, res)
    }

    fun createItemFromResource(itemId: String = UUID.new(), res: ItemResource): Item {
        val baseItem = Item(
            id = itemId,
            type = res.idInXML,
            quality = ItemQualityType.fromString(res.element.getAttribute("quality"))
        )

        when (res.type) {
            "gear" -> parseGear(res.element, baseItem)
            "weapon" -> parseWeapon(res.element, baseItem)
            "clothing" -> parseClothing(res.element, baseItem)
        }

        return baseItem
    }

    private fun parseGear(element: Element, baseItem: Item) {}
    private fun parseWeapon(element: Element, baseItem: Item) {}
    private fun parseClothing(element: Element, baseItem: Item) {}
}

===== C:\Users\Sulivan\Desktop\Projects\DeadZone-Private-Server\src\main\kotlin\core\items\model\CrateItem.kt =====
package dev.deadzone.core.items.model

import kotlinx.serialization.Serializable
import dev.deadzone.socket.handler.save.crate.response.gachaPoolExample

@Serializable
data class CrateItem(
    val type: String,
    val id: String = "",  // uses GUID.create() by default
    val new: Boolean = false,
    val storeId: String = "",
    val level: Int = 0,
    val series: Int = 0,
    val version: Int = 0,
    val contents: List<Item> = gachaPoolExample
)

===== C:\Users\Sulivan\Desktop\Projects\DeadZone-Private-Server\src\main\kotlin\core\items\model\EffectItem.kt =====
package dev.deadzone.core.items.model

import kotlinx.serialization.Serializable

@Serializable
data class EffectItem(
    val effect: ByteArray,  // see effect.as for bytearray specification
)

===== C:\Users\Sulivan\Desktop\Projects\DeadZone-Private-Server\src\main\kotlin\core\items\model\Gear.kt =====
package dev.deadzone.core.items.model

import dev.deadzone.core.model.game.data.AttireData
import kotlinx.serialization.Serializable

@Serializable
data class Gear(
    val _attireXMLInvalid: Boolean = false,
    val animType: String = "",
    val attire: List<AttireData> = listOf(),
    val attireXMLList: List<String> = listOf(),  // List<XMLList> actually
    val gearType: UInt = 1u,
    val gearClass: String = "",
    val requiredSurvivorClass: String?,
    val carryLimit: Int = 0,
    val survivorClasses: List<String> = listOf(),
    val weaponClasses: List<String> = listOf(),
    val weaponTypes: UInt = 0u,
    val ammoTypes: UInt = 0u,
    val activeAttributes: ItemAttributes
)

===== C:\Users\Sulivan\Desktop\Projects\DeadZone-Private-Server\src\main\kotlin\core\items\model\GearClass.kt =====
package dev.deadzone.core.items.model

import kotlinx.serialization.Serializable

@Serializable
data class GearClass(
    val GLOVES: String = "gloves",
    val GLASSES: String = "glasses",
    val SHOES: String = "shoes",
    val VEST: String = "vest",
    val GRENADE: String = "grenade",
    val EXPLOSIVE_CHARGE: String = "expcharge",
    val STIM: String = "stim"
)

===== C:\Users\Sulivan\Desktop\Projects\DeadZone-Private-Server\src\main\kotlin\core\items\model\GearType.kt =====
package dev.deadzone.core.items.model

import kotlinx.serialization.Serializable

@Serializable
@JvmInline
value class GearType(val value: UInt)

object GearType_Constants {
    val UNKNOWN = GearType(0u)
    val PASSIVE = GearType(1u)
    val ACTIVE = GearType(2u)
    val CONSUMABLE = GearType(4u)
    val EXPLOSIVE = GearType(8u)
    val IMPROVISED = GearType(16u)
}

===== C:\Users\Sulivan\Desktop\Projects\DeadZone-Private-Server\src\main\kotlin\core\items\model\Item.kt =====
@file:OptIn(ExperimentalSerializationApi::class)

package dev.deadzone.core.items.model

import dev.deadzone.core.model.game.data.CraftingInfo
import dev.deadzone.utils.UUID
import kotlinx.serialization.EncodeDefault
import kotlinx.serialization.ExperimentalSerializationApi
import kotlinx.serialization.Serializable

@Serializable
data class Item(
    @EncodeDefault(EncodeDefault.Mode.NEVER) val id: String = UUID.new(),
    @EncodeDefault(EncodeDefault.Mode.NEVER) val new: Boolean = false,
    @EncodeDefault(EncodeDefault.Mode.NEVER) val storeId: String? = null,
    @EncodeDefault(EncodeDefault.Mode.NEVER) val bought: Boolean = false,
    @EncodeDefault(EncodeDefault.Mode.NEVER) val mod1: String? = null,
    @EncodeDefault(EncodeDefault.Mode.NEVER) val mod2: String? = null,
    @EncodeDefault(EncodeDefault.Mode.NEVER) val mod3: String? = null,
    @EncodeDefault(EncodeDefault.Mode.NEVER) val type: String,
    @EncodeDefault(EncodeDefault.Mode.NEVER) val level: Int = 0,
    @EncodeDefault(EncodeDefault.Mode.NEVER) val qty: UInt = 1u,
    @EncodeDefault(EncodeDefault.Mode.NEVER) val quality: Int? = null,
    @EncodeDefault(EncodeDefault.Mode.NEVER) val bind: UInt? = null,
    @EncodeDefault(EncodeDefault.Mode.NEVER) val tradable: Boolean? = true,
    @EncodeDefault(EncodeDefault.Mode.NEVER) val disposable: Boolean? = true,
    @EncodeDefault(EncodeDefault.Mode.NEVER) val ctrType: UInt? = null,
    @EncodeDefault(EncodeDefault.Mode.NEVER) val ctrVal: Int? = null,
    @EncodeDefault(EncodeDefault.Mode.NEVER) val craft: CraftingInfo? = null,
    @EncodeDefault(EncodeDefault.Mode.NEVER) val name: String? = null,
    @EncodeDefault(EncodeDefault.Mode.NEVER) val specData: ItemBonusStats? = null,
    @EncodeDefault(EncodeDefault.Mode.NEVER) val duplicate: Boolean = false,  // added from deserialize of Inventory
)

===== C:\Users\Sulivan\Desktop\Projects\DeadZone-Private-Server\src\main\kotlin\core\items\model\ItemAttributes.kt =====
package dev.deadzone.core.items.model

import kotlinx.serialization.Serializable

@Serializable
data class ItemAttributes(
    val baseValues: Map<String, Map<String, Double>> = mapOf(),
    val modValues: Map<String, Map<String, Double>> = mapOf(),
    val attCaps: Map<String, Map<String, Double>> = mapOf()
)

===== C:\Users\Sulivan\Desktop\Projects\DeadZone-Private-Server\src\main\kotlin\core\items\model\ItemAttributesConstants.kt =====
package dev.deadzone.core.items.model

object ItemAttributesConstants {
    const val GEAR = "gear"
    const val SURVIVOR = "srv"
    const val WEAPON = "weap"
    const val CARRY = "carry"
    const val EQUIP = "equip"
    const val INFECTED_KILL_XP = "infected_kill_xp"
    const val SURVIVOR_KILL_XP = "survivor_kill_xp"
    const val HUMAN_KILL_XP = "human_kill_xp"
    const val CLS = "cls"
    const val TYPE = "type"
    const val AMMO = "ammo"
    const val ANIM = "anim"
    const val SND = "snd"
    const val SWING = "swing"
    const val PROJ = "proj"
    const val RLDANIM = "rldanim"
    const val EXP = "exp"
    const val NOISE = "noise"
    const val RATE = "rate"
    const val RLDTIME = "rldtime"
    const val AMMO_COST = "ammo_cost"
    const val INJURY_CHANCE = "injuryChance"
    const val RNG_MIN_EFF = "rng_min_eff"
    const val REVERSE_RATE = "rate"
    const val REVERSE_RLDTIME = "rldtime"
}

===== C:\Users\Sulivan\Desktop\Projects\DeadZone-Private-Server\src\main\kotlin\core\items\model\ItemBindState.kt =====
package dev.deadzone.core.items.model

import kotlinx.serialization.Serializable

@Serializable
@JvmInline
value class ItemBindState(val value: UInt)

object ItemBindState_Constants {
    val NotBindable = ItemBindState(0u)
    val OnEquip = ItemBindState(1u)
    val Bound = ItemBindState(2u)
}

===== C:\Users\Sulivan\Desktop\Projects\DeadZone-Private-Server\src\main\kotlin\core\items\model\ItemBonusStats.kt =====
package dev.deadzone.core.items.model

import kotlinx.serialization.Serializable

@Serializable
data class ItemBonusStats(
    val stat_srv: Map<String, Double>? = null,
    val stat_weap: Map<String, Double>? = null,
    val stat_gear: Map<String, Double>? = null
)

===== C:\Users\Sulivan\Desktop\Projects\DeadZone-Private-Server\src\main\kotlin\core\items\model\ItemCounterType.kt =====
package dev.deadzone.core.items.model

import kotlinx.serialization.Serializable

@Serializable
@JvmInline
value class ItemCounterType(val value: UInt)

object ItemCounterType_Constants {
    val None = ItemCounterType(0u)
    val ZombieKills = ItemCounterType(1u)
    val HumanKills = ItemCounterType(2u)
    val SurvivorKills = ItemCounterType(3u)
}

===== C:\Users\Sulivan\Desktop\Projects\DeadZone-Private-Server\src\main\kotlin\core\items\model\ItemQualityType.kt =====
package dev.deadzone.core.items.model

import kotlinx.serialization.Serializable

@Serializable
@JvmInline
value class ItemQualityType(val value: Int) {
    companion object {
        fun fromString(s: String): Int? {
            return when (s) {
                "none" -> -2147483648
                "grey" -> -1
                "white" -> 0
                "green" -> 1
                "blue" -> 2
                "purple" -> 3
                "rare" -> 50
                "unique" -> 51
                "infamous" -> 52
                "premium" -> 100
                else -> null
            }
        }

        fun fromInt(i: Int): String? {
            return when (i) {
                -2147483648 -> "none"
                -1 -> "grey"
                0 -> "white"
                1 -> "green"
                2 -> "blue"
                3 -> "purple"
                50 -> "rare"
                51 -> "unique"
                52 -> "infamous"
                100 -> "premium"
                else -> null
            }
        }
    }
}

object ItemQualityType_Constants {
    val NONE = ItemQualityType(-2147483648)
    val GREY = ItemQualityType(-1)
    val WHITE = ItemQualityType(0)
    val GREEN = ItemQualityType(1)
    val BLUE = ItemQualityType(2)
    val PURPLE = ItemQualityType(3)
    val RARE = ItemQualityType(50)
    val UNIQUE = ItemQualityType(51)
    val INFAMOUS = ItemQualityType(52)
    val PREMIUM = ItemQualityType(100)
}

===== C:\Users\Sulivan\Desktop\Projects\DeadZone-Private-Server\src\main\kotlin\core\items\model\MedicalItem.kt =====
package dev.deadzone.core.items.model

import kotlinx.serialization.Serializable

@Serializable
data class MedicalItem(
    val item: Item
)

===== C:\Users\Sulivan\Desktop\Projects\DeadZone-Private-Server\src\main\kotlin\core\items\model\MiscEffectItem.kt =====
package dev.deadzone.core.items.model

import kotlinx.serialization.Serializable

@Serializable
data class MiscEffectItem(
    val effectItem: EffectItem
)

===== C:\Users\Sulivan\Desktop\Projects\DeadZone-Private-Server\src\main\kotlin\core\items\model\SchematicItem.kt =====
package dev.deadzone.core.items.model

import kotlinx.serialization.Serializable

@Serializable
data class SchematicItem(
    val type: String,
    val schem: String,
    val id: String = "",  // actually default a GUID.create()
    val new: Boolean = false,
    val storeId: String? = null
)

===== C:\Users\Sulivan\Desktop\Projects\DeadZone-Private-Server\src\main\kotlin\core\metadata\PlayerObjectsMetadataRepository.kt =====
package dev.deadzone.core.metadata

/**
 * Repository for uncategorized fields in PlayerObjects like nickname, flags
 */
interface PlayerObjectsMetadataRepository {
    suspend fun getPlayerFlags(playerId: String): Result<ByteArray>
    suspend fun updatePlayerFlags(playerId: String, flags: ByteArray): Result<Unit>

    suspend fun getPlayerNickname(playerId: String): Result<String?>
    suspend fun updatePlayerNickname(playerId: String, nickname: String): Result<Unit>
}

===== C:\Users\Sulivan\Desktop\Projects\DeadZone-Private-Server\src\main\kotlin\core\metadata\PlayerObjectsMetadataRepositoryMaria.kt =====
package dev.deadzone.core.metadata

import dev.deadzone.data.collection.PlayerObjects
import dev.deadzone.data.db.PlayerObjectsTable
import kotlinx.serialization.json.Json
import org.jetbrains.exposed.sql.*
import org.jetbrains.exposed.sql.SqlExpressionBuilder.eq
import org.jetbrains.exposed.sql.transactions.transaction

class PlayerObjectsMetadataRepositoryMaria(private val database: Database) : PlayerObjectsMetadataRepository {
    private val json = Json { ignoreUnknownKeys = true }
    
    override suspend fun getPlayerFlags(playerId: String): Result<ByteArray> {
        return runCatching {
            transaction(database) {
                PlayerObjectsTable.select { PlayerObjectsTable.playerId eq playerId }
                    .singleOrNull()?.let { row ->
                        val playerObjects = json.decodeFromString(PlayerObjects.serializer(), row[PlayerObjectsTable.dataJson])
                        playerObjects.flags
                    } ?: throw NoSuchElementException("No player found with id=$playerId")
            }
        }
    }
    
    override suspend fun updatePlayerFlags(playerId: String, flags: ByteArray): Result<Unit> {
        return runCatching {
            transaction(database) {
                val currentData = PlayerObjectsTable.select { PlayerObjectsTable.playerId eq playerId }
                    .singleOrNull()?.let { row ->
                        json.decodeFromString(PlayerObjects.serializer(), row[PlayerObjectsTable.dataJson])
                    } ?: throw NoSuchElementException("No player found with id=$playerId")
                
                val updatedData = currentData.copy(flags = flags)
                val updateResult = PlayerObjectsTable.update({ PlayerObjectsTable.playerId eq playerId }) {
                    it[dataJson] = json.encodeToString(PlayerObjects.serializer(), updatedData)
                }
                
                if (updateResult == 0) {
                    throw NoSuchElementException("No player found with id=$playerId")
                }
            }
        }
    }
    
    override suspend fun getPlayerNickname(playerId: String): Result<String?> {
        return runCatching {
            transaction(database) {
                PlayerObjectsTable.select { PlayerObjectsTable.playerId eq playerId }
                    .singleOrNull()?.let { row ->
                        val playerObjects = json.decodeFromString(PlayerObjects.serializer(), row[PlayerObjectsTable.dataJson])
                        playerObjects.nickname
                    } ?: throw NoSuchElementException("No player found with id=$playerId")
            }
        }
    }
    
    override suspend fun updatePlayerNickname(playerId: String, nickname: String): Result<Unit> {
        return runCatching {
            transaction(database) {
                val currentData = PlayerObjectsTable.select { PlayerObjectsTable.playerId eq playerId }
                    .singleOrNull()?.let { row ->
                        json.decodeFromString(PlayerObjects.serializer(), row[PlayerObjectsTable.dataJson])
                    } ?: throw NoSuchElementException("No player found with id=$playerId")
                
                val updatedData = currentData.copy(nickname = nickname)
                val updateResult = PlayerObjectsTable.update({ PlayerObjectsTable.playerId eq playerId }) {
                    it[dataJson] = json.encodeToString(PlayerObjects.serializer(), updatedData)
                }
                
                if (updateResult == 0) {
                    throw NoSuchElementException("No player found with id=$playerId")
                }
            }
        }
    }
}

===== C:\Users\Sulivan\Desktop\Projects\DeadZone-Private-Server\src\main\kotlin\core\metadata\PlayerObjectsMetadataService.kt =====
package dev.deadzone.core.metadata

import core.PlayerService
import core.metadata.model.PlayerFlags
import dev.deadzone.utils.LogConfigSocketToClient
import dev.deadzone.utils.Logger

class PlayerObjectsMetadataService(
    private val playerObjectsMetadataRepository: PlayerObjectsMetadataRepository
) : PlayerService {
    private var flags: ByteArray = PlayerFlags.newgame() // use newgame flags to avoid null
    private var nickname: String? = null // nickname null will prompt leader creation
    private lateinit var playerId: String

    suspend fun updatePlayerFlags(flags: ByteArray) {
        val result = playerObjectsMetadataRepository.updatePlayerFlags(playerId, flags)
        result.onFailure {
            Logger.error(LogConfigSocketToClient) { "Error updatePlayerFlags: ${it.message}" }
        }
        result.onSuccess {
            this.flags = flags
        }
    }

    suspend fun updatePlayerNickname(nickname: String) {
        val result = playerObjectsMetadataRepository.updatePlayerNickname(playerId, nickname)
        result.onFailure {
            Logger.error(LogConfigSocketToClient) { "Error updatePlayerNickname: ${it.message}" }
        }
        result.onSuccess {
            this.nickname = nickname
        }
    }

    fun getPlayerFlags() = flags

    override suspend fun init(playerId: String): Result<Unit> {
        return runCatching {
            this.playerId = playerId
            val _flags = playerObjectsMetadataRepository.getPlayerFlags(playerId).getOrThrow()
            val _nickname = playerObjectsMetadataRepository.getPlayerNickname(playerId).getOrThrow()

            flags = _flags
            nickname = _nickname

            if (flags.isEmpty()) {
                Logger.warn(LogConfigSocketToClient) { "flags for playerId=$playerId is empty" }
            }
        }
    }

    override suspend fun close(playerId: String): Result<Unit> {
        return Result.success(Unit)
    }
}

===== C:\Users\Sulivan\Desktop\Projects\DeadZone-Private-Server\src\main\kotlin\core\metadata\model\PlayerFlags.kt =====
package core.metadata.model
import kotlinx.serialization.KSerializer
import kotlinx.serialization.descriptors.PrimitiveKind
import kotlinx.serialization.descriptors.PrimitiveSerialDescriptor
import kotlinx.serialization.descriptors.SerialDescriptor
import kotlinx.serialization.encoding.Decoder
import kotlinx.serialization.encoding.Encoder
import kotlin.experimental.or
import kotlin.io.encoding.Base64
import kotlin.io.encoding.ExperimentalEncodingApi
object PlayerFlags {
    fun create(
        nicknameVerified: Boolean = false, refreshNeighbors: Boolean = false,
        tutorialComplete: Boolean = false, injurySustained: Boolean = false,
        injuryHelpComplete: Boolean = false, autoProtectionApplied: Boolean = false,
        tutorialCrateFound: Boolean = false, tutorialCrateUnlocked: Boolean = false,
        tutorialSchematicFound: Boolean = false, tutorialEffectFound: Boolean = false,
        tutorialPvPPractice: Boolean = false,
    ): ByteArray {
        val flags = listOf(
            nicknameVerified, refreshNeighbors, tutorialComplete,
            injurySustained, injuryHelpComplete, autoProtectionApplied,
            tutorialCrateFound, tutorialCrateUnlocked, tutorialSchematicFound,
            tutorialEffectFound, tutorialPvPPractice,
        )
        return flags.toByteArray()
    }
    fun newgame(
        nicknameVerified: Boolean = false, refreshNeighbors: Boolean = false,
        tutorialComplete: Boolean = false, injurySustained: Boolean = false,
        injuryHelpComplete: Boolean = false, autoProtectionApplied: Boolean = false,
        tutorialCrateFound: Boolean = false, tutorialCrateUnlocked: Boolean = false,
        tutorialSchematicFound: Boolean = false, tutorialEffectFound: Boolean = false,
        tutorialPvPPractice: Boolean = false,
    ): ByteArray {
        val flags = listOf(
            nicknameVerified, refreshNeighbors, tutorialComplete,
            injurySustained, injuryHelpComplete, autoProtectionApplied,
            tutorialCrateFound, tutorialCrateUnlocked, tutorialSchematicFound,
            tutorialEffectFound, tutorialPvPPractice,
        )
        return flags.toByteArray()
    }
    fun skipTutorial(
        nicknameVerified: Boolean = true, refreshNeighbors: Boolean = false,
        tutorialComplete: Boolean = true, injurySustained: Boolean = true,
        injuryHelpComplete: Boolean = true, autoProtectionApplied: Boolean = true,
        tutorialCrateFound: Boolean = true, tutorialCrateUnlocked: Boolean = true,
        tutorialSchematicFound: Boolean = true, tutorialEffectFound: Boolean = true,
        tutorialPvPPractice: Boolean = true,
    ): ByteArray {
        val flags = listOf(
            nicknameVerified, refreshNeighbors, tutorialComplete,
            injurySustained, injuryHelpComplete, autoProtectionApplied,
            tutorialCrateFound, tutorialCrateUnlocked, tutorialSchematicFound,
            tutorialEffectFound, tutorialPvPPractice,
        )
        return flags.toByteArray()
    }
}
fun List<Boolean>.toByteArray(): ByteArray {
    val bytes = ByteArray(this.size)
    for (i in this.indices) {
        if (this[i]) {
            val byteIndex = i / 8
            val bitIndex = i % 8
            bytes[byteIndex] = bytes[byteIndex] or (1 shl bitIndex).toByte()
        }
    }
    return bytes
}
@OptIn(ExperimentalEncodingApi::class)
object ByteArrayAsBase64Serializer : KSerializer<ByteArray> {
    override val descriptor: SerialDescriptor =
        PrimitiveSerialDescriptor("ByteArrayAsBase64", PrimitiveKind.STRING)
    override fun serialize(encoder: Encoder, value: ByteArray) {
        encoder.encodeString(Base64.encode(value))
    }
    override fun deserialize(decoder: Decoder): ByteArray {
        return Base64.decode(decoder.decodeString())
    }
}
object PlayerFlags_Constants {
    val TutorialComplete = 2u
}

===== C:\Users\Sulivan\Desktop\Projects\DeadZone-Private-Server\src\main\kotlin\core\mission\LootService.kt =====
package dev.deadzone.core.mission

import dev.deadzone.core.data.assets.ItemResource
import dev.deadzone.context.GlobalContext
import dev.deadzone.core.data.GameDefinitions
import dev.deadzone.core.mission.model.LootContent
import dev.deadzone.core.mission.model.LootParameter
import dev.deadzone.utils.UUID
import org.w3c.dom.Document
import org.w3c.dom.Element
import java.io.StringReader
import java.io.StringWriter
import javax.xml.parsers.DocumentBuilderFactory
import javax.xml.transform.OutputKeys
import javax.xml.transform.TransformerFactory
import javax.xml.transform.dom.DOMSource
import javax.xml.transform.stream.StreamResult
import javax.xml.parsers.DocumentBuilder
import org.xml.sax.InputSource
import java.util.TreeMap
import kotlin.random.Random

val ALL_LOCS = listOf(
    "crafting", "backpack", "kitchen", "lounge", "bedroom", "bathroom",
    "random", "office", "store", "military", "weapon", "resource", "police",
    "gear", "tutorial", "fuel", "food", "fridge", "water", "vending", "car",
    "body", "basement", "ammo", "wood", "metal", "cloth", "comms", "hospital",
    "island", "firstaid"
) // + the tutorial convenience store (tutorialfuel)

class LootService(
    private val gameDefinitions: GameDefinitions = GlobalContext.gameDefinitions,
    private val sceneXML: String,
    private val parameter: LootParameter
) {
    val cumulativeLootsPerLoc: MutableMap<String, TreeMap<Double, LootContent>> = mutableMapOf()
    val totalWeightPerLoc: MutableMap<String, Double> = mutableMapOf()
    val insertedLoots: MutableList<LootContent> = mutableListOf()
    val itemsLootedByPlayer: MutableList<LootContent> = mutableListOf()

    init {
        buildIndexOfLootableItems()
    }

    private fun buildIndexOfLootableItems() {
        ALL_LOCS.forEach { loc ->
            val lootableInLoc = gameDefinitions.itemsByLootable[loc] ?: emptyList()
            val treeMap = TreeMap<Double, LootContent>()
            var cumulativeWeight = 0.0

            loop@ for (item in lootableInLoc) {
                val specialItemsKeyword = listOf(
                    "halloween", "spooky", "pumpkin", "ghost", "witch",
                    "christmas", "winter", "snow", "xmas", "santa", "holiday",
                    "easter", "bunny", "egg",
                    "valentine", "love", "heart",
                    "summer", "beach", "sun", "vacation",
                    "autumn", "fall", "harvest",
                    "spring", "blossom",

                    "4july", "july", "independence", "firework",
                    "birthday", "anniversary", "celebration", "cake",
                    "newyear", "ny", "countdown",
                    "thanksgiving", "turkey", "feast",

                    "event", "limited", "special", "exclusive", "festive",

                    "cache", "box", "gacha", "crate"
                )

                val isEventItem = specialItemsKeyword.any { keyword ->
                    item.idInXML.contains(keyword, ignoreCase = true)
                }

                if (isEventItem) continue

                val lvlMin = item.element.getElementsByTagName("lvl_min").item(0)?.textContent?.toIntOrNull() ?: 0
                val lvlMax = item.element.getElementsByTagName("lvl_max").item(0)?.textContent?.toIntOrNull()
                    ?: Int.MAX_VALUE
                if (parameter.areaLevel !in (lvlMin..lvlMax)) continue

                val rarity = item.element.getAttribute("rarity").toIntOrNull() ?: 1
                val type = item.element.getAttribute("type")
                val quality = item.element.getAttribute("quality")

                val baseWeight = parameter.itemWeightOverrides[item.idInXML]
                    ?: (parameter.baseWeight / rarity.toDouble())

                val itemBoost = parameter.specificItemBoost[item.idInXML] ?: 0.0
                val typeBoost = parameter.itemTypeBoost[type] ?: 0.0
                val qualityBoost = parameter.itemQualityBoost[quality] ?: 0.0

                val totalMultiplier = (1.0 + itemBoost) * (1.0 + typeBoost) * (1.0 + qualityBoost)

                val finalWeight = (baseWeight * totalMultiplier).coerceAtLeast(0.0001)

                cumulativeWeight += finalWeight
                treeMap[cumulativeWeight] = createLootContent(item)
            }

            if (treeMap.isNotEmpty()) {
                cumulativeLootsPerLoc[loc] = treeMap
                totalWeightPerLoc[loc] = cumulativeWeight
            }
        }
    }

    fun insertLoots(): String {
        val docBuilder: DocumentBuilder = DocumentBuilderFactory.newInstance().newDocumentBuilder()
        val doc: Document = docBuilder.parse(InputSource(StringReader(sceneXML)))

        val eList = doc.getElementsByTagName("e")
        for (i in 0 until eList.length) {
            val eNode = eList.item(i) as? Element ?: continue

            val optNode = eNode.getElementsByTagName("opt").item(0) as? Element ?: continue
            val srchNode = optNode.getElementsByTagName("srch").item(0) ?: continue

            val hasItms = (0 until eNode.childNodes.length)
                .map { eNode.childNodes.item(it) }
                .any { it is Element && it.tagName == "itms" }

            if (!hasItms) {
                val itmsElement = doc.createElement("itms")

                val loots = getRollsFromLocs(srchNode.textContent.split(","))
                for ((id, type, q) in loots) {
                    val itm = doc.createElement("itm")
                    itm.setAttribute("id", id)
                    itm.setAttribute("type", type)
                    itm.setAttribute("q", q.toString())
                    itmsElement.appendChild(itm)
                }

                insertedLoots.addAll(loots)
                eNode.appendChild(itmsElement)
            }
        }

        val transformer = TransformerFactory.newInstance().newTransformer().apply {
            setOutputProperty(OutputKeys.INDENT, "yes")
            setOutputProperty("{http://xml.apache.org/xslt}indent-amount", "2")
        }

        val writer = StringWriter()
        transformer.transform(DOMSource(doc), StreamResult(writer))
        return writer.toString()
    }

    private fun getRollsFromLocs(locs: List<String>): List<LootContent> {
        val lootsAmount = (0..6).random()
        val lootResults: MutableList<LootContent> = mutableListOf()

        val shuffledLocs = locs.shuffled()
        var i = 0

        while (lootResults.size < lootsAmount) {
            val loc = shuffledLocs[i % shuffledLocs.size]
            weightedRandomTree(loc)?.let { lootResults.add(it) }
            i += 1
        }

        return lootResults
    }

    private fun weightedRandomTree(loc: String): LootContent? {
        val possibleLoots = cumulativeLootsPerLoc[loc] ?: return null
        val totalWeight = totalWeightPerLoc[loc] ?: return null
        val roll = Random.nextDouble(0.0, totalWeight)
        return possibleLoots.ceilingEntry(roll)?.value
    }

    private fun createLootContent(res: ItemResource): LootContent {
        val element = res.element
        val qntMin = element.getElementsByTagName("qnt_min").item(0)?.textContent?.toIntOrNull() ?: 1
        val qntMax = element.getElementsByTagName("qnt_max").item(0)?.textContent?.toIntOrNull() ?: 1
        val min = minOf(qntMin, qntMax)
        val max = maxOf(qntMin, qntMax)
        val qty = (min..max).random()

        return LootContent(
            itemId = UUID.new(),
            itemIdInXML = res.idInXML,
            quantity = qty,
        )
    }
}

===== C:\Users\Sulivan\Desktop\Projects\DeadZone-Private-Server\src\main\kotlin\core\mission\model\LootContent.kt =====
package dev.deadzone.core.mission.model

data class LootContent(
    val itemId: String,
    val itemIdInXML: String,
    val quantity: Int,
)

===== C:\Users\Sulivan\Desktop\Projects\DeadZone-Private-Server\src\main\kotlin\core\mission\model\LootParameter.kt =====
package dev.deadzone.core.mission.model

data class LootParameter(
    val areaLevel: Int,
    val playerLevel: Int, // not used yet
    val itemWeightOverrides: Map<String, Double> = emptyMap(), // absolute override if needed
    val specificItemBoost: Map<String, Double> = emptyMap(),   // e.g. "fuel" to 0.2 (+20%)
    val itemTypeBoost: Map<String, Double> = emptyMap(),       // e.g. "weapon" to 0.1 (+10%)
    val itemQualityBoost: Map<String, Double> = emptyMap(),    // e.g. "blue" to -0.4 (-40%)
    val baseWeight: Double = 1.0,
    val fuelLimit: Int = 0 // not used yet
)

===== C:\Users\Sulivan\Desktop\Projects\DeadZone-Private-Server\src\main\kotlin\core\mission\model\MissionCollection.kt =====
package dev.deadzone.core.model.game.data

import kotlinx.serialization.Serializable
import dev.deadzone.core.model.game.data.MissionData

@Serializable
data class MissionCollection(
    val list: List<MissionData> = listOf()
)

===== C:\Users\Sulivan\Desktop\Projects\DeadZone-Private-Server\src\main\kotlin\core\mission\model\MissionData.kt =====
package dev.deadzone.core.model.game.data

import kotlinx.serialization.Serializable
import dev.deadzone.core.items.model.Item

@Serializable
data class MissionData(
    val id: String,
    val player: SurvivorData,
    val stats: MissionStats? = null,
    val xpEarned: Int,
    val xp: Map<String, Int> = emptyMap(),
    val completed: Boolean,
    val assignmentId: String,
    val assignmentType: String,
    val playerId: String? = null,
    val compound: Boolean = false,
    val areaLevel: Int = 1,
    val areaId: String = "",
    val type: String = "",
    val suburb: String = "",
    val automated: Boolean = false,
    val survivors: List<Map<String, String>> = emptyList(), //survivor ids to mission ids
    val srvDown: List<Map<String, String>> = emptyList(), //survivor ids
    val buildingsDestroyed: List<String> = emptyList(), //building ids
    val returnTimer: TimerData? = null,
    val lockTimer: TimerData? = null,
    val loot: List<Item> = emptyList(),
    val highActivityIndex: Int? = null
) {
    companion object {
        fun dummy(srvId: String): MissionData {
            return MissionData(
                id = "mission001",
                player = SurvivorData.dummy(srvId),
                xpEarned = 50,
                xp = mapOf("mission" to 50),
                completed = false,
                assignmentId = "compoundTutorial",
                assignmentType = "tutorial",
                compound = true,
                type = "compound",
                survivors = listOf(mapOf("id" to srvId))
            )
        }
    }
}

===== C:\Users\Sulivan\Desktop\Projects\DeadZone-Private-Server\src\main\kotlin\core\mission\model\MissionDataConstants.kt =====
package dev.deadzone.core.model.game.data

import kotlinx.serialization.Serializable

@Serializable
@JvmInline
value class MissionDataConstants(val value: Int)

object MissionDataConstants_Constants {
    val DANGER_NORMAL = MissionDataConstants(0)
    val DANGER_LOW = MissionDataConstants(0)
    val DANGER_MODERATE = MissionDataConstants(1)
    val DANGER_DANGEROUS = MissionDataConstants(2)
    val DANGER_HIGH = MissionDataConstants(3)
    val DANGER_EXTREME = MissionDataConstants(4)
}

===== C:\Users\Sulivan\Desktop\Projects\DeadZone-Private-Server\src\main\kotlin\core\mission\model\MissionStats.kt =====
package dev.deadzone.core.model.game.data

import kotlinx.serialization.Serializable

@Serializable
data class MissionStats(
    val zombieSpawned: Int = 0,
    val levelUps: Int = 0,
    val damageOutput: Double = 0.0,
    val damageTaken: Double = 0.0,
    val containersSearched: Int = 0,
    val survivorKills: Int = 0,
    val survivorsDowned: Int = 0,
    val survivorExplosiveKills: Int = 0,
    val humanKills: Int = 0,
    val humanExplosiveKills: Int = 0,
    val zombieKills: Int = 0,
    val zombieExplosiveKills: Int = 0,
    val hpHealed: Int = 0,
    val explosivesPlaced: Int = 0,
    val grenadesThrown: Int = 0,
    val grenadesSmokeThrown: Int = 0,
    val allianceFlagCaptured: Int = 0,
    val buildingsDestroyed: Int = 0,
    val buildingsLost: Int = 0,
    val buildingsExplosiveDestroyed: Int = 0,
    val trapsTriggered: Int = 0,
    val trapDisarmTriggered: Int = 0,
    val cashFound: Int = 0,
    val woodFound: Int = 0,
    val metalFound: Int = 0,
    val clothFound: Int = 0,
    val foodFound: Int = 0,
    val waterFound: Int = 0,
    val ammunitionFound: Int = 0,
    val ammunitionUsed: Int = 0,
    val weaponsFound: Int = 0,
    val gearFound: Int = 0,
    val junkFound: Int = 0,
    val medicalFound: Int = 0,
    val craftingFound: Int = 0,
    val researchFound: Int = 0,
    val researchNoteFound: Int = 0,
    val clothingFound: Int = 0,
    val cratesFound: Int = 0,
    val schematicsFound: Int = 0,
    val effectFound: Int = 0,
    val rareWeaponFound: Int = 0,
    val rareGearFound: Int = 0,
    val uniqueWeaponFound: Int = 0,
    val uniqueGearFound: Int = 0,
    val greyWeaponFound: Int = 0,
    val greyGearFound: Int = 0,
    val whiteWeaponFound: Int = 0,
    val whiteGearFound: Int = 0,
    val greenWeaponFound: Int = 0,
    val greenGearFound: Int = 0,
    val blueWeaponFound: Int = 0,
    val blueGearFound: Int = 0,
    val purpleWeaponFound: Int = 0,
    val purpleGearFound: Int = 0,
    val premiumWeaponFound: Int = 0,
    val premiumGearFound: Int = 0,
    val killData: Map<String, Int> = mapOf(),
    val customData: Map<String, Int> = mapOf()
)

===== C:\Users\Sulivan\Desktop\Projects\DeadZone-Private-Server\src\main\kotlin\core\mission\model\ZombieData.kt =====
package dev.deadzone.core.model.game.data

import kotlinx.serialization.Serializable

@Serializable
data class ZombieData(
    val id: Int,
    val type: String,
    val weapon: String
) {
    companion object {
        fun standardZombieWeakAttack(id: Int): ZombieData {
            return ZombieData(id = id, type = "standard", weapon = "zStrike")
        }

        fun dogStandard(id: Int): ZombieData {
            return ZombieData(id = id, type = "dog", weapon = "zDogBite")
        }

        fun fatWalkerStrongAttack(id: Int): ZombieData {
            return ZombieData(id = id, type = "fat-walker", weapon = "zStrongStrike")
        }

        fun police20ZWeakAttack(id: Int): ZombieData {
            return ZombieData(id = id, type = "police-20", weapon = "zStrike")
        }

        fun riotWalker37MediumAttack(id: Int): ZombieData {
            return ZombieData(id = id, type = "riot-walker-37", weapon = "zMediumStrike")
        }

        fun dogTank(id: Int): ZombieData {
            return ZombieData(id = id, type = "dog-tank", weapon = "zDogBite")
        }

        fun strongRunner(id: Int): ZombieData {
            return ZombieData(id = id, type = "strong-runner", weapon = "zKnockbackStrike")
        }
    }
}

fun ZombieData.toFlatList(): List<String> {
    return listOf("$id", type, weapon)
}

===== C:\Users\Sulivan\Desktop\Projects\DeadZone-Private-Server\src\main\kotlin\core\model\data\AllianceDialogState.kt =====
package dev.deadzone.core.model.data

import kotlinx.serialization.Serializable

@Serializable
@JvmInline
value class AllianceDialogState(val value: Int)

object AllianceDialogState_Constants {
    val SHOW_NONE = AllianceDialogState(0)
    val SHOW_ALLIANCE_DIALOG = AllianceDialogState(1)
    val SHOW_INDIVIDUALS = AllianceDialogState(2)
    val SHOW_TOP_100 = AllianceDialogState(3)
}

===== C:\Users\Sulivan\Desktop\Projects\DeadZone-Private-Server\src\main\kotlin\core\model\data\CostEntry.kt =====
package dev.deadzone.core.model.data

import kotlinx.serialization.Serializable

@Serializable
data class CostEntry(
    val key: String,
    val type: String?
)

===== C:\Users\Sulivan\Desktop\Projects\DeadZone-Private-Server\src\main\kotlin\core\model\data\CostTable.kt =====
package dev.deadzone.core.model.data

import kotlinx.serialization.Serializable
import dev.deadzone.core.model.data.CostEntry

@Serializable
data class CostTable(
    val objectsByKey: Map<String, CostEntry> = mapOf(),
    val categories: Map<String, Map<String, CostEntry>> = mapOf()
)

===== C:\Users\Sulivan\Desktop\Projects\DeadZone-Private-Server\src\main\kotlin\core\model\data\Currency.kt =====
package dev.deadzone.core.model.data

import kotlinx.serialization.Serializable

@Serializable
@JvmInline
value class Currency(val value: String)

object Currency_Constants {
    val FUEL = Currency("Coins")
    val FACEBOOK_CREDITS = Currency("FBC")
    val US_DOLLARS = Currency("USD")
    val KONGREGATE_KREDS = Currency("KKR")
    val ALLIANCE_TOKENS = Currency("ATK")
}

===== C:\Users\Sulivan\Desktop\Projects\DeadZone-Private-Server\src\main\kotlin\core\model\data\FlagSet.kt =====
package dev.deadzone.core.model.data

import kotlinx.serialization.Serializable

/**
 * Bytearray of booleans
 *
 * Content of booleans depend on [core.metadata.model.PlayerFlags]
 */
@Serializable
data class FlagSet(
    val byteArray: ByteArray = byteArrayOf()
) {
    companion object {
        fun mockFlagSetByteArray(bitCount: Int = 256): ByteArray {
            val byteSize = (bitCount + 7) / 8 // round up
            val data = ByteArray(byteSize)

            for (i in 0 until byteSize) {
                data[i] = 0b00000001 // only first bit set
            }

            return data
        }
    }
}

===== C:\Users\Sulivan\Desktop\Projects\DeadZone-Private-Server\src\main\kotlin\core\model\data\HighActivity.kt =====
package dev.deadzone.core.model.data

import kotlinx.serialization.Serializable

@Serializable
data class HighActivity(
    val buildings: List<String>,  // building ids
)

===== C:\Users\Sulivan\Desktop\Projects\DeadZone-Private-Server\src\main\kotlin\core\model\data\KeyFlags.kt =====
package dev.deadzone.core.model.data

import kotlinx.serialization.Serializable

@Serializable
@JvmInline
value class KeyFlags(val value: UInt)

object KeyFlags_Constants {
    val NONE = KeyFlags(0u)
    val CONTROL = KeyFlags(1u)
    val SHIFT = KeyFlags(2u)
}

===== C:\Users\Sulivan\Desktop\Projects\DeadZone-Private-Server\src\main\kotlin\core\model\data\NavigationLocation.kt =====
package dev.deadzone.core.model.data

import kotlinx.serialization.Serializable

@Serializable
@JvmInline
value class NavigationLocation(val value: String)

object NavigationLocation_Constants {
    val PLAYER_COMPOUND = NavigationLocation("playerCompound")
    val NEIGHBOR_COMPOUND = NavigationLocation("neighborCompound")
    val MISSION = NavigationLocation("mission")
    val MISSION_PLANNING = NavigationLocation("missionPlanning")
    val WORLD_MAP = NavigationLocation("worldmap")
}

===== C:\Users\Sulivan\Desktop\Projects\DeadZone-Private-Server\src\main\kotlin\core\model\data\NewsArticle.kt =====
package dev.deadzone.core.model.data

import kotlinx.serialization.Serializable

@Serializable
data class NewsArticle(
    val date: Long,
    val body: String
)

===== C:\Users\Sulivan\Desktop\Projects\DeadZone-Private-Server\src\main\kotlin\core\model\data\Notification.kt =====
package dev.deadzone.core.model.data

import kotlinx.serialization.Serializable

@Serializable
data class Notification(
    val type: String?, // notification: type
    val data: String?,
)

===== C:\Users\Sulivan\Desktop\Projects\DeadZone-Private-Server\src\main\kotlin\core\model\data\PlayerUpgrades.kt =====
package dev.deadzone.core.model.data

import kotlinx.serialization.Serializable

@Serializable
@JvmInline
value class PlayerUpgrades(val value: Int)

object PlayerUpgrades_Constants {
    val DeathMobileUpgrade = PlayerUpgrades(0)
    val TradeSlotUpgrade = PlayerUpgrades(1)
    val InventoryUpgrade1_UNUSED = PlayerUpgrades(2)
}

===== C:\Users\Sulivan\Desktop\Projects\DeadZone-Private-Server\src\main\kotlin\core\model\data\PrevLogin.kt =====
package dev.deadzone.core.model.data

import kotlinx.serialization.Serializable

@Serializable
data class PrevLogin(
    val date: Long
)

===== C:\Users\Sulivan\Desktop\Projects\DeadZone-Private-Server\src\main\kotlin\core\model\data\RequirementTypes.kt =====
package dev.deadzone.core.model.data

import kotlinx.serialization.Serializable

@Serializable
@JvmInline
value class RequirementTypes(val value: UInt)

object RequirementTypes_Constants {
    val None = RequirementTypes(0u)
    val PlayerLevel = RequirementTypes(2u)
    val Buildings = RequirementTypes(4u)
    val Survivors = RequirementTypes(8u)
    val Items = RequirementTypes(16u)
    val Resources = RequirementTypes(32u)
    val Skills = RequirementTypes(64u)
    val All = RequirementTypes(16777215u)
    val NotItemsResources = RequirementTypes(16777167u)
    val ItemsResources = RequirementTypes(48u)
}

===== C:\Users\Sulivan\Desktop\Projects\DeadZone-Private-Server\src\main\kotlin\core\model\data\user\AbstractUser.kt =====
package dev.deadzone.core.model.data.user

import kotlinx.serialization.Serializable
import dev.deadzone.core.model.data.Currency
import dev.deadzone.core.model.data.user.UserData

@Serializable
data class AbstractUser(
    val data: UserData,
    val email: String,
    val time: Long,
    val defaultCurrency: String // Currency constants
)

===== C:\Users\Sulivan\Desktop\Projects\DeadZone-Private-Server\src\main\kotlin\core\model\data\user\PlayerIOUser.kt =====
package dev.deadzone.core.model.data.user

import kotlinx.serialization.Serializable
import dev.deadzone.core.model.data.user.AbstractUser
import dev.deadzone.core.model.data.user.PublishingNetworkProfile

@Serializable
data class PlayerIOUser(
    val abstractUser: AbstractUser,
    val profile: PublishingNetworkProfile
)

===== C:\Users\Sulivan\Desktop\Projects\DeadZone-Private-Server\src\main\kotlin\core\model\data\user\PublishingNetworkProfile.kt =====
package dev.deadzone.core.model.data.user

import kotlinx.serialization.Serializable

@Serializable
data class PublishingNetworkProfile(
    val userId: String,
    val displayName: String,
    val avatarUrl: String,
    val lastOnline: Long,
    val countryCode: String
)

===== C:\Users\Sulivan\Desktop\Projects\DeadZone-Private-Server\src\main\kotlin\core\model\data\user\UserData.kt =====
package dev.deadzone.core.model.data.user

import kotlinx.serialization.Serializable

@Serializable
data class UserData(
    val email: String
)

===== C:\Users\Sulivan\Desktop\Projects\DeadZone-Private-Server\src\main\kotlin\core\model\game\data\AmmoType.kt =====
package dev.deadzone.core.model.game.data

import kotlinx.serialization.Serializable

@Serializable
data class AmmoType(
    val NONE: UInt = 0u,
    val ARROW: UInt = 1u,
    val ASSAULT_RIFLE: UInt = 2u,
    val BOLT: UInt = 4u,
    val LONG_RIFLE: UInt = 8u,
    val PISTOL: UInt = 16u,
    val SHOTGUN: UInt = 32u,
    val SMG: UInt = 64u
)

===== C:\Users\Sulivan\Desktop\Projects\DeadZone-Private-Server\src\main\kotlin\core\model\game\data\BatchRecycleJob.kt =====
package dev.deadzone.core.model.game.data

import kotlinx.serialization.Serializable
import dev.deadzone.core.items.model.Item

@Serializable
data class BatchRecycleJob(
    val id: String,
    val items: List<Item>,
    val start: Long,
    val end: Int
)

===== C:\Users\Sulivan\Desktop\Projects\DeadZone-Private-Server\src\main\kotlin\core\model\game\data\BatchRecycleJobCollection.kt =====
package dev.deadzone.core.model.game.data

import kotlinx.serialization.Serializable
import dev.deadzone.core.model.game.data.BatchRecycleJob

@Serializable
data class BatchRecycleJobCollection(
    val list: List<BatchRecycleJob> = listOf()
)

===== C:\Users\Sulivan\Desktop\Projects\DeadZone-Private-Server\src\main\kotlin\core\model\game\data\CooldownCollection.kt =====
package dev.deadzone.core.model.game.data

import kotlinx.serialization.Serializable

@Serializable
data class CooldownCollection(
    val byteArray: Map<String, ByteArray> = mapOf(),  // will be parsed to Cooldown
)

===== C:\Users\Sulivan\Desktop\Projects\DeadZone-Private-Server\src\main\kotlin\core\model\game\data\CraftingInfo.kt =====
package dev.deadzone.core.model.game.data

import kotlinx.serialization.Serializable

@Serializable
data class CraftingInfo(
    val user_id: String,
    val user_name: String,
    val date: Long
)

===== C:\Users\Sulivan\Desktop\Projects\DeadZone-Private-Server\src\main\kotlin\core\model\game\data\DamageType.kt =====
package dev.deadzone.core.model.game.data

import kotlinx.serialization.Serializable

@Serializable
data class DamageType(
    val UNKNOWN: UInt = 0u,
    val MELEE: UInt = 1u,
    val PROJECTILE: UInt = 2u,
    val EXPLOSIVE: UInt = 3u
)

===== C:\Users\Sulivan\Desktop\Projects\DeadZone-Private-Server\src\main\kotlin\core\model\game\data\EffectCollection.kt =====
package dev.deadzone.core.model.game.data

import kotlinx.serialization.Serializable
import dev.deadzone.core.model.game.data.effects.Effect

@Serializable
data class EffectCollection(
    val list: List<ByteArray> = listOf()
) {
    fun dummy(): EffectCollection {
        return EffectCollection(
            list = listOf(byteArrayOf())
        )
    }
}

===== C:\Users\Sulivan\Desktop\Projects\DeadZone-Private-Server\src\main\kotlin\core\model\game\data\EnemyResults.kt =====
package dev.deadzone.core.model.game.data

import kotlinx.serialization.Serializable
import dev.deadzone.core.items.model.Item

@Serializable
data class EnemyResults(
    val attackerId: String,
    val attackerNickname: String,
    val numSrvDown: Int = 0,
    val survivors: List<String> = listOf(),  // survivor ids
    val srvDown: List<String> = listOf(),  // survivor ids
    val loot: List<Item> = listOf(),
    val prodBuildingsRaided: List<String> = listOf(),  // building ids
    val buildingsDestroyed: List<String> = listOf(),  // building ids
    val trapsTriggered: List<String> = listOf(),  // building ids
    val trapsDisarmed: List<String> = listOf(),  // building ids
    val totalBuildingsLooted: Int?
)

===== C:\Users\Sulivan\Desktop\Projects\DeadZone-Private-Server\src\main\kotlin\core\model\game\data\Task.kt =====
package dev.deadzone.core.model.game.data

import kotlinx.serialization.Serializable
import dev.deadzone.core.items.model.Item

@Serializable
data class Task(
    val id: String,
    val type: String,
    val length: Int,
    val time: Double,
    val items: List<Item>?,
    val completed: Boolean,
    val survivors: List<String>,  // survivor ids
)

===== C:\Users\Sulivan\Desktop\Projects\DeadZone-Private-Server\src\main\kotlin\core\model\game\data\TaskCollection.kt =====
package dev.deadzone.core.model.game.data

import kotlinx.serialization.Serializable
import dev.deadzone.core.model.game.data.Task

@Serializable
data class TaskCollection(
    val list: List<Task> = listOf()
)

===== C:\Users\Sulivan\Desktop\Projects\DeadZone-Private-Server\src\main\kotlin\core\model\game\data\TaskStatus.kt =====
package dev.deadzone.core.model.game.data

import kotlinx.serialization.Serializable

@Serializable
@JvmInline
value class TaskStatus(val value: String)

object TaskStatus_Constants {
    val ACTIVE = TaskStatus("active")
    val INACTIVE = TaskStatus("inactive")
    val COMPLETE = TaskStatus("complete")
}

===== C:\Users\Sulivan\Desktop\Projects\DeadZone-Private-Server\src\main\kotlin\core\model\game\data\TaskType.kt =====
package dev.deadzone.core.model.game.data

import kotlinx.serialization.Serializable

@Serializable
@JvmInline
value class TaskType(val value: String)

object TaskType_Constants {
    val JUNK_REMOVAL = TaskType("junk_removal")
    val ITEM_CRAFTING = TaskType("item_crafting")
}

===== C:\Users\Sulivan\Desktop\Projects\DeadZone-Private-Server\src\main\kotlin\core\model\game\data\TimerData.kt =====
package dev.deadzone.core.model.game.data

import dev.deadzone.utils.AnyMapSerializer
import io.ktor.util.date.*
import kotlinx.serialization.Serializable
import kotlin.time.Duration
import kotlin.time.Duration.Companion.seconds

@Serializable
data class TimerData(
    val start: Long, // epoch millis
    val length: Long, // length in seconds!
    @Serializable(with = AnyMapSerializer::class)
    val data: Map<String, Any>? // this depends on each response. e.g., building upgrade need level
) {
    companion object {
        fun runForDuration(
            duration: Duration,
            data: Map<String, Any>? = emptyMap()
        ): TimerData {
            return TimerData(
                start = getTimeMillis(),
                length = duration.inWholeSeconds,
                data = data
            )
        }
    }
}

data class SocketTimerData(
    val start: Long, // epoch millis
    val length: Long, // length in seconds!
    @Serializable(with = AnyMapSerializer::class)
    val data: Map<String, Any>? // this depends on each response. e.g., building upgrade need level
)

fun TimerData.hasEnded(): Boolean {
    return getTimeMillis() >= this.start + this.length.seconds.inWholeMilliseconds
}

===== C:\Users\Sulivan\Desktop\Projects\DeadZone-Private-Server\src\main\kotlin\core\model\game\data\Weapon.kt =====
package dev.deadzone.core.model.game.data

import kotlinx.serialization.Serializable
import dev.deadzone.core.survivor.model.injury.InjuryCause

@Serializable
data class Weapon(
    val attachments: List<String>,
    val burstFire: Boolean,
    val injuryCause: InjuryCause,
    val weaponClass: WeaponClass,
    val animType: String,
    val reloadAnim: String,
    val swingAnims: List<String>,
    val playSwingExertionSound: Boolean = true,
    val flags: UInt = 0u,
    val weaponType: UInt = 0u,
    val ammoType: UInt = 0u,
    val survivorClasses: List<String> = listOf()
)

===== C:\Users\Sulivan\Desktop\Projects\DeadZone-Private-Server\src\main\kotlin\core\model\game\data\WeaponClass.kt =====
package dev.deadzone.core.model.game.data

import kotlinx.serialization.Serializable

@Serializable
@JvmInline
value class WeaponClass(val value: String)

object WeaponClass_Constants {
    val ASSAULT_RIFLE = WeaponClass("assault_rifle")
    val BOW = WeaponClass("bow")
    val LAUNCHER = WeaponClass("launcher")
    val LONG_RIFLE = WeaponClass("long_rifle")
    val MELEE = WeaponClass("melee")
    val PISTOL = WeaponClass("pistol")
    val SHOTGUN = WeaponClass("shotgun")
    val SMG = WeaponClass("smg")
    val LMG = WeaponClass("lmg")
    val THROWN = WeaponClass("thrown")
    val HEAVY = WeaponClass("heavy")
}

===== C:\Users\Sulivan\Desktop\Projects\DeadZone-Private-Server\src\main\kotlin\core\model\game\data\WeaponData.kt =====
package dev.deadzone.core.model.game.data

import kotlinx.serialization.Serializable

@Serializable
data class WeaponData(
    val minRange: Double = 0.0,
    val minEffectiveRange: Double = 0.0,
    val range: Double = 0.0,
    val minRangeMod: Double = 0.0,
    val maxRangeMod: Double = 0.0,
    val burstAvg: Int = 0,
    val roundsInMagazine: Int = 0,
    val ammoCost: Double = 0.0,
    val damageMax: Double = 0.0,
    val damageMin: Double = 0.0,
    val damageMult: Double = 1.0,
    val damageMultVsBuilding: Double = 1.0,
    val accuracy: Double = 0.0,
    val capacity: Int = 0,
    val reloadTime: Double = 0.0,
    val fireRate: Double = 0.0,
    val noise: Double = 0.0,
    val idleNoise: Double = 0.0,
    val criticalChance: Double = 0.0,
    val knockbackChance: Double = 0.0,
    val dodgeChance: Double = 0.0,
    val isMelee: Boolean = false,
    val isExplosive: Boolean = false,
    val attackArcCosine: Double = 0.0,
    val suppressionRate: Double = 0.0,
    val goreMultiplier: Double = 1.0,
    val readyTime: Double = 0.0
)

===== C:\Users\Sulivan\Desktop\Projects\DeadZone-Private-Server\src\main\kotlin\core\model\game\data\WeaponFlags.kt =====
package dev.deadzone.core.model.game.data

import kotlinx.serialization.Serializable

@Serializable
@JvmInline
value class WeaponFlags(val value: UInt)

object WeaponFlags_Constants {
    val NONE = WeaponFlags(0u)
    val SUPPRESSED = WeaponFlags(1u)
}

===== C:\Users\Sulivan\Desktop\Projects\DeadZone-Private-Server\src\main\kotlin\core\model\game\data\WeaponType.kt =====
package dev.deadzone.core.model.game.data

import kotlinx.serialization.Serializable

@Serializable
@JvmInline
value class WeaponType(val value: UInt)

object WeaponType_Constants {
    val NONE = WeaponType(0u)
    val AUTO = WeaponType(1u)
    val SEMI_AUTO = WeaponType(2u)
    val ONE_HANDED = WeaponType(4u)
    val TWO_HANDED = WeaponType(8u)
    val IMPROVISED = WeaponType(16u)
    val EXPLOSIVE = WeaponType(32u)
    val BLADE = WeaponType(64u)
    val BLUNT = WeaponType(128u)
    val AXE = WeaponType(256u)
    val SPECIAL = WeaponType(512u)
}

===== C:\Users\Sulivan\Desktop\Projects\DeadZone-Private-Server\src\main\kotlin\core\model\game\data\alliance\AllianceBannerData.kt =====
package dev.deadzone.core.model.game.data.alliance

import kotlinx.serialization.Serializable

@Serializable
@JvmInline
value class AllianceBannerData(val value: Int)

object AllianceBannerData_Constants {
    val BASE_COLOR = AllianceBannerData(0)
    val DECAL_1 = AllianceBannerData(1)
    val DECAL_1_COLOR = AllianceBannerData(2)
    val DECAL_2 = AllianceBannerData(3)
    val DECAL_2_COLOR = AllianceBannerData(4)
    val DECAL_3 = AllianceBannerData(5)
    val DECAL_3_COLOR = AllianceBannerData(6)
}

===== C:\Users\Sulivan\Desktop\Projects\DeadZone-Private-Server\src\main\kotlin\core\model\game\data\alliance\AllianceData.kt =====
package dev.deadzone.core.model.game.data.alliance

import kotlinx.serialization.Serializable
import dev.deadzone.core.model.game.data.alliance.AllianceDataSummary
import dev.deadzone.core.model.game.data.alliance.AllianceList
import dev.deadzone.core.model.game.data.alliance.AllianceMemberList
import dev.deadzone.core.model.game.data.alliance.AllianceMessageList
import dev.deadzone.core.model.game.data.effects.Effect
import dev.deadzone.core.model.game.data.alliance.TargetRecord

@Serializable
data class AllianceData(
    val allianceDataSummary: AllianceDataSummary,
    val members: AllianceMemberList?,
    val messages: AllianceMessageList?,
    val enemies: AllianceList?,
    val ranks: Map<String, Int>?,
    val bannerEdits: Int,
    val effects: List<Effect>?,
    val tokens: Int?,
    val taskSet: Int?,
    val tasks: Map<String, Int>?, // string as key, but parsed to int
    val attackedTargets: Map<String, TargetRecord>?,
    val scoutedTargets: Map<String, TargetRecord>?
)

===== C:\Users\Sulivan\Desktop\Projects\DeadZone-Private-Server\src\main\kotlin\core\model\game\data\alliance\AllianceDataSummary.kt =====
package dev.deadzone.core.model.game.data.alliance

import kotlinx.serialization.Serializable

@Serializable
data class AllianceDataSummary(
    val allianceId: String?,
    val name: String?,
    val tag: String?,
    val banner: String?,  // can also be bytearray. if a string, will try to decodeToByteArray
    val thumbURI: String?,
    val memberCount: Int?,
    val efficiency: Double?,
    val points: Int?
)

===== C:\Users\Sulivan\Desktop\Projects\DeadZone-Private-Server\src\main\kotlin\core\model\game\data\alliance\AllianceLifetimeStats.kt =====
package dev.deadzone.core.model.game.data.alliance

import kotlinx.serialization.Serializable

@Serializable
data class AllianceLifetimeStats(
    val userName: String?,
    val points: Int,
    val wins: Int,
    val losses: Int,
    val abandons: Int,
    val defWins: Int,
    val defLosses: Int,
    val pointsAttack: Int,
    val pointsDefend: Int,
    val missionSuccess: Int,
    val missionFail: Int,
    val missionAbandon: Int,
    val pointsMission: Int
)

===== C:\Users\Sulivan\Desktop\Projects\DeadZone-Private-Server\src\main\kotlin\core\model\game\data\alliance\AllianceList.kt =====
package dev.deadzone.core.model.game.data.alliance

import kotlinx.serialization.Serializable
import dev.deadzone.core.model.game.data.alliance.AllianceDataSummary

@Serializable
data class AllianceList(
    val list: List<AllianceDataSummary> = listOf()
)

===== C:\Users\Sulivan\Desktop\Projects\DeadZone-Private-Server\src\main\kotlin\core\model\game\data\alliance\AllianceMember.kt =====
package dev.deadzone.core.model.game.data.alliance

import kotlinx.serialization.Serializable

@Serializable
data class AllianceMember(
    val playerId: String,
    val nickname: String,
    val level: Int,
    val joindate: Long,
    val rank: UInt,
    val tokens: UInt,
    val online: Boolean,
    val points: UInt,
    val pointsAttack: UInt,
    val pointsDefend: UInt,
    val pointsMission: UInt,
    val efficiency: Double,
    val wins: Int,
    val losses: Int,
    val abandons: Int,
    val defWins: Int,
    val defLosses: Int,
    val missionSuccess: Int,
    val missionFail: Int,
    val missionAbandon: Int,
    val missionEfficiency: Double,
    val raidWinPts: UInt,
    val raidLosePts: UInt
)

===== C:\Users\Sulivan\Desktop\Projects\DeadZone-Private-Server\src\main\kotlin\core\model\game\data\alliance\AllianceMemberList.kt =====
package dev.deadzone.core.model.game.data.alliance

import kotlinx.serialization.Serializable
import dev.deadzone.core.model.game.data.alliance.AllianceMember

@Serializable
data class AllianceMemberList(
    val list: List<AllianceMember>
)

===== C:\Users\Sulivan\Desktop\Projects\DeadZone-Private-Server\src\main\kotlin\core\model\game\data\alliance\AllianceMessage.kt =====
package dev.deadzone.core.model.game.data.alliance

import kotlinx.serialization.Serializable

@Serializable
data class AllianceMessage(
    val id: String,
    val date: Long,
    val playerId: String,
    val author: String,
    val title: String,
    val message: String
)

===== C:\Users\Sulivan\Desktop\Projects\DeadZone-Private-Server\src\main\kotlin\core\model\game\data\alliance\AllianceMessageList.kt =====
package dev.deadzone.core.model.game.data.alliance

import kotlinx.serialization.Serializable
import dev.deadzone.core.model.game.data.alliance.AllianceMessage

@Serializable
data class AllianceMessageList(
    val list: List<AllianceMessage> = listOf()
)

===== C:\Users\Sulivan\Desktop\Projects\DeadZone-Private-Server\src\main\kotlin\core\model\game\data\alliance\AllianceRank.kt =====
package dev.deadzone.core.model.game.data.alliance

import kotlinx.serialization.Serializable

@Serializable
data class AllianceRank(
    val maps: Map<UInt, UInt> = mapOf()
)

===== C:\Users\Sulivan\Desktop\Projects\DeadZone-Private-Server\src\main\kotlin\core\model\game\data\alliance\AllianceRankConstants.kt =====
package dev.deadzone.core.model.game.data.alliance

import kotlinx.serialization.Serializable

@Serializable
@JvmInline
value class AllianceRankConstants(val value: UInt)

object AllianceRankConstants_Constants {
    val RANK_1 = AllianceRankConstants(1u)
    val RANK_2 = AllianceRankConstants(2u)
    val RANK_3 = AllianceRankConstants(3u)
    val RANK_4 = AllianceRankConstants(4u)
    val RANK_5 = AllianceRankConstants(5u)
    val RANK_6 = AllianceRankConstants(6u)
    val RANK_7 = AllianceRankConstants(7u)
    val RANK_8 = AllianceRankConstants(8u)
    val RANK_9 = AllianceRankConstants(9u)
    val RANK_10 = AllianceRankConstants(10u)
    val FOUNDER = AllianceRankConstants(10u)
    val TWO_IC = AllianceRankConstants(9u)
}

===== C:\Users\Sulivan\Desktop\Projects\DeadZone-Private-Server\src\main\kotlin\core\model\game\data\alliance\AllianceRankPrivilege.kt =====
package dev.deadzone.core.model.game.data.alliance

import kotlinx.serialization.Serializable

@Serializable
@JvmInline
value class AllianceRankPrivilege(val value: UInt)

object AllianceRankPrivilege_Constants {
    val None = AllianceRankPrivilege(0u)
    val ChangeLeadership = AllianceRankPrivilege(1u)
    val Disband = AllianceRankPrivilege(2u)
    val PostMessages = AllianceRankPrivilege(4u)
    val DeleteMessages = AllianceRankPrivilege(8u)
    val InviteMembers = AllianceRankPrivilege(16u)
    val RemoveMembers = AllianceRankPrivilege(32u)
    val PromoteMembers = AllianceRankPrivilege(64u)
    val DemoteMembers = AllianceRankPrivilege(128u)
    val SpendTokens = AllianceRankPrivilege(256u)
    val EditRankNames = AllianceRankPrivilege(512u)
    val EditBanner = AllianceRankPrivilege(1024u)
    val All = AllianceRankPrivilege(1048575u)
}

===== C:\Users\Sulivan\Desktop\Projects\DeadZone-Private-Server\src\main\kotlin\core\model\game\data\alliance\AllianceRound.kt =====
package dev.deadzone.core.model.game.data.alliance

import kotlinx.serialization.Serializable
import dev.deadzone.core.model.game.data.effects.Effect

@Serializable
data class AllianceRound(
    val roundNum: Int?,
    val roundActive: Long?,
    val roundEnd: Long?,
    val roundEffects: List<Effect>?,
    val roundMembers: Int?
)

===== C:\Users\Sulivan\Desktop\Projects\DeadZone-Private-Server\src\main\kotlin\core\model\game\data\alliance\AllianceTask.kt =====
package dev.deadzone.core.model.game.data.alliance

import kotlinx.serialization.Serializable

@Serializable
data class AllianceTask(
    val id: String,
    val imageURI: String,
    val iconType: String,
    val goalType: String,
    val goalId: String,
    val goalPerMember: Int,
    val tokensPerMember: Int
)

===== C:\Users\Sulivan\Desktop\Projects\DeadZone-Private-Server\src\main\kotlin\core\model\game\data\alliance\TargetRecord.kt =====
package dev.deadzone.core.model.game.data.alliance

import kotlinx.serialization.Serializable

@Serializable
data class TargetRecord(
    val user: String,
    val time: Long
)

===== C:\Users\Sulivan\Desktop\Projects\DeadZone-Private-Server\src\main\kotlin\core\model\game\data\arena\ArenaSession.kt =====
package dev.deadzone.core.model.game.data.arena

import kotlinx.serialization.Serializable
import dev.deadzone.core.model.game.data.assignment.AssignmentStageState

@Serializable
data class ArenaSession(
    val points: Int,
    val state: Map<String, AssignmentStageState> = mapOf()
)

===== C:\Users\Sulivan\Desktop\Projects\DeadZone-Private-Server\src\main\kotlin\core\model\game\data\arena\ArenaStageData.kt =====
package dev.deadzone.core.model.game.data.arena

import kotlinx.serialization.Serializable

@Serializable
data class ArenaStageData(
    val srvpoints: Int,
    val objpoints: Int
)

===== C:\Users\Sulivan\Desktop\Projects\DeadZone-Private-Server\src\main\kotlin\core\model\game\data\arena\ArenaSystem.kt =====
package dev.deadzone.core.model.game.data.arena

import kotlinx.serialization.Serializable
import dev.deadzone.core.model.game.data.CooldownCollection
import dev.deadzone.core.items.model.Item

@Serializable
data class ArenaSystem(
    val id: String,  // cased to ArenaSession, so must be one of the AssignmentType enum
    val srvcount: Int,
    val srvpoints: Int,
    val objpoints: Int,
    val completed: Boolean,
    val points: Int,
    val stage: Int,
    val returnsurvivors: List<String> = listOf(),  // survivor ids
    val cooldown: CooldownCollection = CooldownCollection(),
    val assignsuccess: Boolean,
    val items: List<Item> = listOf()
)

===== C:\Users\Sulivan\Desktop\Projects\DeadZone-Private-Server\src\main\kotlin\core\model\game\data\assignment\AssignmentCollection.kt =====
package dev.deadzone.core.model.game.data.assignment

import kotlinx.serialization.Serializable
import dev.deadzone.core.model.game.data.assignment.AssignmentData

@Serializable
data class AssignmentCollection(
    val list: List<AssignmentData> = listOf()
)

===== C:\Users\Sulivan\Desktop\Projects\DeadZone-Private-Server\src\main\kotlin\core\model\game\data\assignment\AssignmentData.kt =====
package dev.deadzone.core.model.game.data.assignment

import kotlinx.serialization.Serializable
import dev.deadzone.core.model.game.data.assignment.AssignmentStageData

@Serializable
data class AssignmentData(
    val name: String,
    val id: String,
    val started: Boolean,
    val competed: Boolean,
    val stageindex: Int,
    val survivors: List<String> = listOf(),  // survivor ids
    val stagelist: List<AssignmentStageData> = listOf()
)

===== C:\Users\Sulivan\Desktop\Projects\DeadZone-Private-Server\src\main\kotlin\core\model\game\data\assignment\AssignmentResult.kt =====
package dev.deadzone.core.model.game.data.assignment

import kotlinx.serialization.Serializable

@Serializable
data class AssignmentResult(
    val id: String,
    val type: String = AssignmentType_Constants.None.value
)

===== C:\Users\Sulivan\Desktop\Projects\DeadZone-Private-Server\src\main\kotlin\core\model\game\data\assignment\AssignmentStageData.kt =====
package dev.deadzone.core.model.game.data.assignment

import kotlinx.serialization.Serializable

@Serializable
data class AssignmentStageData(
    val level: Int,
    val time: Int,
    val state: Int,
    val srvcount: Int
)

===== C:\Users\Sulivan\Desktop\Projects\DeadZone-Private-Server\src\main\kotlin\core\model\game\data\assignment\AssignmentStageState.kt =====
package dev.deadzone.core.model.game.data.assignment

import kotlinx.serialization.Serializable

@Serializable
@JvmInline
value class AssignmentStageState(val value: UInt)

object AssignmentStageState_Constants {
    val LOCKED = AssignmentStageState(0u)
    val ACTIVE = AssignmentStageState(1u)
    val COMPLETE = AssignmentStageState(2u)
}

===== C:\Users\Sulivan\Desktop\Projects\DeadZone-Private-Server\src\main\kotlin\core\model\game\data\assignment\AssignmentType.kt =====
package dev.deadzone.core.model.game.data.assignment

import kotlinx.serialization.Serializable

@Serializable
@JvmInline
value class AssignmentType(val value: String)

object AssignmentType_Constants {
    val None = AssignmentType("None")
    val Raid = AssignmentType("Raid")
    val Arena = AssignmentType("Arena")
}

===== C:\Users\Sulivan\Desktop\Projects\DeadZone-Private-Server\src\main\kotlin\core\model\game\data\bounty\InfectedBounty.kt =====
package dev.deadzone.core.model.game.data.bounty

import kotlinx.serialization.Serializable
import dev.deadzone.core.model.game.data.bounty.InfectedBountyTask

@Serializable
data class InfectedBounty(
    val id: String,
    val completed: Boolean,
    val abandoned: Boolean,
    val viewed: Boolean,
    val rewardItemId: String,
    val issueTime: Long,
    val tasks: List<InfectedBountyTask> = listOf()
)

===== C:\Users\Sulivan\Desktop\Projects\DeadZone-Private-Server\src\main\kotlin\core\model\game\data\bounty\InfectedBountyTask.kt =====
package dev.deadzone.core.model.game.data.bounty

import kotlinx.serialization.Serializable
import dev.deadzone.core.model.game.data.bounty.InfectedBountyTaskCondition

@Serializable
data class InfectedBountyTask(
    val suburb: String,
    val conditions: List<InfectedBountyTaskCondition> = listOf()
)

===== C:\Users\Sulivan\Desktop\Projects\DeadZone-Private-Server\src\main\kotlin\core\model\game\data\bounty\InfectedBountyTaskCondition.kt =====
package dev.deadzone.core.model.game.data.bounty

import kotlinx.serialization.Serializable

@Serializable
data class InfectedBountyTaskCondition(
    val zombieType: String,
    val killsRequired: Int,
    val kills: Int
)

===== C:\Users\Sulivan\Desktop\Projects\DeadZone-Private-Server\src\main\kotlin\core\model\game\data\effects\Cooldown.kt =====
package dev.deadzone.core.model.game.data.effects

import kotlinx.serialization.Serializable
import dev.deadzone.core.model.game.data.TimerData

@Serializable
data class Cooldown(
    val raw: ByteArray,  // see readObject of Cooldown
    val id: String,
    val type: UInt,
    val subType: String,
    val timer: TimerData
)

===== C:\Users\Sulivan\Desktop\Projects\DeadZone-Private-Server\src\main\kotlin\core\model\game\data\effects\CooldownType.kt =====
package dev.deadzone.core.model.game.data.effects

import kotlinx.serialization.Serializable

@Serializable
@JvmInline
value class CooldownType(val value: UInt)

object CooldownType_Constants {
    val Unknown = CooldownType(0u)
    val DisablePvP = CooldownType(1u)
    val Purchase = CooldownType(2u)
    val ResetLeaderAttributes = CooldownType(3u)
    val Raid = CooldownType(4u)
    val Arena = CooldownType(5u)
}

===== C:\Users\Sulivan\Desktop\Projects\DeadZone-Private-Server\src\main\kotlin\core\model\game\data\effects\Effect.kt =====
package dev.deadzone.core.model.game.data.effects

import kotlinx.serialization.Serializable
import dev.deadzone.core.model.game.data.effects.EffectData
import dev.deadzone.core.model.game.data.TimerData
import java.io.ByteArrayOutputStream
import java.io.DataOutputStream

@Serializable
data class Effect(
    val raw: ByteArray = byteArrayOf(),
    val type: String,
    val id: String,
    val lockTime: Int,
    val cooldownTime: Int,
    val started: Boolean = false,
    val timer: TimerData?,
    val lockoutTimer: TimerData?,
    val effectList: List<EffectData> = listOf(),
    val itemId: String?
) {
    companion object {
        fun dummyEffectByteArray(): ByteArray {
            val output = ByteArrayOutputStream()
            val data = DataOutputStream(output)

            data.writeUTF("VacationMode") // _type
            data.writeUTF("vacation")  // _id
            data.writeByte(0)         // unused byte
            data.writeInt(0)          // _lockTime
            data.writeInt(0)          // _cooldownTime

            data.writeByte(0) // No _timer

            data.writeByte(0) // No _lockoutTimer

            val effects = listOf(
                EffectData(100u, 10.0), // BarricadeHealth
                EffectData(101u, 5.0),  // BarricadeCover
                EffectData(102u, 8.0),  // etc...
                EffectData(103u, 4.0)
            )
            data.writeByte(effects.size) // number of effects

            for (effect in effects) {
                data.writeInt(effect.type.toInt())   // short
                data.writeDouble(effect.value)    // float
            }

            data.writeByte(0) // No itemId

            return output.toByteArray()
        }

        /**
         * Halloween trick pumpkin zombie effect is needed for starting mission
         */
        fun halloweenTrickPumpkinZombie(): ByteArray {
            val effectType = "HalloweenTrickPumpkinZombie"
            val effectId = "halloween-pumpkinzombies"

            val output = ByteArrayOutputStream()
            val data = DataOutputStream(output)

            data.writeUTF(effectType)
            data.writeUTF(effectId)
            data.writeByte(0)         // unused byte
            data.writeInt(0)          // _lockTime
            data.writeInt(0)          // _cooldownTime

            data.writeByte(0)         // No _timer
            data.writeByte(0)         // No _lockoutTimer

            val effects = listOf(
                EffectData(100u, 1.0)
            )

            data.writeByte(effects.size) // number of effects
            for (effect in effects) {
                data.writeInt(effect.type.toInt())   // int (not short)
                data.writeDouble(effect.value)       // double (not float)
            }

            data.writeByte(0) // No itemId

            return output.toByteArray()
        }

        /**
         * Halloween trick pew pew effect is needed for starting mission
         *
         * This is what it should do before checking pewVal > 0
         * pewVal = Network.getInstance().playerData.compound.getEffectValue(EffectType.getTypeValue("HalloweenTrickPewPew"));
         */
        fun halloweenTrickPewPew(): ByteArray {
            val effectType = "HalloweenTrickPewPew"
            val effectId = "halloween-pewpew"

            val output = ByteArrayOutputStream()
            val data = DataOutputStream(output)

            data.writeUTF(effectType)
            data.writeUTF(effectId)
            data.writeByte(0)         // unused byte
            data.writeInt(0)          // _lockTime
            data.writeInt(0)          // _cooldownTime

            data.writeByte(0)         // No _timer
            data.writeByte(0)         // No _lockoutTimer

            val effects:List<EffectData> = listOf(
                EffectData(207u, 1.0)
            )

            data.writeByte(effects.size) // number of effects
            for (effect in effects) {
                data.writeInt(effect.type.toInt())   // int (not short)
                data.writeDouble(effect.value)       // double (not float)
            }

            data.writeByte(0) // No itemId

            return output.toByteArray()
        }
    }
}

===== C:\Users\Sulivan\Desktop\Projects\DeadZone-Private-Server\src\main\kotlin\core\model\game\data\effects\EffectData.kt =====
package dev.deadzone.core.model.game.data.effects

import kotlinx.serialization.Serializable

@Serializable
data class EffectData(
    val type: UInt,
    val value: Double
)

===== C:\Users\Sulivan\Desktop\Projects\DeadZone-Private-Server\src\main\kotlin\core\model\game\data\effects\EffectSaveFlags.kt =====
package dev.deadzone.core.model.game.data.effects

import kotlinx.serialization.Serializable

@Serializable
@JvmInline
value class EffectSaveFlags(val value: UInt)

object EffectSaveFlags_Constants {
    val NONE = EffectSaveFlags(0u)
    val CONSUMABLE = EffectSaveFlags(1u)
    val PERMANENT = EffectSaveFlags(2u)
    val LINKED_ITEM = EffectSaveFlags(4u)
}

===== C:\Users\Sulivan\Desktop\Projects\DeadZone-Private-Server\src\main\kotlin\core\model\game\data\effects\EffectType.kt =====
package dev.deadzone.core.model.game.data.effects

import kotlinx.serialization.Serializable

@Serializable
@JvmInline
value class EffectType(val value: String)

object EffectType_Constants {
    val WOOD_PRODUCTION = EffectType("WoodProduction")
    val METAL_PRODUCTION = EffectType("MetalProduction")
    val CLOTH_PRODUCTION = EffectType("ClothProduction")
    val AMMO_PRODUCTION = EffectType("AmmoProduction")
    val FOOD_PRODUCTION = EffectType("FoodProduction")
    val WATER_PRODUCTION = EffectType("WaterProduction")
}

===== C:\Users\Sulivan\Desktop\Projects\DeadZone-Private-Server\src\main\kotlin\core\model\game\data\enemies\EnemyEliteType.kt =====
package dev.deadzone.core.model.game.data.enemies

import kotlinx.serialization.Serializable

@Serializable
@JvmInline
value class EnemyEliteType(val value: UInt)

object EnemyEliteType_Constants {
    val NONE = EnemyEliteType(0u)
    val RARE = EnemyEliteType(1u)
    val UNIQUE = EnemyEliteType(2u)
}

===== C:\Users\Sulivan\Desktop\Projects\DeadZone-Private-Server\src\main\kotlin\core\model\game\data\quests\DynamicQuest.kt =====
package dev.deadzone.core.model.game.data.quests

import dev.deadzone.core.model.game.data.MoraleConstants_Constants
import kotlinx.serialization.Serializable
import dev.deadzone.core.model.game.data.quests.DynamicQuestGoal
import dev.deadzone.core.model.game.data.quests.DynamicQuestPenalty
import dev.deadzone.core.model.game.data.quests.DynamicQuestReward
import dev.deadzone.core.model.game.data.quests.Quest
import io.ktor.util.date.getTimeMillis
import java.io.ByteArrayOutputStream
import java.io.DataOutputStream
import java.nio.ByteBuffer
import java.nio.ByteOrder

@Serializable
data class DynamicQuest(
    val raw: ByteArray,  // see DynamicQuest.as for detail of structure
    val quest: Quest,  // inherited
    val questType: Int,
    val accepted: Boolean,
    val goals: List<DynamicQuestGoal> = listOf(),
    val rewards: List<DynamicQuestReward> = listOf(),
    val failurePenalties: List<DynamicQuestPenalty> = listOf()
) {
    companion object {
        fun dummy(): ByteArray {
            val buffer = ByteBuffer.allocate(2048).order(ByteOrder.LITTLE_ENDIAN)

            buffer.putShort(2)      // version
            buffer.putShort(1)      // quest type

            val questIdBytes = ByteArrayOutputStream()
            DataOutputStream(questIdBytes).writeUTF("comfortQuest")
            buffer.put(questIdBytes.toByteArray())

            buffer.put(0) // accepted
            buffer.put(0) // complete
            buffer.put(0) // collected
            buffer.put(0) // failed

            buffer.putDouble(getTimeMillis().toDouble())

            buffer.putShort(1) // 1 goal
            val goalData = ByteArrayOutputStream()
            val goalOut = DataOutputStream(goalData)
            goalOut.writeUTF("statInc")
            goalOut.writeUTF("zombieKills")
            goalOut.writeInt(10)
            val goalBytes = goalData.toByteArray()
            buffer.putShort(goalBytes.size.toShort())
            buffer.put(goalBytes)

            buffer.putShort(1) // 1 reward
            val rewardData = ByteArrayOutputStream()
            val rewardOut = DataOutputStream(rewardData)
            rewardOut.writeShort(0)      // type = xp
            rewardOut.writeInt(500)      // xp amount
            val rewardBytes = rewardData.toByteArray()
            buffer.putShort(rewardBytes.size.toShort())
            buffer.put(rewardBytes)

            buffer.putShort(1) // 1 penalty
            val penaltyData = ByteArrayOutputStream()
            val penaltyOut = DataOutputStream(penaltyData)
            penaltyOut.writeShort(2)         // type = morale
            penaltyOut.writeUTF("comfort")      // morale type
            penaltyOut.writeDouble(5.0)      // morale amount
            val penaltyBytes = penaltyData.toByteArray()
            buffer.putShort(penaltyBytes.size.toShort())
            buffer.put(penaltyBytes)

            buffer.putInt(12345678)

            return buffer.array().sliceArray(0 until buffer.position())
        }
    }
}

===== C:\Users\Sulivan\Desktop\Projects\DeadZone-Private-Server\src\main\kotlin\core\model\game\data\quests\DynamicQuestGoal.kt =====
package dev.deadzone.core.model.game.data.quests

import kotlinx.serialization.Serializable
import dev.deadzone.core.model.game.data.quests.DynamicQuestGoalEnum

@Serializable
data class DynamicQuestGoal(
    val type: DynamicQuestGoalEnum,
    val stat: String?,
    val survivor: String?,
    val goal: Int
)

===== C:\Users\Sulivan\Desktop\Projects\DeadZone-Private-Server\src\main\kotlin\core\model\game\data\quests\DynamicQuestGoalEnum.kt =====
package dev.deadzone.core.model.game.data.quests

import kotlinx.serialization.Serializable

@Serializable
@JvmInline
value class DynamicQuestGoalEnum(val value: String)

object DynamicQuestGoalEnum_Constants {
    val statInc = DynamicQuestGoalEnum("statInc")
    val xpInc = DynamicQuestGoalEnum("xpInc")
}

===== C:\Users\Sulivan\Desktop\Projects\DeadZone-Private-Server\src\main\kotlin\core\model\game\data\quests\DynamicQuestPenalty.kt =====
package dev.deadzone.core.model.game.data.quests

import kotlinx.serialization.Serializable
import dev.deadzone.core.model.game.data.quests.DynamicQuestPenaltyEnum
import dev.deadzone.core.model.game.data.MoraleConstants

@Serializable
data class DynamicQuestPenalty(
    val type: DynamicQuestPenaltyEnum,
    val value: String, // actually string and int
    val moraleType: MoraleConstants?,  // Only if type == "morale"
)

===== C:\Users\Sulivan\Desktop\Projects\DeadZone-Private-Server\src\main\kotlin\core\model\game\data\quests\DynamicQuestPenaltyEnum.kt =====
package dev.deadzone.core.model.game.data.quests

import kotlinx.serialization.Serializable

@Serializable
@JvmInline
value class DynamicQuestPenaltyEnum(val value: String)

object DynamicQuestPenaltyEnum_Constants {
    val morale = DynamicQuestPenaltyEnum("morale")
}

===== C:\Users\Sulivan\Desktop\Projects\DeadZone-Private-Server\src\main\kotlin\core\model\game\data\quests\DynamicQuestReward.kt =====
package dev.deadzone.core.model.game.data.quests

import kotlinx.serialization.Serializable
import dev.deadzone.core.model.game.data.quests.DynamicQuestRewardEnum
import dev.deadzone.core.model.game.data.MoraleConstants

@Serializable
data class DynamicQuestReward(
    val type: DynamicQuestRewardEnum,
    val value: String, // actually string and integer
    val moraleType: MoraleConstants?,  // Only if type == "morale"
)

===== C:\Users\Sulivan\Desktop\Projects\DeadZone-Private-Server\src\main\kotlin\core\model\game\data\quests\DynamicQuestRewardEnum.kt =====
package dev.deadzone.core.model.game.data.quests

import kotlinx.serialization.Serializable

@Serializable
@JvmInline
value class DynamicQuestRewardEnum(val value: String)

object DynamicQuestRewardEnum_Constants {
    val xp = DynamicQuestRewardEnum("xp")
    val itm = DynamicQuestRewardEnum("itm")
    val morale = DynamicQuestRewardEnum("morale")
}

===== C:\Users\Sulivan\Desktop\Projects\DeadZone-Private-Server\src\main\kotlin\core\model\game\data\quests\DynamicQuestType.kt =====
package dev.deadzone.core.model.game.data.quests

import kotlinx.serialization.Serializable

@Serializable
@JvmInline
value class DynamicQuestType(val value: Int)

object DynamicQuestType_Constants {
    val SURVIVOR_REQUEST = DynamicQuestType(0)
}

===== C:\Users\Sulivan\Desktop\Projects\DeadZone-Private-Server\src\main\kotlin\core\model\game\data\quests\GlobalQuestData.kt =====
package dev.deadzone.core.model.game.data.quests

import kotlinx.serialization.Serializable
import dev.deadzone.core.model.game.data.quests.GQDataObj

@Serializable
data class GlobalQuestData(
    val raw: ByteArray,
    val map: Map<String, GQDataObj> = mapOf()
)

===== C:\Users\Sulivan\Desktop\Projects\DeadZone-Private-Server\src\main\kotlin\core\model\game\data\quests\GQDataObj.kt =====
package dev.deadzone.core.model.game.data.quests

import kotlinx.serialization.Serializable

@Serializable
data class GQDataObj(
    val id: String,
    val collected: Boolean,
    val contributed: Boolean,
    val contributedLevel: Int,
    val statValues: List<UInt> = listOf()
)

===== C:\Users\Sulivan\Desktop\Projects\DeadZone-Private-Server\src\main\kotlin\core\model\game\data\quests\Quest.kt =====
package dev.deadzone.core.model.game.data.quests

import kotlinx.serialization.Serializable

@Serializable
data class Quest(
    val id: String,
    val started: Boolean,
    val complete: Boolean,
    val conditionProgress: List<Int> = listOf(),
    val collected: Boolean,
    val index: Int,
    val important: Boolean,
    val startImageURI: String?,
    val completeImageURI: String?,
    val isAchievement: Boolean,
    val level: Int,
    val secretLevel: UInt = 0u,
    val type: String,
    val xml: String?,  // uses XML type actually
    val new: Boolean,
    val children: List<Quest> = listOf(),
    val startTime: Long?,
    val endTime: Long?,
    val failed: Boolean,
    val timeBased: Boolean,
    val visible: Boolean = true
)

===== C:\Users\Sulivan\Desktop\Projects\DeadZone-Private-Server\src\main\kotlin\core\model\game\data\quests\QuestConstants.kt =====
import kotlinx.serialization.Serializable

@Serializable
@JvmInline
value class QuestSecret(val value: UInt)

@Serializable
@JvmInline
value class QuestType(val value: String)

@Serializable
@JvmInline
value class QuestTracking(val value: String)

object QuestConstants {
    val SECRET_NONE = QuestSecret(0u)
    val SECRET_TITLE_ONLY = QuestSecret(1u)
    val SECRET_HIDDEN = QuestSecret(2u)

    val TYPE_ACHIEVEMENT = QuestType("achievement")
    val TYPE_GENERAL = QuestType("general")
    val TYPE_COMBAT = QuestType("combat")
    val TYPE_SCAVENGE = QuestType("scavenge")
    val TYPE_CONSTRUCTION = QuestType("construct")
    val TYPE_COMMUNITY = QuestType("community")
    val TYPE_WORLD = QuestType("world")
    val TYPE_DYNAMIC = QuestType("dynamic")

    val TRACKING_TRACKED = QuestTracking("tracked")
    val TRACKING_UNTRACKED = QuestTracking("untracked")
    val TRACKING_MAX_TRACKED = QuestTracking("maxTracked")
}

===== C:\Users\Sulivan\Desktop\Projects\DeadZone-Private-Server\src\main\kotlin\core\model\game\data\raid\RaidData.kt =====
package dev.deadzone.core.model.game.data.raid

import kotlinx.serialization.Serializable
import dev.deadzone.core.model.game.data.assignment.AssignmentData

@Serializable
data class RaidData(
    val assignmentData: AssignmentData,
    val ptsPerSurvivor: Int,
    val maxSurvivorMissionPoints: Int,
    val points: Int
)

===== C:\Users\Sulivan\Desktop\Projects\DeadZone-Private-Server\src\main\kotlin\core\model\game\data\raid\RaidStageData.kt =====
package dev.deadzone.core.model.game.data.raid

import kotlinx.serialization.Serializable
import dev.deadzone.core.model.game.data.assignment.AssignmentStageData

@Serializable
data class RaidStageData(
    val assignmentStageData: AssignmentStageData,
    val objectiveIndex: Int,
    val objectiveState: RaidStageObjectiveState = RaidStageObjectiveState_Constants.INCOMPLETE,
    val objectiveXML: String?,  // actually an XML type
    val imageURI: String
)

===== C:\Users\Sulivan\Desktop\Projects\DeadZone-Private-Server\src\main\kotlin\core\model\game\data\raid\RaidStageObjectiveState.kt =====
package dev.deadzone.core.model.game.data.raid

import kotlinx.serialization.Serializable

@Serializable
@JvmInline
value class RaidStageObjectiveState(val value: UInt)

object RaidStageObjectiveState_Constants {
    val INCOMPLETE = RaidStageObjectiveState(0u)
    val COMPLETE = RaidStageObjectiveState(1u)
    val FAILED = RaidStageObjectiveState(2u)
}

===== C:\Users\Sulivan\Desktop\Projects\DeadZone-Private-Server\src\main\kotlin\core\model\game\data\research\ResearchEffect.kt =====
package dev.deadzone.core.model.game.data.research

import kotlinx.serialization.Serializable

@Serializable
@JvmInline
value class ResearchEffect(val value: String)

object ResearchEffect_Constants {
    val Unknown = ResearchEffect("Unknown")
    val FoodWaterProductionRate = ResearchEffect("FoodWaterProductionRate")
    val FoodWaterProductionCapacity = ResearchEffect("FoodWaterProductionCapacity")
    val BuildingMaterialProductionRate = ResearchEffect("BuildingMaterialProductionRate")
    val BuildingMaterialProductionCapacity = ResearchEffect("BuildingMaterialProductionCapac")
    val AmmoProductionRate = ResearchEffect("AmmoProductionRate")
    val AmmoProductionCapacity = ResearchEffect("AmmoProductionCapacity")
    val FuelProductionRate = ResearchEffect("FuelProductionRate")
    val FuelProductionCapacity = ResearchEffect("FuelProductionCapacity")
    val ExplosiveTrapDamage = ResearchEffect("ExplosiveTrapDamage")
    val ExplosiveTrapDisarmChance = ResearchEffect("ExplosiveTrapDisarmChance")
    val ExplosiveTrapDisarmTime = ResearchEffect("ExplosiveTrapDisarmTime")
    val ExplosiveTrapDetectRange = ResearchEffect("ExplosiveTrapDetectRange")
    val ExplosiveTrapHealth = ResearchEffect("ExplosiveTrapHealth")
    val WireTrapDamage = ResearchEffect("WireTrapDamage")
    val WireTrapDisarmChance = ResearchEffect("WireTrapDisarmChance")
    val WireTrapDisarmTime = ResearchEffect("WireTrapDisarmTime")
    val WireTrapDetectRange = ResearchEffect("WireTrapDetectRange")
    val WireTrapHealth = ResearchEffect("WireTrapHealth")
    val BallisticTrapDamage = ResearchEffect("BallisticTrapDamage")
    val BallisticTrapDisarmChance = ResearchEffect("BallisticTrapDisarmChance")
    val BallisticTrapDisarmTime = ResearchEffect("BallisticTrapDisarmTime")
    val BallisticTrapDetectRange = ResearchEffect("BallisticTrapDetectRange")
    val BallisticTrapHealth = ResearchEffect("BallisticTrapHealth")
    val BarricadeHealth = ResearchEffect("BarricadeHealth")
    val BarricadeCover = ResearchEffect("BarricadeCover")
    val BarricadeSecurity = ResearchEffect("BarricadeSecurity")
    val DoorHealth = ResearchEffect("DoorHealth")
    val DoorCover = ResearchEffect("DoorCover")
    val DoorSecurity = ResearchEffect("DoorSecurity")
    val WatchtowerHealth = ResearchEffect("WatchtowerHealth")
    val WatchtowerCover = ResearchEffect("WatchtowerCover")
    val WatchtowerSecurity = ResearchEffect("WatchtowerSecurity")
    val BarrierHealth = ResearchEffect("BarrierHealth")
    val BarrierCover = ResearchEffect("BarrierCover")
    val BarrierSecurity = ResearchEffect("BarrierSecurity")
    val FoodWaterStorageCapacity = ResearchEffect("FoodWaterStorageCapacity")
    val BuildingMaterialStorageCapacity = ResearchEffect("BuildingMaterialStorageCapacity")
    val AmmoStorageCapacity = ResearchEffect("AmmoStorageCapacity")
    val IndoorComfort = ResearchEffect("IndoorComfort")
    val OutdoorComfort = ResearchEffect("OutdoorComfort")
    val MoralePenalty = ResearchEffect("MoralePenalty")
    val FirearmDamage = ResearchEffect("FirearmDamage")
    val MeleeDamage = ResearchEffect("MeleeDamage")
    val GearHealth = ResearchEffect("GearHealth")
    val BuildingRepairCost = ResearchEffect("BuildingRepairCost")
    val CraftingQuality = ResearchEffect("CraftingQuality")
    val CraftingCost = ResearchEffect("CraftingCost")
    val MissionReturnTime = ResearchEffect("MissionReturnTime")
    val MissionAutoSuccess = ResearchEffect("MissionAutoSuccess")
    val MissionXP = ResearchEffect("MissionXP")
    val LootFindJunk = ResearchEffect("LootFindJunk")
    val LootFindQuality = ResearchEffect("LootFindQuality")
    val InjuryRecoveryTime = ResearchEffect("InjuryRecoveryTime")
}

===== C:\Users\Sulivan\Desktop\Projects\DeadZone-Private-Server\src\main\kotlin\core\model\game\data\research\ResearchState.kt =====
package dev.deadzone.core.model.game.data.research

import kotlinx.serialization.Serializable

@Serializable
data class ResearchState(
    val active: List<ResearchTask>,
    val levels: Map<String, Int>,
)

===== C:\Users\Sulivan\Desktop\Projects\DeadZone-Private-Server\src\main\kotlin\core\model\game\data\research\ResearchTask.kt =====
package dev.deadzone.core.model.game.data.research

import kotlinx.serialization.Serializable

@Serializable
data class ResearchTask(
    val start: Long,
    val id: String,
    val length: Int,
    val category: String,
    val group: String,
    val level: Int,
    val completed: Boolean,
)

===== C:\Users\Sulivan\Desktop\Projects\DeadZone-Private-Server\src\main\kotlin\core\model\game\data\skills\SkillCollection.kt =====
package dev.deadzone.core.model.game.data.skills

import kotlinx.serialization.Serializable
import dev.deadzone.core.model.game.data.skills.SkillState

@Serializable
data class SkillCollection(
    val map: Map<String, SkillState>? = mapOf()
)

===== C:\Users\Sulivan\Desktop\Projects\DeadZone-Private-Server\src\main\kotlin\core\model\game\data\skills\SkillState.kt =====
package dev.deadzone.core.model.game.data.skills

import kotlinx.serialization.Serializable

@Serializable
data class SkillState(
    val xp: Int,
    val level: Int
)

===== C:\Users\Sulivan\Desktop\Projects\DeadZone-Private-Server\src\main\kotlin\core\model\game\data\store\StoreCollection.kt =====
package dev.deadzone.core.model.game.data.store

import kotlinx.serialization.Serializable

@Serializable
data class StoreCollection(
    val key: String,
    val admin: Boolean = false,
    val new: Boolean = false,
    val individualPurchases: Boolean = true,
    val levelMin: Int = 0,
    val levelMax: Int = 2147483647,
    val start: Long?,
    val end: Long?,
    val items: List<String> = listOf(),
    val PriceCoins: Int = 0,
    val PriceUSD: Int = 0,
    val PriceKKR: Int = 0
)

===== C:\Users\Sulivan\Desktop\Projects\DeadZone-Private-Server\src\main\kotlin\core\model\game\data\store\StoreItem.kt =====
package dev.deadzone.core.model.game.data.store

import kotlinx.serialization.Serializable
import dev.deadzone.core.items.model.Item

@Serializable
data class StoreItem(
    val key: String,
    val item: Item,
    val new: Boolean,
    val deal: Boolean,
    val promo: Boolean,
    val collectionOnly: Boolean,
    val admin: Boolean,
    val sale: String?,
    val priority: Int,
    val levelMin: Int = 0,
    val levelMax: Int = 2147483647,
    val start: Long?,
    val end: Long?,
    val PriceCoins: Int?,  // pricecoins else usd or kkr
    val priceUSD: Double?,
    val priceKKR: Int?,
    val orgPriceFUEL: Int?,
    val orgPriceUSD: Int?,
    val orgPriceKKR: Int?,
    val showOrgPrice: Boolean
)

===== C:\Users\Sulivan\Desktop\Projects\DeadZone-Private-Server\src\main\kotlin\core\model\game\data\store\StoreSale.kt =====
package dev.deadzone.core.model.game.data.store

import kotlinx.serialization.Serializable

@Serializable
data class StoreSale(
    val admin: Boolean,
    val savingPerc: Double,
    val levelMin: Int = 0,
    val levelMax: Int = 2147483647,
    val start: Long,
    val end: Long,
    val items: List<String>?,  // assigned to itemKeys, a list of string
)

===== C:\Users\Sulivan\Desktop\Projects\DeadZone-Private-Server\src\main\kotlin\core\model\game\data\task\JunkRemovalTask.kt =====
package dev.deadzone.core.model.game.data.task

import kotlinx.serialization.Serializable
import dev.deadzone.core.model.game.data.JunkBuilding
import dev.deadzone.core.model.game.data.Task

@Serializable
data class JunkRemovalTask(
    val task: Task,
    val target: JunkBuilding,
    val targetId: String,  // obtained from buildingId
    val buildingId: String,
    val xp: Int = 0
)

===== C:\Users\Sulivan\Desktop\Projects\DeadZone-Private-Server\src\main\kotlin\core\model\network\RemotePlayerData.kt =====
package dev.deadzone.core.model.network

import kotlinx.serialization.Serializable

@Serializable
data class RemotePlayerData(
    val name: String?,
    val nickname: String?,
    val level: Int?,
    val serviceUserId: String?,
    val serviceAvatar: String?,
    val serviceAvatarURL: String?,
    val lastLogin: Long?,
    val allianceId: String?,
    val allianceTag: String?,
    val allianceName: String?,
    val bounty: Int?,
    val bountyAllTime: Int?,
    val bountyAllTimeCount: Int?,
    val bountyEarnings: Int?,
    val bountyCollectCount: Int?,
    val bountyDate: Long?,
    val online: Boolean?,
    val onlineTimestamp: Long?,
    val raidLockout: Long?,
    val underAttack: Boolean?,
    val protected: Boolean?,
    val protected_start: Long?,
    val protected_length: Int?,
    val banned: Boolean?
)

===== C:\Users\Sulivan\Desktop\Projects\DeadZone-Private-Server\src\main\kotlin\core\model\network\RemotePlayerDataConstants.kt =====
package dev.deadzone.core.model.network

import kotlinx.serialization.Serializable

@Serializable
@JvmInline
value class RemotePlayerDataConstants(val value: String)

object RemotePlayerDataConstants_Constants {
    val RELATIONSHIP_FRIEND = RemotePlayerDataConstants("friend")
    val RELATIONSHIP_NEUTRAL = RemotePlayerDataConstants("neutral")
    val RELATIONSHIP_ENEMY = RemotePlayerDataConstants("enemy")
}

===== C:\Users\Sulivan\Desktop\Projects\DeadZone-Private-Server\src\main\kotlin\core\survivor\SurvivorRepository.kt =====
package dev.deadzone.core.survivor

import dev.deadzone.core.model.game.data.Survivor

interface SurvivorRepository {
    /**
     * Get survivors of [playerId].
     */
    suspend fun getSurvivors(playerId: String): Result<List<Survivor>>

    /**
     * Update survivor field of [playerId] for the [srvId]
     */
    suspend fun updateSurvivor(
        playerId: String,
        srvId: String,
        updatedSurvivor: Survivor
    ): Result<Unit>
}

===== C:\Users\Sulivan\Desktop\Projects\DeadZone-Private-Server\src\main\kotlin\core\survivor\SurvivorRepositoryMaria.kt =====
package dev.deadzone.core.survivor

import dev.deadzone.core.model.game.data.Survivor
import dev.deadzone.data.collection.PlayerObjects
import dev.deadzone.data.db.PlayerObjectsTable
import kotlinx.serialization.json.Json
import org.jetbrains.exposed.sql.*
import org.jetbrains.exposed.sql.SqlExpressionBuilder.eq
import org.jetbrains.exposed.sql.transactions.transaction

class SurvivorRepositoryMaria(private val database: Database) : SurvivorRepository {
    private val json = Json { ignoreUnknownKeys = true }
    
    override suspend fun getSurvivors(playerId: String): Result<List<Survivor>> {
        return runCatching {
            transaction(database) {
                PlayerObjectsTable.select { PlayerObjectsTable.playerId eq playerId }
                    .singleOrNull()?.let { row ->
                        val playerObjects = json.decodeFromString(PlayerObjects.serializer(), row[PlayerObjectsTable.dataJson])
                        playerObjects.survivors
                    } ?: throw NoSuchElementException("No player found with id=$playerId")
            }
        }
    }
    
    override suspend fun updateSurvivor(playerId: String, srvId: String, updatedSurvivor: Survivor): Result<Unit> {
        return runCatching {
            transaction(database) {
                val currentData = PlayerObjectsTable.select { PlayerObjectsTable.playerId eq playerId }
                    .singleOrNull()?.let { row ->
                        json.decodeFromString(PlayerObjects.serializer(), row[PlayerObjectsTable.dataJson])
                    } ?: throw NoSuchElementException("No player found with id=$playerId")
                
                val updatedSurvivors = currentData.survivors.toMutableList()
                val survivorIndex = updatedSurvivors.indexOfFirst { it.id == srvId }
                if (survivorIndex == -1) {
                    throw NoSuchElementException("Survivor for playerId=$playerId srvId=$srvId not found")
                }
                updatedSurvivors[survivorIndex] = updatedSurvivor
                
                val updatedData = currentData.copy(survivors = updatedSurvivors)
                PlayerObjectsTable.update({ PlayerObjectsTable.playerId eq playerId }) {
                    it[dataJson] = json.encodeToString(PlayerObjects.serializer(), updatedData)
                }
            }
        }
    }
}

===== C:\Users\Sulivan\Desktop\Projects\DeadZone-Private-Server\src\main\kotlin\core\survivor\SurvivorService.kt =====
package core.survivor

import core.PlayerService
import dev.deadzone.core.model.game.data.Survivor
import dev.deadzone.core.survivor.SurvivorRepository
import dev.deadzone.utils.LogConfigSocketToClient
import dev.deadzone.utils.Logger

/**
 * Manages survivors.
 */
class SurvivorService(
    val survivorLeaderId: String,
    private val survivorRepository: SurvivorRepository
) : PlayerService {
    private val survivors = mutableListOf<Survivor>()
    private lateinit var playerId: String // for simple debug

    fun getSurvivorLeader(): Survivor {
        return survivors.find { it.id == survivorLeaderId }
            ?: throw NoSuchElementException("Survivor leader is missing for playerId=$playerId")
    }

    fun getAllSurvivors(): List<Survivor> {
        return survivors
    }

    fun getIndexOfSurvivor(srvId: String?): Int {
        val idx = survivors.indexOfFirst { it.id == srvId }
        if (idx == -1) throw NoSuchElementException("Couldn't find survivor of id=$srvId for player=$playerId")
        return idx
    }

    suspend fun updateSurvivor(
        srvId: String, updateAction: suspend (Survivor) -> Survivor
    ) {
        val idx = getIndexOfSurvivor(srvId)
        val update = updateAction(survivors[idx])
        val result = survivorRepository.updateSurvivor(playerId, srvId, update)
        result.onFailure {
            Logger.error(LogConfigSocketToClient) { "Error on updateSurvivor: ${it.message}" }
        }
        result.onSuccess {
            survivors[idx] = update
        }
    }

    override suspend fun init(playerId: String): Result<Unit> {
        return runCatching {
            this.playerId = playerId
            val _survivors = survivorRepository.getSurvivors(playerId).getOrThrow()

            if (_survivors.isEmpty()) {
                Logger.warn(LogConfigSocketToClient) { "Survivor for playerId=$playerId is empty" }
            }
            survivors.addAll(_survivors)
        }
    }

    override suspend fun close(playerId: String): Result<Unit> {
        return Result.success(Unit)
    }
}

===== C:\Users\Sulivan\Desktop\Projects\DeadZone-Private-Server\src\main\kotlin\core\survivor\model\AttireData.kt =====
package dev.deadzone.core.model.game.data

import kotlinx.serialization.Serializable
import dev.deadzone.core.model.game.data.AttireOverlay

@Serializable
data class AttireData(
    val id: String = "",
    val type: String = "",
    val model: String = "",
    val texture: String = "",
    val tint: Double = 0.0,
    val hue: Double = 0.0,
    val brightness: Double = 0.0,
    val modifiedTextureURI: String = "",
    val modifiedTexture: Boolean = false,
    val uniqueTexture: Boolean = false,
    val overlays: List<AttireOverlay> = listOf(),
    val children: List<AttireData> = listOf(),
    val flags: Int = 0
)

===== C:\Users\Sulivan\Desktop\Projects\DeadZone-Private-Server\src\main\kotlin\core\survivor\model\AttireFlags.kt =====
package dev.deadzone.core.model.game.data

import kotlinx.serialization.Serializable

@Serializable
@JvmInline
value class AttireFlags(val value: UInt)

object AttireFlags_Constants {
    val NONE = AttireFlags(0u)
    val NO_HAIR = AttireFlags(1u)
    val NO_FACIAL_HAIR = AttireFlags(2u)
    val MOUTH = AttireFlags(4u)
    val EYES = AttireFlags(8u)
    val HEAD = AttireFlags(16u)
    val BACK = AttireFlags(32u)
    val CHEST = AttireFlags(64u)
    val NECK = AttireFlags(128u)
    val WAIST_FRONT = AttireFlags(256u)
    val WAIST_BACK = AttireFlags(512u)
    val LEFT_SHOULDER = AttireFlags(1024u)
    val LEFT_UPPER_ARM = AttireFlags(2048u)
    val LEFT_LOWER_ARM = AttireFlags(4096u)
    val LEFT_UPPER_LEG = AttireFlags(8192u)
    val LEFT_LOWER_LEG = AttireFlags(16384u)
    val RIGHT_SHOULDER = AttireFlags(32768u)
    val RIGHT_UPPER_ARM = AttireFlags(65536u)
    val RIGHT_LOWER_ARM = AttireFlags(131072u)
    val RIGHT_UPPER_LEG = AttireFlags(262144u)
    val RIGHT_LOWER_LEG = AttireFlags(524288u)
    val UPPER_BODY = AttireFlags(1048576u)
    val LOWER_BODY = AttireFlags(2097152u)
    val ALL = AttireFlags(16777215u)
    val CLOTHING = AttireFlags(3145728u)
    val ACCESSORIES = AttireFlags(13631487u)
}

===== C:\Users\Sulivan\Desktop\Projects\DeadZone-Private-Server\src\main\kotlin\core\survivor\model\AttireOverlay.kt =====
package dev.deadzone.core.model.game.data

import kotlinx.serialization.Serializable

@Serializable
data class AttireOverlay(
    val type: String,
    val texture: String
)

===== C:\Users\Sulivan\Desktop\Projects\DeadZone-Private-Server\src\main\kotlin\core\survivor\model\AttributeClass.kt =====
package dev.deadzone.core.model.game.data

import kotlinx.serialization.Serializable

@Serializable
@JvmInline
value class AttributeClass(val value: String)

object AttributeClass_Constants {
    val FIGHTING_1 = AttributeClass("combatProjectile")
    val FIGHTING_2 = AttributeClass("combatMelee")
    val SCAVENGING_1 = AttributeClass("scavenge")
    val ENGINEERING_1 = AttributeClass("combatImprovised")
    val ENGINEERING_2 = AttributeClass("trapDisarming")
    val MEDIC_1 = AttributeClass("healing")
    val RECON_1 = AttributeClass("movement")
    val RECON_2 = AttributeClass("trapSpotting")
}

===== C:\Users\Sulivan\Desktop\Projects\DeadZone-Private-Server\src\main\kotlin\core\survivor\model\AttributeOptions.kt =====
package dev.deadzone.core.model.game.data

import kotlinx.serialization.Serializable

@Serializable
data class AttributeOptions(
    val INCLUDE_NONE: Int = 0,
    val INCLUDE_INJURIES: Int = 1,
    val INCLUDE_MORALE: Int = 2,
    val INCLUDE_AI_EFFECTS: Int = 4,
    val INCLUDE_RESEARCH: Int = 8,
    val INCLUDE_EFFECTS: Int = 16,
    val INCLUDE_ALL: Int = 31,
    val NO_MORALE: Int = 29,
    val NO_INJURY: Int = 30
)

===== C:\Users\Sulivan\Desktop\Projects\DeadZone-Private-Server\src\main\kotlin\core\survivor\model\Attributes.kt =====
package dev.deadzone.core.model.game.data

import kotlinx.serialization.Serializable

@Serializable
data class Attributes(
    val health: Double = 0.0,
    val combatProjectile: Double = 0.0,
    val combatMelee: Double = 0.0,
    val combatImprovised: Double = 0.0,
    val movement: Double = 0.0,
    val scavenge: Double = 0.0,
    val healing: Double = 0.0,
    val trapSpotting: Double = 0.0,
    val trapDisarming: Double = 0.0,
    val injuryChance: Double = 0.0
) {
    companion object {
        fun dummy(): Attributes {
            return Attributes(
                health = 100.0,
                combatProjectile = 2.0,
                combatMelee = 2.0,
                combatImprovised = 2.0,
                movement = 2.0,
                scavenge = 2.0,
                healing = 2.0,
                trapSpotting = 2.0,
                trapDisarming = 2.0,
                injuryChance = 2.0,
            )
        }
    }
}

===== C:\Users\Sulivan\Desktop\Projects\DeadZone-Private-Server\src\main\kotlin\core\survivor\model\AttributesConstants.kt =====
package dev.deadzone.core.model.game.data

import kotlinx.serialization.Serializable

@Serializable
@JvmInline
value class AttributesConstants(val value: String)

object AttributesConstants_Constants {
    val COMBAT_IMPROVISED = AttributesConstants("combatImprovised")
    val COMBAT_PROJECTILE = AttributesConstants("combatProjectile")
    val COMBAT_MELEE = AttributesConstants("combatMelee")
    val MOVEMENT_SPEED = AttributesConstants("movement")
    val SCAVENGE_SPEED = AttributesConstants("scavenge")
    val HEALING = AttributesConstants("healing")
    val TRAP_SPOTTING = AttributesConstants("trapSpotting")
    val TRAP_DISARMING = AttributesConstants("trapDisarming")
    val HEALTH = AttributesConstants("health")
    val INJURY_CHANCE = AttributesConstants("injuryChance")
}

===== C:\Users\Sulivan\Desktop\Projects\DeadZone-Private-Server\src\main\kotlin\core\survivor\model\Gender.kt =====
package dev.deadzone.core.model.game.data

import kotlinx.serialization.Serializable

@Serializable
@JvmInline
value class Gender(val value: String)

object Gender_Constants {
    val MALE = Gender("male")
    val FEMALE = Gender("female")
    val UNKNOWN = Gender("unknown")
}

===== C:\Users\Sulivan\Desktop\Projects\DeadZone-Private-Server\src\main\kotlin\core\survivor\model\HumanAppearance.kt =====
package dev.deadzone.core.model.game.data

import kotlinx.serialization.Serializable

@Serializable
data class HumanAppearance(
    val forceHair: Boolean = false,
    val hideGear: Boolean = false,
    val hairColor: String = "black",
    val skinColor: String? = null,
    val hair: String? = null,
    val facialHair: String? = null,
    val clothing_upper: String? = null,
    val clothing_lower: String? = null,
    val accessories: List<String>? = null
) {
    companion object {
        fun parse(app: Map<*, *>): HumanAppearance {
            return HumanAppearance(
                forceHair = app["forceHair"] as? Boolean ?: false,
                hideGear = app["hideGear"] as? Boolean ?: false,
                hairColor = app["hairColor"] as? String ?: "black",
                skinColor = app["skinColor"] as? String,
                hair = app["hair"] as? String,
                facialHair = app["facialHair"] as? String,
                clothing_upper = app["upper"] as? String,
                clothing_lower = app["lower"] as? String,
                accessories = (app["accessories"] as? List<*>)?.mapNotNull { it as? String }
            )
        }
    }
}

===== C:\Users\Sulivan\Desktop\Projects\DeadZone-Private-Server\src\main\kotlin\core\survivor\model\Morale.kt =====
package dev.deadzone.core.model.game.data

import kotlinx.serialization.Serializable

@Serializable
data class Morale(
    val maps: Map<String, Double> = mapOf()
)

===== C:\Users\Sulivan\Desktop\Projects\DeadZone-Private-Server\src\main\kotlin\core\survivor\model\MoraleConstants.kt =====
package dev.deadzone.core.model.game.data

import kotlinx.serialization.Serializable

@Serializable
@JvmInline
value class MoraleConstants(val value: String)

object MoraleConstants_Constants {
    val EFFECT_INJURY = MoraleConstants("injury")
    val EFFECT_MISSION_COMPLETE = MoraleConstants("missionComplete")
    val EFFECT_FOOD = MoraleConstants("food")
    val EFFECT_WATER = MoraleConstants("water")
    val EFFECT_SECURITY = MoraleConstants("security")
    val EFFECT_COMFORT = MoraleConstants("comfort")
    val EFFECT_AVERAGE_SURVIVOR = MoraleConstants("avgSurvivor")
    val EFFECT_DAILY_QUEST_COMPLETED = MoraleConstants("dailyQuestCompleted")
    val EFFECT_DAILY_QUEST_FAILED = MoraleConstants("dailyQuestFailed")
}

===== C:\Users\Sulivan\Desktop\Projects\DeadZone-Private-Server\src\main\kotlin\core\survivor\model\Survivor.kt =====
package dev.deadzone.core.model.game.data

import dev.deadzone.core.data.AdminData
import dev.deadzone.core.model.game.data.SurvivorAppearance.Companion.toHumanAppearance
import dev.deadzone.core.survivor.model.injury.Injury
import dev.deadzone.core.survivor.model.injury.InjuryList
import dev.deadzone.utils.UUID
import kotlinx.serialization.Serializable

@Serializable
data class Survivor(
    val id: String = UUID.new(),
    val title: String,
    val firstName: String = "",
    val lastName: String = "DZ",
    val gender: String,
    val portrait: String? = null,
    val classId: String,
    val morale: Map<String, Double>,
    val injuries: List<Injury>,
    val level: Int,
    val xp: Int,
    val missionId: String?,
    val assignmentId: String?,
    val reassignTimer: TimerData? = null,
    val appearance: HumanAppearance? = null, // HumanAppearance > SurvivorAppearance
    val scale: Double = 1.22,
    val voice: String,
    val accessories: Map<String, String>,  // key is parsed to int, string is accessory id
    val maxClothingAccessories: Int
) {
    companion object {
        fun playerM(): Survivor {
            return Survivor(
                id = AdminData.PLAYER_SRV_ID,
                title = "MercifulLeader",
                firstName = "Merciful",
                lastName = "Leader",
                gender = Gender_Constants.MALE.value,
                portrait = null,
                classId = SurvivorClassConstants_Constants.PLAYER.value,
                morale = Morale().maps,
                injuries = InjuryList().list,
                level = 59,
                xp = 1000,
                missionId = null,
                assignmentId = null,
                reassignTimer = null,
                appearance = SurvivorAppearance.playerM().toHumanAppearance(),
                scale = 1.22,
                voice = "asian-m",
                accessories = mapOf(),
                maxClothingAccessories = 10
            )
        }

        fun reconF(): Survivor {
            return Survivor(
                id = AdminData.RECON_SRV_ID,
                title = "NoisyRecon",
                firstName = "Noisy",
                lastName = "Recon",
                gender = Gender_Constants.FEMALE.value,
                portrait = null,
                classId = SurvivorClassConstants_Constants.RECON.value,
                morale = Morale().maps,
                injuries = InjuryList().list,
                level = 59,
                xp = 1000,
                missionId = null,
                assignmentId = null,
                reassignTimer = null,
                appearance = SurvivorAppearance.reconF().toHumanAppearance(),
                scale = 1.22,
                voice = "white-f",
                accessories = mapOf(),
                maxClothingAccessories = 10
            )
        }

        fun fighterM(): Survivor {
            return Survivor(
                id = AdminData.FIGHTER_SRV_ID,
                title = "AngryFighter",
                firstName = "Angry",
                lastName = "Fighter",
                gender = Gender_Constants.MALE.value,
                portrait = null,
                classId = SurvivorClassConstants_Constants.FIGHTER.value,
                morale = Morale().maps,
                injuries = InjuryList().list,
                level = 59,
                xp = 1000,
                missionId = null,
                assignmentId = null,
                reassignTimer = null,
                appearance = SurvivorAppearance.fighterM().toHumanAppearance(),
                scale = 1.18,
                voice = "asian-m",
                accessories = mapOf(),
                maxClothingAccessories = 10
            )
        }
    }
}

===== C:\Users\Sulivan\Desktop\Projects\DeadZone-Private-Server\src\main\kotlin\core\survivor\model\SurvivorAppearance.kt =====
package dev.deadzone.core.model.game.data

import kotlinx.serialization.Serializable

@Serializable
data class SurvivorAppearance(
    val skinColor: String?,
    val upper: String?,
    val lower: String?,
    val hair: String?,
    val facialHair: String?,
    val hairColor: String?,
    val forceHair: Boolean = false,
    val hideGear: Boolean = false
) {
    companion object {
        fun SurvivorAppearance.toHumanAppearance(): HumanAppearance {
            return HumanAppearance(
                skinColor = this.skinColor,
                hair = this.hair,
                facialHair = this.facialHair,
                clothing_upper = this.upper,
                clothing_lower = this.lower,
                hairColor = this.hairColor ?: "black",
                forceHair = this.forceHair,
                hideGear = this.hideGear,
                accessories = emptyList()
            )
        }

        fun playerM(): SurvivorAppearance {
            return SurvivorAppearance(
                skinColor = "light1",
                upper = "hoodie",
                lower = "pants",
                hair = "hair1",
                facialHair = "facialHair0",
                hairColor = "darkBrown",
                forceHair = false,
                hideGear = false
            )
        }

        fun fighterM(): SurvivorAppearance {
            return SurvivorAppearance(
                skinColor = "light1",
                upper = "class_fighter",
                lower = "class_fighter",
                hair = "hair1",
                facialHair = "facialHair0",
                hairColor = "darkBrown",
                forceHair = false,
                hideGear = false
            )
        }

        fun reconF(): SurvivorAppearance {
            return SurvivorAppearance(
                skinColor = "light1",
                upper = "class_recon",
                lower = "class_recon",
                hair = "hair1",
                facialHair = null,
                hairColor = "darkBrown",
                forceHair = false,
                hideGear = false
            )
        }
    }
}

===== C:\Users\Sulivan\Desktop\Projects\DeadZone-Private-Server\src\main\kotlin\core\survivor\model\SurvivorAppearanceConstants.kt =====
package dev.deadzone.core.model.game.data

import kotlinx.serialization.Serializable

@Serializable
@JvmInline
value class SurvivorAppearanceConstants(val value: String)

object SurvivorAppearanceConstants_Constants {
    val SLOT_UPPER_BODY = SurvivorAppearanceConstants("clothing_upper")
    val SLOT_LOWER_BODY = SurvivorAppearanceConstants("clothing_lower")
}

===== C:\Users\Sulivan\Desktop\Projects\DeadZone-Private-Server\src\main\kotlin\core\survivor\model\SurvivorClass.kt =====
package dev.deadzone.core.model.game.data

import kotlinx.serialization.Serializable
import dev.deadzone.core.model.game.data.Attributes
import dev.deadzone.core.model.game.data.SurvivorClassWeapons

@Serializable
data class SurvivorClass(
    val id: String,
    val maleUpper: String,
    val maleLower: String,
    val maleSkinOverlay: String?,
    val femaleUpper: String,
    val femaleLower: String,
    val femaleSkinOverlay: String?,
    val baseAttributes: Attributes,
    val levelAttributes: Attributes,
    val hideHair: Boolean = false,
    val weapons: List<SurvivorClassWeapons>
)

===== C:\Users\Sulivan\Desktop\Projects\DeadZone-Private-Server\src\main\kotlin\core\survivor\model\SurvivorClassConstants.kt =====
package dev.deadzone.core.model.game.data

import kotlinx.serialization.Serializable

@Serializable
@JvmInline
value class SurvivorClassConstants(val value: String)

object SurvivorClassConstants_Constants {
    val FIGHTER = SurvivorClassConstants("fighter")
    val MEDIC = SurvivorClassConstants("medic")
    val SCAVENGER = SurvivorClassConstants("scavenger")
    val ENGINEER = SurvivorClassConstants("engineer")
    val RECON = SurvivorClassConstants("recon")
    val PLAYER = SurvivorClassConstants("player")
    val UNASSIGNED = SurvivorClassConstants("unassigned")
}

===== C:\Users\Sulivan\Desktop\Projects\DeadZone-Private-Server\src\main\kotlin\core\survivor\model\SurvivorClassWeapons.kt =====
package dev.deadzone.core.model.game.data

import kotlinx.serialization.Serializable
import dev.deadzone.core.model.game.data.WeaponClass
import dev.deadzone.core.model.game.data.WeaponType

@Serializable
data class SurvivorClassWeapons(
    val classes: List<WeaponClass> = listOf(),
    val types: List<WeaponType> = listOf()
)

===== C:\Users\Sulivan\Desktop\Projects\DeadZone-Private-Server\src\main\kotlin\core\survivor\model\SurvivorCollection.kt =====
package dev.deadzone.core.model.game.data

import kotlinx.serialization.Serializable
import dev.deadzone.core.model.game.data.Survivor

@Serializable
data class SurvivorCollection(
    val list: List<Survivor> = listOf()
) {
    companion object {
        fun playerOnly(): List<Survivor> {
            return listOf(
                Survivor.playerM(),
            )
        }

        fun threeSurvivors(): List<Survivor> {
            return listOf(
                Survivor.playerM(),
                Survivor.fighterM(),
                Survivor.reconF(),
            )
        }
    }
}

===== C:\Users\Sulivan\Desktop\Projects\DeadZone-Private-Server\src\main\kotlin\core\survivor\model\SurvivorData.kt =====
package dev.deadzone.core.model.game.data

import kotlinx.serialization.Serializable

@Serializable
data class SurvivorData(
    val id: String,
    val startXP: Int,
    val startLevel: Int,
    val endXP: Int,
    val endLevel: Int
) {
    companion object {
        fun dummy(id: String): SurvivorData {
            return SurvivorData(
                id = id,
                startXP = 0,
                startLevel = 2,
                endXP = 1000,
                endLevel = 4,
            )
        }
    }
}

===== C:\Users\Sulivan\Desktop\Projects\DeadZone-Private-Server\src\main\kotlin\core\survivor\model\SurvivorLoadout.kt =====
package dev.deadzone.core.model.game.data

import kotlinx.serialization.Serializable
import dev.deadzone.core.model.game.data.Survivor
import dev.deadzone.core.model.game.data.SurvivorLoadoutData

@Serializable
data class SurvivorLoadout(
    val type: String,
    val survivor: Survivor,
    val weapon: SurvivorLoadoutData,
    val gearPassive: SurvivorLoadoutData,
    val gearActive: SurvivorLoadoutData,
    val supressChanges: Boolean = false
)

===== C:\Users\Sulivan\Desktop\Projects\DeadZone-Private-Server\src\main\kotlin\core\survivor\model\SurvivorLoadoutConstants.kt =====
package dev.deadzone.core.model.game.data

import kotlinx.serialization.Serializable

@Serializable
@JvmInline
value class SurvivorLoadoutConstants(val value: String)

object SurvivorLoadoutConstants_Constants {
    val SLOT_WEAPON = SurvivorLoadoutConstants("weapon")
    val SLOT_GEAR_PASSIVE = SurvivorLoadoutConstants("gearPassive")
    val SLOT_GEAR_ACTIVE = SurvivorLoadoutConstants("gearActive")
    val TYPE_OFFENCE = SurvivorLoadoutConstants("offence")
    val TYPE_DEFENCE = SurvivorLoadoutConstants("defence")
}

===== C:\Users\Sulivan\Desktop\Projects\DeadZone-Private-Server\src\main\kotlin\core\survivor\model\SurvivorLoadoutData.kt =====
package dev.deadzone.core.model.game.data

import kotlinx.serialization.Serializable
import dev.deadzone.core.items.model.Item

@Serializable
data class SurvivorLoadoutData(
    val type: String,
    val item: Item,
    val quantity: Int,
    val loadout: SurvivorLoadout
)

===== C:\Users\Sulivan\Desktop\Projects\DeadZone-Private-Server\src\main\kotlin\core\survivor\model\SurvivorLoadoutEntry.kt =====
package dev.deadzone.core.model.game.data

import dev.deadzone.core.data.AdminData
import kotlinx.serialization.Serializable

@Serializable
data class SurvivorLoadoutEntry(
    val weapon: String,  // weapon id
    val gear1: String,  // gear id
    val gear2: String,  // gear id
) {
    companion object {
        fun playerLoudout(): SurvivorLoadoutEntry {
            return SurvivorLoadoutEntry(
                weapon = AdminData.PLAYER_WEP_ID,
                gear1 = "",
                gear2 = "",
            )
        }

        fun fighterLoadout(): SurvivorLoadoutEntry {
            return SurvivorLoadoutEntry(
                weapon = AdminData.FIGHTER_WEP_ID,
                gear1 = "",
                gear2 = "",
            )
        }

        fun reconLoadout(): SurvivorLoadoutEntry {
            return SurvivorLoadoutEntry(
                weapon = AdminData.RECON_WEP_ID,
                gear1 = "",
                gear2 = "",
            )
        }
    }
}

===== C:\Users\Sulivan\Desktop\Projects\DeadZone-Private-Server\src\main\kotlin\core\survivor\model\SurvivorState.kt =====
package dev.deadzone.core.model.game.data

import kotlinx.serialization.Serializable

@Serializable
@JvmInline
value class SurvivorState(val value: UInt)

object SurvivorState_Constants {
    val AVAILABLE = SurvivorState(0u)
    val ON_MISSION = SurvivorState(1u)
    val ON_TASK = SurvivorState(2u)
    val REASSIGNING = SurvivorState(4u)
    val ON_ASSIGNMENT = SurvivorState(8u)
}

===== C:\Users\Sulivan\Desktop\Projects\DeadZone-Private-Server\src\main\kotlin\core\survivor\model\injury\Injury.kt =====
package dev.deadzone.core.survivor.model.injury

import kotlinx.serialization.Serializable
import dev.deadzone.core.model.game.data.TimerData

@Serializable
data class Injury(
    val id: String,
    val type: String,
    val location: String,
    val severity: String,
    val damage: Double,
    val morale: Double,
    val timer: TimerData?
)

===== C:\Users\Sulivan\Desktop\Projects\DeadZone-Private-Server\src\main\kotlin\core\survivor\model\injury\InjuryCause.kt =====
package dev.deadzone.core.survivor.model.injury

import kotlinx.serialization.Serializable

@Serializable
@JvmInline
value class InjuryCause(val value: String)

object InjuryCause_Constants {
    val UNKNOWN = InjuryCause("unknown")
    val BLUNT = InjuryCause("blunt")
    val SHARP = InjuryCause("sharp")
    val HEAT = InjuryCause("heat")
    val BULLET = InjuryCause("bullet")
    val ILLNESS = InjuryCause("illness")
}

===== C:\Users\Sulivan\Desktop\Projects\DeadZone-Private-Server\src\main\kotlin\core\survivor\model\injury\InjuryList.kt =====
package dev.deadzone.core.survivor.model.injury

import kotlinx.serialization.Serializable

@Serializable
data class InjuryList(
    val list: List<Injury> = listOf(),  // casted to array in code
)

===== C:\Users\Sulivan\Desktop\Projects\DeadZone-Private-Server\src\main\kotlin\core\survivor\model\injury\InjurySeverity.kt =====
package dev.deadzone.core.survivor.model.injury

import kotlinx.serialization.Serializable

@Serializable
@JvmInline
value class InjurySeverity(val value: String)

object InjurySeverity_Constants {
    val MINOR = InjurySeverity("minor")
    val MODERATE = InjurySeverity("moderate")
    val SERIOUS = InjurySeverity("serious")
    val SEVERE = InjurySeverity("severe")
    val CRITICAL = InjurySeverity("critical")
}

===== C:\Users\Sulivan\Desktop\Projects\DeadZone-Private-Server\src\main\kotlin\data\collection\Inventory.kt =====
package dev.deadzone.data.collection

import dev.deadzone.core.data.AdminData
import dev.deadzone.core.items.ItemFactory
import dev.deadzone.core.items.model.Item
import kotlinx.serialization.Serializable

/**
 * Inventory table
 */
@Serializable
data class Inventory(
    val playerId: String, // reference to UserDocument
    val inventory: List<Item> = emptyList(),
    val schematics: ByteArray = byteArrayOf(),  // see line 643 of Inventory.as
) {
    companion object {
        fun admin(): Inventory {
            val items = listOf(
                ItemFactory.createItemFromId(idInXML = "crate-tutorial"),
                ItemFactory.createItemFromId(idInXML = "crate-tutorial"),
                ItemFactory.createItemFromId(idInXML = "crate-tutorial"),
                ItemFactory.createItemFromId(idInXML = "crate-tutorial"),
                ItemFactory.createItemFromId(idInXML = "crate-tutorial"),
                ItemFactory.createItemFromId(idInXML = "crate-tutorial"),
                ItemFactory.createItemFromId(idInXML = "crate-tutorial"),
                ItemFactory.createItemFromId(idInXML = "crate-tutorial"),
                ItemFactory.createItemFromId(idInXML = "crate-tutorial"),
                ItemFactory.createItemFromId(idInXML = "crate-tutorial"),
                ItemFactory.createItemFromId(idInXML = "key-herc-level-1").copy(new = false, qty = 10u),
                ItemFactory.createItemFromId(idInXML = "grenade-christmas-2"),
                ItemFactory.createItemFromId(idInXML = "p90").copy(level = 37, quality = 3),
                ItemFactory.createItemFromId(idInXML = "sword-unique").copy(level = 49, quality = 51),
                ItemFactory.createItemFromId(itemId = AdminData.FIGHTER_WEP_ID, "bladesaw")
                    .copy(level = 58, quality = 50),
                ItemFactory.createItemFromId(itemId = AdminData.PLAYER_WEP_ID, "freedom-desert-eagle-2-replica")
                    .copy(level = 49, quality = 100),
                ItemFactory.createItemFromId(itemId = AdminData.RECON_WEP_ID, "fal-winter-2017-3")
                    .copy(level = 59, quality = 100),
                ItemFactory.createItemFromId(idInXML = "goldAK47-special").copy(level = 19, quality = 100, bind = 1u),
                ItemFactory.createItemFromId(idInXML = "helmet-wasteland-knight").copy(level = 50, quality = 100),
                ItemFactory.createItemFromId(idInXML = "christmas-canned-meat")
            )

            return Inventory(
                playerId = AdminData.PLAYER_ID,
                inventory = items,
                schematics = byteArrayOf()
            )
        }

        fun newgame(pid: String): Inventory {
            val items = listOf(
                Item(type = "pocketKnife"),
                Item(type = "lawson22")
            )
            return Inventory(
                playerId = pid,
                inventory = items,
                schematics = byteArrayOf()
            )
        }
    }

    override fun equals(other: Any?): Boolean {
        if (this === other) return true
        if (javaClass != other?.javaClass) return false

        other as Inventory

        if (inventory != other.inventory) return false
        if (!schematics.contentEquals(other.schematics)) return false

        return true
    }

    override fun hashCode(): Int {
        var result = inventory.hashCode()
        result = 31 * result + schematics.contentHashCode()
        return result
    }
}

===== C:\Users\Sulivan\Desktop\Projects\DeadZone-Private-Server\src\main\kotlin\data\collection\NeighborHistory.kt =====
package dev.deadzone.data.collection

import dev.deadzone.core.model.network.RemotePlayerData
import kotlinx.serialization.Serializable

/**
 * Neighbor history table
 */
@Serializable
data class NeighborHistory(
    val playerId: String, // reference to UserDocument
    val map: Map<String, @Serializable RemotePlayerData>? = emptyMap()
) {
    companion object {
        fun empty(pid: String): NeighborHistory {
            return NeighborHistory(
                playerId = pid,
                map = emptyMap()
            )
        }
    }
}

===== C:\Users\Sulivan\Desktop\Projects\DeadZone-Private-Server\src\main\kotlin\data\collection\PlayerAccount.kt =====
package dev.deadzone.data.collection

import dev.deadzone.user.model.ServerMetadata
import dev.deadzone.user.model.UserProfile
import dev.deadzone.core.data.AdminData
import kotlinx.serialization.Serializable

/**
 * Database-level representation of a user data
 *
 * @property playerId internal ID, also known as userId in PIO login.
 * This is also used to uniquely identify a user document.
 *
 * @property hashedPassword using particular hash system
 */
@Serializable
data class PlayerAccount(
    val playerId: String, // referenced by other collections
    val hashedPassword: String,
    val profile: UserProfile,
    val serverMetadata: ServerMetadata,
) {
    companion object {
        fun admin(): PlayerAccount {
            return PlayerAccount(
                playerId = AdminData.PLAYER_ID,
                hashedPassword = AdminData.PASSWORD,
                profile = UserProfile.admin(),
                serverMetadata = ServerMetadata()
            )
        }
    }
}

/*
List of common field in PlayerAccount and PlayerObjects
- UserProfile:
    - displayName -> nickname
*/

===== C:\Users\Sulivan\Desktop\Projects\DeadZone-Private-Server\src\main\kotlin\data\collection\PlayerObjects.kt =====
package dev.deadzone.data.collection

import dev.deadzone.core.data.AdminData
import core.metadata.model.ByteArrayAsBase64Serializer
import dev.deadzone.core.model.data.HighActivity
import dev.deadzone.core.model.data.Notification
import core.metadata.model.PlayerFlags
import core.metadata.model.toByteArray
import dev.deadzone.core.model.data.user.AbstractUser
import dev.deadzone.core.model.game.data.Attributes
import dev.deadzone.core.model.game.data.BatchRecycleJob
import dev.deadzone.core.model.game.data.BuildingCollection
import dev.deadzone.core.model.game.data.BuildingLike
import dev.deadzone.core.model.game.data.GameResources
import dev.deadzone.core.model.game.data.Gender_Constants
import dev.deadzone.core.model.game.data.MissionData
import dev.deadzone.core.model.game.data.Survivor
import dev.deadzone.core.model.game.data.SurvivorAppearance
import dev.deadzone.core.model.game.data.SurvivorAppearance.Companion.toHumanAppearance
import dev.deadzone.core.model.game.data.SurvivorClassConstants_Constants
import dev.deadzone.core.model.game.data.SurvivorCollection
import dev.deadzone.core.model.game.data.SurvivorLoadoutEntry
import dev.deadzone.core.model.game.data.Task
import dev.deadzone.core.model.game.data.TaskCollection
import dev.deadzone.core.model.game.data.assignment.AssignmentData
import dev.deadzone.core.model.game.data.bounty.InfectedBounty
import dev.deadzone.core.model.game.data.effects.Effect
import dev.deadzone.core.model.game.data.quests.GQDataObj
import dev.deadzone.core.model.game.data.research.ResearchState
import dev.deadzone.core.model.game.data.skills.SkillState
import dev.deadzone.core.model.network.RemotePlayerData
import io.ktor.util.date.getTimeMillis
import kotlinx.serialization.Serializable

@Serializable
data class PlayerObjects(
    val playerId: String,
    val key: String,
    val user: Map<String, AbstractUser> = emptyMap(),
    val admin: Boolean,
    @Serializable(with = ByteArrayAsBase64Serializer::class)
    val flags: ByteArray = PlayerFlags.newgame(),
    val nickname: String?,
    val playerSurvivor: String?,
    val levelPts: UInt = 0u,
    val restXP: Int = 0,
    val oneTimePurchases: List<String> = emptyList(),
    val neighbors: Map<String, RemotePlayerData>?,
    val friends: Map<String, RemotePlayerData>?,
    val research: ResearchState?,
    val skills: Map<String, SkillState>?,
    val resources: GameResources,
    val survivors: List<Survivor>,
    val playerAttributes: Attributes,
    val buildings: List<BuildingLike>,
    val rally: Map<String, List<String>>?,
    val tasks: List<Task>,
    val missions: List<MissionData>?,
    val assignments: List<AssignmentData>?,
    val effects: List<ByteArray>?,
    val globalEffects: List<ByteArray>?,
    val cooldowns: Map<String, ByteArray>?,
    val batchRecycles: List<BatchRecycleJob>?,
    val offenceLoadout: Map<String, SurvivorLoadoutEntry>?,
    val defenceLoadout: Map<String, SurvivorLoadoutEntry>?,
    val quests: ByteArray?,
    val questsCollected: ByteArray?,
    val achievements: ByteArray?,
    val dailyQuest: ByteArray?,
    val questsTracked: String?,
    val gQuestsV2: Map<String, GQDataObj>?,
    val bountyCap: Int,
    val lastLogout: Long?,
    val dzBounty: InfectedBounty?,
    val nextDZBountyIssue: Long,
    val highActivity: HighActivity?,
    val notifications: List<Notification?>?,
) {
    companion object {
        fun admin(): PlayerObjects {
            val mockFlags = IntRange(0, 8).map { false }.toByteArray()

            return PlayerObjects(
                playerId = AdminData.PLAYER_ID,
                key = AdminData.PLAYER_DATA_KEY,
                admin = true,
                flags = PlayerFlags.skipTutorial(),
                nickname = AdminData.DISPLAY_NAME,
                playerSurvivor = AdminData.PLAYER_SRV_ID,
                neighbors = null,
                friends = null,
                research = ResearchState(active = listOf(), mapOf()),
                skills = null,
                resources = GameResources(
                    cash = 100000,
                    wood = 99999,
                    metal = 99999,
                    cloth = 99999,
                    food = 200,
                    water = 200,
                    ammunition = 99999
                ),
                survivors = SurvivorCollection.threeSurvivors(),
                playerAttributes = Attributes.dummy(),
                buildings = BuildingCollection.starterBase(),
                rally = mapOf(),
                tasks = TaskCollection().list,
                missions = listOf(MissionData.dummy(AdminData.PLAYER_SRV_ID)),
                assignments = null,
                effects = listOf(Effect.halloweenTrickPumpkinZombie(), Effect.halloweenTrickPewPew()),
                globalEffects = listOf(Effect.halloweenTrickPumpkinZombie(), Effect.halloweenTrickPewPew()),
                cooldowns = null,
                batchRecycles = null,
                offenceLoadout = mapOf(
                    AdminData.PLAYER_SRV_ID to SurvivorLoadoutEntry.playerLoudout(),
                    AdminData.FIGHTER_SRV_ID to SurvivorLoadoutEntry.fighterLoadout(),
                    AdminData.RECON_SRV_ID to SurvivorLoadoutEntry.reconLoadout(),
                ),
                defenceLoadout = mapOf(
                    AdminData.PLAYER_SRV_ID to SurvivorLoadoutEntry.playerLoudout(),
                    AdminData.FIGHTER_SRV_ID to SurvivorLoadoutEntry.fighterLoadout(),
                    AdminData.RECON_SRV_ID to SurvivorLoadoutEntry.reconLoadout(),
                ),
                quests = mockFlags,
                questsCollected = mockFlags,
                achievements = mockFlags,
                dailyQuest = null,
                questsTracked = null,
                gQuestsV2 = null,
                bountyCap = 0,
                lastLogout = getTimeMillis() - 100000,
                dzBounty = null,
                nextDZBountyIssue = 1230768000000,
                highActivity = null,
                notifications = null,
            )
        }

        fun newgame(pid: String, nickname: String, playerSrvId: String): PlayerObjects {
            val mockFlags = IntRange(0, 8).map { false }.toByteArray()
            val playerSrv = Survivor(
                id = playerSrvId,
                title = nickname,
                firstName = nickname,
                lastName = "DZ",
                gender = Gender_Constants.MALE.value,
                portrait = null,
                classId = SurvivorClassConstants_Constants.PLAYER.value,
                morale = emptyMap(),
                injuries = emptyList(),
                level = 0,
                xp = 0,
                missionId = null,
                assignmentId = null,
                reassignTimer = null,
                appearance = SurvivorAppearance.playerM().toHumanAppearance(),
                voice = "asian-m",
                accessories = emptyMap(),
                maxClothingAccessories = 4
            )

            return PlayerObjects(
                playerId = pid,
                key = pid,
                admin = false,
                flags = PlayerFlags.create(nicknameVerified = false),
                nickname = null,
                playerSurvivor = playerSrvId,
                neighbors = null,
                friends = null,
                research = ResearchState(active = emptyList(), levels = emptyMap()),
                skills = null,
                resources = GameResources(
                    cash = 100, wood = 300, metal = 300,
                    cloth = 300, food = 25, water = 25, ammunition = 150
                ),
                survivors = listOf(playerSrv),
                playerAttributes = Attributes.dummy(),
                buildings = BuildingCollection.starterBase(),
                rally = emptyMap(),
                tasks = TaskCollection().list,
                missions = listOf(MissionData.dummy(AdminData.PLAYER_SRV_ID)),
                assignments = null,
                effects = listOf(Effect.halloweenTrickPumpkinZombie(), Effect.halloweenTrickPewPew()),
                globalEffects = listOf(Effect.halloweenTrickPumpkinZombie(), Effect.halloweenTrickPewPew()),
                cooldowns = null,
                batchRecycles = null,
                offenceLoadout = emptyMap(),
                defenceLoadout = emptyMap(),
                quests = mockFlags,
                questsCollected = mockFlags,
                achievements = mockFlags,
                dailyQuest = null,
                questsTracked = null,
                gQuestsV2 = null,
                bountyCap = 0,
                lastLogout = null,
                dzBounty = null,
                nextDZBountyIssue = 1765074185294,
                highActivity = null,
                notifications = null,
            )
        }
    }

    override fun equals(other: Any?): Boolean {
        if (this === other) return true
        if (javaClass != other?.javaClass) return false

        other as PlayerObjects

        if (admin != other.admin) return false
        if (restXP != other.restXP) return false
        if (bountyCap != other.bountyCap) return false
        if (lastLogout != other.lastLogout) return false
        if (nextDZBountyIssue != other.nextDZBountyIssue) return false
        if (key != other.key) return false
        if (user != other.user) return false
        if (!flags.contentEquals(other.flags)) return false
        if (nickname != other.nickname) return false
        if (playerSurvivor != other.playerSurvivor) return false
        if (levelPts != other.levelPts) return false
        if (oneTimePurchases != other.oneTimePurchases) return false
        if (neighbors != other.neighbors) return false
        if (friends != other.friends) return false
        if (research != other.research) return false
        if (skills != other.skills) return false
        if (resources != other.resources) return false
        if (survivors != other.survivors) return false
        if (playerAttributes != other.playerAttributes) return false
        if (buildings != other.buildings) return false
        if (rally != other.rally) return false
        if (tasks != other.tasks) return false
        if (missions != other.missions) return false
        if (assignments != other.assignments) return false
        if (effects != other.effects) return false
        if (globalEffects != other.globalEffects) return false
        if (cooldowns != other.cooldowns) return false
        if (batchRecycles != other.batchRecycles) return false
        if (offenceLoadout != other.offenceLoadout) return false
        if (defenceLoadout != other.defenceLoadout) return false
        if (!quests.contentEquals(other.quests)) return false
        if (!questsCollected.contentEquals(other.questsCollected)) return false
        if (!achievements.contentEquals(other.achievements)) return false
        if (!dailyQuest.contentEquals(other.dailyQuest)) return false
        if (questsTracked != other.questsTracked) return false
        if (gQuestsV2 != other.gQuestsV2) return false
        if (dzBounty != other.dzBounty) return false
        if (highActivity != other.highActivity) return false
        if (notifications != other.notifications) return false

        return true
    }

    override fun hashCode(): Int {
        var result = admin.hashCode()
        result = 31 * result + restXP
        result = 31 * result + bountyCap
        result = 31 * result + (lastLogout?.hashCode() ?: 0)
        result = 31 * result + nextDZBountyIssue.hashCode()
        result = 31 * result + key.hashCode()
        result = 31 * result + user.hashCode()
        result = 31 * result + flags.contentHashCode()
        result = 31 * result + nickname.hashCode()
        result = 31 * result + playerSurvivor.hashCode()
        result = 31 * result + levelPts.hashCode()
        result = 31 * result + oneTimePurchases.hashCode()
        result = 31 * result + (neighbors?.hashCode() ?: 0)
        result = 31 * result + (friends?.hashCode() ?: 0)
        result = 31 * result + (research?.hashCode() ?: 0)
        result = 31 * result + (skills?.hashCode() ?: 0)
        result = 31 * result + resources.hashCode()
        result = 31 * result + survivors.hashCode()
        result = 31 * result + playerAttributes.hashCode()
        result = 31 * result + buildings.hashCode()
        result = 31 * result + (rally?.hashCode() ?: 0)
        result = 31 * result + tasks.hashCode()
        result = 31 * result + (missions?.hashCode() ?: 0)
        result = 31 * result + (assignments?.hashCode() ?: 0)
        result = 31 * result + (effects?.hashCode() ?: 0)
        result = 31 * result + (globalEffects?.hashCode() ?: 0)
        result = 31 * result + (cooldowns?.hashCode() ?: 0)
        result = 31 * result + (batchRecycles?.hashCode() ?: 0)
        result = 31 * result + (offenceLoadout?.hashCode() ?: 0)
        result = 31 * result + (defenceLoadout?.hashCode() ?: 0)
        result = 31 * result + (quests?.contentHashCode() ?: 0)
        result = 31 * result + (questsCollected?.contentHashCode() ?: 0)
        result = 31 * result + (achievements?.contentHashCode() ?: 0)
        result = 31 * result + (dailyQuest?.hashCode() ?: 0)
        result = 31 * result + (questsTracked?.hashCode() ?: 0)
        result = 31 * result + (gQuestsV2?.hashCode() ?: 0)
        result = 31 * result + (dzBounty?.hashCode() ?: 0)
        result = 31 * result + (highActivity?.hashCode() ?: 0)
        result = 31 * result + (notifications?.hashCode() ?: 0)
        return result
    }
}

===== C:\Users\Sulivan\Desktop\Projects\DeadZone-Private-Server\src\main\kotlin\data\db\BigDB.kt =====
package dev.deadzone.data.db

import dev.deadzone.data.collection.Inventory
import dev.deadzone.data.collection.NeighborHistory
import dev.deadzone.data.collection.PlayerAccount
import dev.deadzone.data.collection.PlayerObjects

enum class CollectionName {
    PLAYER_ACCOUNT_COLLECTION, PLAYER_OBJECTS_COLLECTION,
    NEIGHBOR_HISTORY_COLLECTION, INVENTORY_COLLECTION,
}

/**
 * Representation of PlayerIO BigDB
 */
interface BigDB {
    suspend fun loadPlayerAccount(playerId: String): PlayerAccount?
    suspend fun loadPlayerObjects(playerId: String): PlayerObjects?
    suspend fun loadNeighborHistory(playerId: String): NeighborHistory?
    suspend fun loadInventory(playerId: String): Inventory?

    /**
     * A flexible method to update particular field of [PlayerObjects]
     */
    suspend fun <T> updatePlayerObjectsField(
        playerId: String,
        path: String,
        value: T
    )

    /**
     * Get a particular collection without type safety.
     *
     * Typically used when repository independent of DB implementation needs
     * to its implementor collection.
     */
    suspend fun <T> getCollection(name: CollectionName): T

    /**
     * Create a user with the provided username and password.
     *
     * This method is defined in BigDB because it require access to all 5 collections,
     * in which a focused repository do not own.
     *
     * @return playerId (UUID) of the newly created user.
     */
    suspend fun createUser(username: String, password: String): String

    suspend fun shutdown()
}

===== C:\Users\Sulivan\Desktop\Projects\DeadZone-Private-Server\src\main\kotlin\data\db\BigDBMariaImpl.kt =====
package dev.deadzone.data.db
import com.toxicbakery.bcrypt.Bcrypt
import dev.deadzone.core.data.AdminData
import core.metadata.model.ByteArrayAsBase64Serializer
import dev.deadzone.data.collection.Inventory
import dev.deadzone.data.collection.NeighborHistory
import dev.deadzone.data.collection.PlayerAccount
import dev.deadzone.data.collection.PlayerObjects
import dev.deadzone.user.model.ServerMetadata
import dev.deadzone.user.model.UserProfile
import dev.deadzone.utils.Logger
import dev.deadzone.utils.UUID
import io.ktor.util.date.*
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.launch
import kotlinx.serialization.json.Json
import kotlinx.serialization.modules.SerializersModule
import org.jetbrains.exposed.sql.*
import org.jetbrains.exposed.sql.transactions.transaction
import kotlin.io.encoding.Base64

object PlayerAccounts : Table("player_accounts") {
    val playerId = varchar("player_id", 36).uniqueIndex()
    val hashedPassword = text("hashed_password")
    val profileJson = text("profile_json")
    val serverMetadataJson = text("server_metadata_json")
    override val primaryKey = PrimaryKey(playerId)
}

object PlayerObjectsTable : Table("player_objects") {
    val playerId = varchar("player_id", 36).uniqueIndex()
    val dataJson = text("data_json")
    override val primaryKey = PrimaryKey(playerId)
}

object NeighborHistoryTable : Table("neighbor_history") {
    val playerId = varchar("player_id", 36).uniqueIndex()
    val dataJson = text("data_json")
    override val primaryKey = PrimaryKey(playerId)
}

object InventoryTable : Table("inventory") {
    val playerId = varchar("player_id", 36).uniqueIndex()
    val dataJson = text("data_json")
    override val primaryKey = PrimaryKey(playerId)
}

class BigDBMariaImpl(val database: Database, private val adminEnabled: Boolean) : BigDB {
    private val json = Json {
        ignoreUnknownKeys = true
        encodeDefaults = true
        serializersModule = SerializersModule {
            contextual(ByteArray::class, ByteArrayAsBase64Serializer)
        }
    }

    init {
        CoroutineScope(Dispatchers.IO).launch {
            setupDatabase()
        }
    }

    private suspend fun setupDatabase() {
        try {
            transaction(database) {
                SchemaUtils.create(PlayerAccounts, PlayerObjectsTable, NeighborHistoryTable, InventoryTable)
            }
            val count = transaction(database) {
                PlayerAccounts.selectAll().count()
            }
            Logger.info { "MariaDB: User table ready, contains $count users." }
            if (adminEnabled) {
                val adminExists = transaction(database) {
                    PlayerAccounts.selectAll().where { PlayerAccounts.playerId eq AdminData.PLAYER_ID }.count() > 0
                }
                if (!adminExists) {
                    val start = getTimeMillis()
                    transaction(database) {
                        val adminAccount = PlayerAccount.admin()
                        val adminObjects = PlayerObjects.admin()
                        val adminNeighbor = NeighborHistory.empty(AdminData.PLAYER_ID)
                        val adminInventory = Inventory.admin()
                        PlayerAccounts.insert {
                            it[playerId] = adminAccount.playerId
                            it[hashedPassword] = adminAccount.hashedPassword
                            it[profileJson] = json.encodeToString(adminAccount.profile)
                            it[serverMetadataJson] = json.encodeToString(adminAccount.serverMetadata)
                        }
                        PlayerObjectsTable.insert {
                            it[playerId] = adminObjects.playerId
                            it[dataJson] = json.encodeToString(adminObjects)
                        }
                        NeighborHistoryTable.insert {
                            it[playerId] = adminNeighbor.playerId
                            it[dataJson] = json.encodeToString(adminNeighbor)
                        }
                        InventoryTable.insert {
                            it[playerId] = adminInventory.playerId
                            it[dataJson] = json.encodeToString(adminInventory)
                        }
                    }
                    Logger.info { "MariaDB: Admin account inserted in ${getTimeMillis() - start}ms" }
                } else {
                    Logger.info { "MariaDB: Admin account already exists." }
                }
            }
        } catch (e: Exception) {
            Logger.error { "MariaDB: Failed during setup: $e" }
            throw e
        }
    }

    override suspend fun loadPlayerAccount(playerId: String): PlayerAccount? {
        return transaction(database) {
            PlayerAccounts.selectAll().where { PlayerAccounts.playerId eq playerId }
                .singleOrNull()?.let { row ->
                    PlayerAccount(
                        playerId = row[PlayerAccounts.playerId],
                        hashedPassword = row[PlayerAccounts.hashedPassword],
                        profile = json.decodeFromString(row[PlayerAccounts.profileJson]),
                        serverMetadata = json.decodeFromString(row[PlayerAccounts.serverMetadataJson])
                    )
                }
        }
    }

    override suspend fun loadPlayerObjects(playerId: String): PlayerObjects? {
        return transaction(database) {
            PlayerObjectsTable.selectAll().where { PlayerObjectsTable.playerId eq playerId }
                .singleOrNull()?.let { row ->
                    json.decodeFromString(row[PlayerObjectsTable.dataJson])
                }
        }
    }

    override suspend fun loadNeighborHistory(playerId: String): NeighborHistory? {
        return transaction(database) {
            NeighborHistoryTable.selectAll().where { NeighborHistoryTable.playerId eq playerId }
                .singleOrNull()?.let { row ->
                    json.decodeFromString(row[NeighborHistoryTable.dataJson])
                }
        }
    }

    override suspend fun loadInventory(playerId: String): Inventory? {
        return transaction(database) {
            InventoryTable.selectAll().where { InventoryTable.playerId eq playerId }
                .singleOrNull()?.let { row ->
                    json.decodeFromString(row[InventoryTable.dataJson])
                }
        }
    }

    override suspend fun <T> updatePlayerObjectsField(playerId: String, path: String, value: T) {
        transaction(database) {
            val currentData = PlayerObjectsTable.selectAll().where { PlayerObjectsTable.playerId eq playerId }
                .singleOrNull()?.let { row ->
                    json.decodeFromString<PlayerObjects>(row[PlayerObjectsTable.dataJson])
                }
            currentData?.let { playerObjects ->
                val updatedJson = json.encodeToString(playerObjects)
                PlayerObjectsTable.update({ PlayerObjectsTable.playerId eq playerId }) {
                    it[dataJson] = updatedJson
                }
            }
        }
    }

    @Suppress("UNCHECKED_CAST")
    override suspend fun <T> getCollection(name: CollectionName): T {
        return when (name) {
            CollectionName.PLAYER_ACCOUNT_COLLECTION -> PlayerAccounts
            CollectionName.PLAYER_OBJECTS_COLLECTION -> PlayerObjectsTable
            CollectionName.NEIGHBOR_HISTORY_COLLECTION -> NeighborHistoryTable
            CollectionName.INVENTORY_COLLECTION -> InventoryTable
        } as T
    }

    override suspend fun createUser(username: String, password: String): String {
        val pid = UUID.new()
        val profile = UserProfile.default(username = username, pid = pid)
        val playerSrvId = UUID.new()
        transaction(database) {
            val account = PlayerAccount(
                playerId = pid,
                hashedPassword = hashPw(password),
                profile = profile,
                serverMetadata = ServerMetadata()
            )
            val objects = PlayerObjects.newgame(pid, username, playerSrvId)
            val neighbor = NeighborHistory.empty(pid)
            val inventory = Inventory.newgame(pid)
            PlayerAccounts.insert {
                it[playerId] = account.playerId
                it[hashedPassword] = account.hashedPassword
                it[profileJson] = json.encodeToString(account.profile)
                it[serverMetadataJson] = json.encodeToString(account.serverMetadata)
            }
            PlayerObjectsTable.insert {
                it[playerId] = objects.playerId
                it[dataJson] = json.encodeToString(objects)
            }
            NeighborHistoryTable.insert {
                it[playerId] = neighbor.playerId
                it[dataJson] = json.encodeToString(neighbor)
            }
            InventoryTable.insert {
                it[playerId] = inventory.playerId
                it[dataJson] = json.encodeToString(inventory)
            }
        }
        return pid
    }

    private fun hashPw(password: String): String {
        return Base64.encode(Bcrypt.hash(password, 10))
    }

    override suspend fun shutdown() {
    }
}

===== C:\Users\Sulivan\Desktop\Projects\DeadZone-Private-Server\src\main\kotlin\socket\core\Connection.kt =====
package dev.deadzone.socket.core

import dev.deadzone.socket.protocol.PIOSerializer
import dev.deadzone.utils.Logger
import dev.deadzone.utils.UUID
import io.ktor.network.sockets.Socket
import io.ktor.utils.io.ByteWriteChannel
import io.ktor.utils.io.writeFully
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.SupervisorJob
import kotlinx.coroutines.cancel

/**
 * Representation of a player connection.
 * @property playerId reference to which player does this socket belongs to. Only known after client send join message.
 */
class Connection(
    var playerId: String = "",
    val connectionId: String = UUID.new(),
    val socket: Socket,
    val scope: CoroutineScope = CoroutineScope(SupervisorJob() + Dispatchers.Default),
    private val output: ByteWriteChannel,
) {
    private var lastActivity = System.currentTimeMillis()

    /**
     * Update the last activity timestamp
     */
    fun updateActivity() {
        lastActivity = System.currentTimeMillis()
    }

    /**
     * Send raw unserialized message (non-PIO) to client
     */
    suspend fun sendRaw(b: ByteArray, logFull: Boolean = false) {
        try {
            Logger.debug(logFull = logFull) { "Sending raw: ${b.decodeToString()}" }
            output.writeFully(b)
            updateActivity()
        } catch (e: Exception) {
            Logger.warn { "Failed to send raw message to ${socket.remoteAddress}: ${e.message}" }
            throw e
        }
    }

    /**
     * Send a serialized PIO message
     */
    suspend fun sendMessage(type: String, vararg args: Any, logFull: Boolean = false) {
        try {
            val msg = buildList {
                add(type)
                addAll(args)
            }
            val bytes = PIOSerializer.serialize(msg)

            Logger.debug(logFull = logFull) { "Sending message of type '$type' | raw message: ${bytes.decodeToString()}" }
            output.writeFully(bytes)
            updateActivity()
        } catch (e: Exception) {
            Logger.warn { "Failed to send message of type '$type' to ${socket.remoteAddress}: ${e.message}" }
            throw e
        }
    }

    fun shutdown() {
        try {
            scope.cancel()
            socket.close()
        } catch (e: Exception) {
            Logger.debug { "Exception during connection shutdown: ${e.message}" }
        }
    }

    override fun toString(): String {
        return "[ADDR]: ${this.socket.remoteAddress} | connectionId=$connectionId"
    }
}

===== C:\Users\Sulivan\Desktop\Projects\DeadZone-Private-Server\src\main\kotlin\socket\core\OnlinePlayerRegistry.kt =====
package dev.deadzone.socket.core

import io.ktor.util.date.*
import java.util.concurrent.ConcurrentHashMap

data class PlayerStatus(
    val playerId: String,
    val onlineSince: Long,
)

/**
 * Keeps track online players
 */
class OnlinePlayerRegistry {
    private val players = ConcurrentHashMap<String, PlayerStatus>()

    /**
     * Mark a player of [playerId] as online. Does nothing if player is already online
     */
    fun markOnline(playerId: String) {
        players[playerId] = PlayerStatus(
            playerId = playerId,
            onlineSince = getTimeMillis(),
        )
    }

    /**
     * Mark a player of [playerId] as offline. Does nothing if player is already offline
     */
    fun markOffline(playerId: String) {
        players.remove(playerId)
    }

    /**
     * Clear all players
     */
    fun shutdown() {
        players.clear()
    }
}

===== C:\Users\Sulivan\Desktop\Projects\DeadZone-Private-Server\src\main\kotlin\socket\core\Server.kt =====
package dev.deadzone.socket.core

import dev.deadzone.SERVER_HOST
import dev.deadzone.SOCKET_SERVER_PORT
import dev.deadzone.context.ServerContext
import dev.deadzone.socket.handler.*
import dev.deadzone.socket.messaging.SocketMessage
import dev.deadzone.socket.messaging.SocketMessageDispatcher
import dev.deadzone.socket.protocol.PIODeserializer
import dev.deadzone.socket.tasks.impl.BuildingTask
import dev.deadzone.socket.tasks.impl.TimeUpdateTask
import dev.deadzone.utils.Logger
import dev.deadzone.utils.UUID
import io.ktor.network.selector.*
import io.ktor.network.sockets.*
import io.ktor.util.date.*
import io.ktor.utils.io.*
import kotlinx.coroutines.*

const val POLICY_FILE_REQUEST = "<policy-file-request/>"
const val POLICY_FILE_RESPONSE =
    "<cross-domain-policy><allow-access-from domain=\"*\" to-ports=\"7777\"/></cross-domain-policy>\u0000"

class Server(
    private val host: String = SERVER_HOST,
    private val port: Int = SOCKET_SERVER_PORT,
    private val context: ServerContext,
    private val coroutineScope: CoroutineScope = CoroutineScope(Dispatchers.IO + SupervisorJob()),
) {
    private val socketDispatcher = SocketMessageDispatcher()

    init {
        with(context) {
            socketDispatcher.register(JoinHandler(this))
            socketDispatcher.register(AuthHandler())
            socketDispatcher.register(QuestProgressHandler())
            socketDispatcher.register(InitCompleteHandler(this))
            socketDispatcher.register(SaveHandler(this))
            socketDispatcher.register(ZombieAttackHandler())
            socketDispatcher.register(RequestSurvivorCheckHandler())
            context.taskDispatcher.register(TimeUpdateTask())
            context.taskDispatcher.register(BuildingTask())
        }
    }

    fun start() {
        coroutineScope.launch {
            try {
                val selectorManager = SelectorManager(Dispatchers.IO)
                val serverSocket = aSocket(selectorManager).tcp().bind(host, port)

                while (true) {
                    val socket = serverSocket.accept()

                    val connection = Connection(
                        connectionId = UUID.new(),
                        socket = socket,
                        output = socket.openWriteChannel(autoFlush = true),
                    )
                    Logger.info { "New client: ${connection.socket.remoteAddress}" }
                    handleClient(connection)
                }
            } catch (e: Exception) {
                Logger.error { "ERROR on server: $e" }
                shutdown()
            }
        }
    }

    private fun handleClient(connection: Connection) {
        coroutineScope.launch {
            val socket = connection.socket
            val input = socket.openReadChannel()

            try {
                val buffer = ByteArray(4096)

                while (true) {
                    val bytesRead = input.readAvailable(buffer, 0, buffer.size)
                    if (bytesRead <= 0) break

                    val data = buffer.copyOfRange(0, bytesRead)
                    Logger.debug { "Received raw: ${data.decodeToString()}" }

                    if (data.startsWithBytes(POLICY_FILE_REQUEST.toByteArray())) {
                        connection.sendRaw(POLICY_FILE_RESPONSE.toByteArray())
                        Logger.info { "Policy file request received and sent" }
                        break
                    }

                    val data2 = if (data.startsWithBytes(byteArrayOf(0x00))) {
                        Logger.info { "Received 0x00 ‚Äî ignoring" }
                        data.drop(1).toByteArray()
                    } else data

                    val deserialized = PIODeserializer.deserialize(data2)
                    val msg = SocketMessage.fromRaw(deserialized)
                    if (msg.isEmpty()) continue

                    socketDispatcher.findHandlerFor(msg).let { handler ->
                        handler.handle(connection, msg) { response ->
                            connection.sendRaw(response)
                        }
                    }

                    Logger.info("<------------ SOCKET MESSAGE END ------------>")
                }
            } catch (_: ClosedByteChannelException) {
                Logger.info { "Client ${connection.socket.remoteAddress} disconnected abruptly (connection reset)" }
            } catch (e: java.net.SocketException) {
                when {
                    e.message?.contains("Connection reset") == true -> {
                        Logger.info { "Client ${connection.socket.remoteAddress} connection was reset by peer" }
                    }
                    e.message?.contains("Broken pipe") == true -> {
                        Logger.info { "Client ${connection.socket.remoteAddress} connection broken (broken pipe)" }
                    }
                    else -> {
                        Logger.warn { "Socket exception for ${connection.socket.remoteAddress}: ${e.message}" }
                    }
                }
            } catch (e: Exception) {
                Logger.error { "Unexpected error in socket for ${connection.socket.remoteAddress}: $e" }
                e.printStackTrace()
            } finally {
                Logger.info { "Cleaning up connection for ${connection.socket.remoteAddress}" }

                if (connection.playerId.isNotEmpty()) {
                    context.onlinePlayerRegistry.markOffline(connection.playerId)
                    context.playerAccountRepository.updateLastLogin(connection.playerId, getTimeMillis())
                    context.playerContextTracker.removePlayer(connection.playerId)
                    context.taskDispatcher.stopAllTasksForPlayer(connection.playerId)
                }

                connection.shutdown()
            }
        }
    }

    fun shutdown() {
        context.playerContextTracker.shutdown()
        context.onlinePlayerRegistry.shutdown()
        context.sessionManager.shutdown()
        context.taskDispatcher.shutdown()
        socketDispatcher.shutdown()
    }
}

fun ByteArray.startsWithBytes(prefix: ByteArray): Boolean {
    if (this.size < prefix.size) return false
    for (i in prefix.indices) {
        if (this[i] != prefix[i]) return false
    }
    return true
}

===== C:\Users\Sulivan\Desktop\Projects\DeadZone-Private-Server\src\main\kotlin\socket\handler\AuthHandler.kt =====
package dev.deadzone.socket.handler

import dev.deadzone.socket.core.Connection
import dev.deadzone.socket.messaging.SocketMessage
import dev.deadzone.socket.messaging.SocketMessageHandler
import dev.deadzone.utils.LogConfigSocketToClient
import dev.deadzone.utils.Logger

/**
 * Auth message is send after game ready message.
 * 'auth' contains MD5 hash produced from hashing all binaries sent in the join message.
 */
class AuthHandler() : SocketMessageHandler {
    override fun match(message: SocketMessage): Boolean {
        return message.type == "auth" || message.contains("auth")
    }

    override suspend fun handle(
        connection: Connection,
        message: SocketMessage,
        send: suspend (ByteArray) -> Unit
    ) {
        Logger.info(LogConfigSocketToClient) { "Received auth message, ignoring." }
    }
}

===== C:\Users\Sulivan\Desktop\Projects\DeadZone-Private-Server\src\main\kotlin\socket\handler\DefaultHandler.kt =====
package dev.deadzone.socket.handler

import dev.deadzone.socket.core.Connection
import dev.deadzone.socket.messaging.SocketMessage
import dev.deadzone.socket.messaging.SocketMessageHandler
import dev.deadzone.socket.protocol.PIOSerializer
import dev.deadzone.utils.LogConfigSocketError
import dev.deadzone.utils.Logger

class DefaultHandler() : SocketMessageHandler {
    override fun match(message: SocketMessage): Boolean {
        return true
    }

    override suspend fun handle(
        connection: Connection,
        message: SocketMessage,
        send: suspend (ByteArray) -> Unit
    ) {
        Logger.warn(LogConfigSocketError) { "Handler not registered or implemented for message: $message" }
        send(PIOSerializer.serialize(listOf("\u0000\u0000\u0000\u0000")))
    }
}

===== C:\Users\Sulivan\Desktop\Projects\DeadZone-Private-Server\src\main\kotlin\socket\handler\InitCompleteHandler.kt =====
package dev.deadzone.socket.handler

import dev.deadzone.context.ServerContext
import dev.deadzone.socket.core.Connection
import dev.deadzone.socket.messaging.NetworkMessage
import dev.deadzone.socket.messaging.SocketMessage
import dev.deadzone.socket.messaging.SocketMessageHandler
import dev.deadzone.socket.tasks.TaskTemplate

/**
 * Handle `ic` message by:
 *
 * 1. Do the necessary setup in server.
 *
 * Very important signal sent by client. It doesn't expects a response, so likely a one-way signal.
 * In here the game is guaranteed to be loaded (in timeline screen). So we could do some setup here.
 */
class InitCompleteHandler(private val serverContext: ServerContext) :
    SocketMessageHandler {
    override fun match(message: SocketMessage): Boolean {
        return message.contains(NetworkMessage.INIT_COMPLETE)
    }

    override suspend fun handle(
        connection: Connection,
        message: SocketMessage,
        send: suspend (ByteArray) -> Unit
    ) {
        serverContext.onlinePlayerRegistry.markOnline(connection.playerId)

        serverContext.taskDispatcher.runTask(
            connection = connection,
            taskTemplateKey = TaskTemplate.TIME_UPDATE,
            cfgBuilder = { null },
            onComplete = {}
        )
    }
}

===== C:\Users\Sulivan\Desktop\Projects\DeadZone-Private-Server\src\main\kotlin\socket\handler\JoinHandler.kt =====
package dev.deadzone.socket.handler

import dev.deadzone.context.ServerContext
import core.LoginStateBuilder
import dev.deadzone.socket.core.Connection
import dev.deadzone.socket.messaging.NetworkMessage
import dev.deadzone.socket.messaging.SocketMessage
import dev.deadzone.socket.messaging.SocketMessageHandler
import dev.deadzone.socket.protocol.PIOSerializer
import dev.deadzone.utils.Logger
import dev.deadzone.utils.Time
import java.io.ByteArrayOutputStream
import java.io.File
import java.nio.ByteBuffer
import java.nio.ByteOrder
import java.util.zip.GZIPOutputStream

/**
 * Handle `join` message by:
 *
 * 1. Sending `playerio.joinresult`
 * 2. Sending `gr` message
 */
class JoinHandler(private val serverContext: ServerContext) : SocketMessageHandler {
    override fun match(message: SocketMessage): Boolean {
        return message.getString(NetworkMessage.JOIN) != null
    }

    override suspend fun handle(connection: Connection, message: SocketMessage, send: suspend (ByteArray) -> Unit) {
        val joinKey = message.getString(NetworkMessage.JOIN)
        Logger.debug { "Handling join with key: $joinKey" }

        val userId = message.getString("serviceUserId")
            ?: throw IllegalArgumentException("No userId for connection: $connection")
        connection.playerId = userId

        val joinResultMsg = listOf(NetworkMessage.JOIN_RESULT, true)
        send(PIOSerializer.serialize(joinResultMsg))

        serverContext.playerContextTracker.createContext(
            playerId = connection.playerId,
            connection = connection,
            db = serverContext.db
        )

        val gameReadyMsg = listOf(
            NetworkMessage.GAME_READY,
            Time.now(),
            produceBinaries(),
            loadRawFile("static/data/cost_table.json"),
            loadRawFile("static/data/srv_table.json"),
            LoginStateBuilder.build(serverContext, connection.playerId)
        )
        send(PIOSerializer.serialize(gameReadyMsg))
    }

    /**
     * Pack all xml.gz resources in data/xml/ and manually added compressed
     * resources_secondary.xml.gz in data/
     *
     * Core.swf doesn't request these, the server has to send it manually.
     */
    fun produceBinaries(): ByteArray {
        val xmlResources = listOf(
            "static/game/data/resources_secondary.xml",
            "static/game/data/resources_mission.xml",
            "static/game/data/xml/alliances.xml.gz",
            "static/game/data/xml/arenas.xml.gz",
            "static/game/data/xml/attire.xml.gz",
            "static/game/data/xml/badwords.xml.gz",
            "static/game/data/xml/buildings.xml.gz",
            "static/game/data/xml/config.xml.gz",
            "static/game/data/xml/crafting.xml.gz",
            "static/game/data/xml/effects.xml.gz",
            "static/game/data/xml/humanenemies.xml.gz",
            "static/game/data/xml/injury.xml.gz",
            "static/game/data/xml/itemmods.xml.gz",
            "static/game/data/xml/items.xml.gz",
            "static/game/data/xml/quests.xml.gz",
            "static/game/data/xml/quests_global.xml.gz",
            "static/game/data/xml/raids.xml.gz",
            "static/game/data/xml/skills.xml.gz",
            "static/game/data/xml/streetstructs.xml.gz",
            "static/game/data/xml/survivor.xml.gz",
            "static/game/data/xml/vehiclenames.xml.gz",
            "static/game/data/xml/zombie.xml.gz",
            "static/game/data/xml/scenes/compound.xml.gz",
            "static/game/data/xml/scenes/interior-gunstore-1.xml.gz",
            "static/game/data/xml/scenes/street-small-1.xml.gz",
            "static/game/data/xml/scenes/street-small-2.xml.gz",
            "static/game/data/xml/scenes/street-small-3.xml.gz",
            "static/game/data/xml/scenes/set-motel.xml.gz",
        )

        val output = ByteArrayOutputStream()

        output.write(xmlResources.size)

        for (path in xmlResources) {
            File(path).inputStream().use {
                val rawBytes = it.readBytes()

                val fileBytes = if (path.endsWith(".gz")) {
                    rawBytes
                } else {
                    val compressed = ByteArrayOutputStream()
                    GZIPOutputStream(compressed).use { gzip ->
                        gzip.write(rawBytes)
                    }
                    compressed.toByteArray()
                }

                val uri = path
                    .removePrefix("static/game/data/")
                    .removeSuffix(".gz")
                val uriBytes = uri.toByteArray(Charsets.UTF_8)

                output.writeShortLE(uriBytes.size)

                output.write(uriBytes)

                output.writeIntLE(fileBytes.size)

                output.write(fileBytes)
            }
        }

        return output.toByteArray()
    }

    fun loadRawFile(path: String): String {
        return File(path).readText()
    }
}

fun ByteArrayOutputStream.writeShortLE(value: Int) {
    val buf = ByteBuffer.allocate(2).order(ByteOrder.LITTLE_ENDIAN).putShort(value.toShort())
    write(buf.array())
}

fun ByteArrayOutputStream.writeIntLE(value: Int) {
    val buf = ByteBuffer.allocate(4).order(ByteOrder.LITTLE_ENDIAN).putInt(value)
    write(buf.array())
}

===== C:\Users\Sulivan\Desktop\Projects\DeadZone-Private-Server\src\main\kotlin\socket\handler\QuestProgressHandler.kt =====
package dev.deadzone.socket.handler

import dev.deadzone.socket.protocol.PIOSerializer
import dev.deadzone.socket.core.Connection
import dev.deadzone.socket.messaging.NetworkMessage
import dev.deadzone.socket.messaging.SocketMessage
import dev.deadzone.socket.messaging.SocketMessageHandler

/**
 * Handle `qp` message by:
 *
 * 1. Sending quest progress JSON
 *
 */
class QuestProgressHandler() : SocketMessageHandler {
    override fun match(message: SocketMessage): Boolean {
        return message.getString(NetworkMessage.QUEST_PROGRESS) != null
    }

    override suspend fun handle(connection: Connection, message: SocketMessage, send: suspend (ByteArray) -> Unit) {
        val message = listOf(NetworkMessage.QUEST_PROGRESS, questProgressJson.trimIndent())
        send(PIOSerializer.serialize(message))
    }
}

const val questProgressJson = """
{
  "complete": null,
  "progress": null
}
"""

===== C:\Users\Sulivan\Desktop\Projects\DeadZone-Private-Server\src\main\kotlin\socket\handler\RequestSurvivorCheckHandler.kt =====
package dev.deadzone.socket.handler

import dev.deadzone.socket.core.Connection
import dev.deadzone.socket.messaging.NetworkMessage
import dev.deadzone.socket.messaging.SocketMessage
import dev.deadzone.socket.messaging.SocketMessageHandler
import dev.deadzone.socket.protocol.PIOSerializer
import dev.deadzone.utils.Logger
import dev.deadzone.utils.Time

/**
 * Handle `rsc` message by:
 *
 * 1. Sending a reponse in JSON with success set to true
 *
 */
class RequestSurvivorCheckHandler() : SocketMessageHandler {
    override fun match(message: SocketMessage): Boolean {
        return message.type == NetworkMessage.REQUEST_SURVIVOR_CHECK || message.contains(NetworkMessage.REQUEST_SURVIVOR_CHECK)
    }

    override suspend fun handle(
        connection: Connection,
        message: SocketMessage,
        send: suspend (ByteArray) -> Unit
    ) {
        val id = message.getMap("rsc")?.get("id") as? String
        Logger.debug { "Received RSC of saveId: $id" }

        val reponseMsg =
            listOf(
                NetworkMessage.SEND_RESPONSE,  // Message Type
                id ?: "m",   // id
                Time.now(),   // server time
                survivorCheckJson.trimIndent() // response
            )
        
        val newSurvivorMsg =
            listOf(
                NetworkMessage.SURVIVOR_NEW,  // Message Type
                survivorNewJson.trimIndent()
            )

        send(PIOSerializer.serialize(reponseMsg))
        send(PIOSerializer.serialize(newSurvivorMsg))
    }
}

const val survivorCheckJson = """{"success": true}"""

const val survivorNewJson = """
{
  "id": "",
  "title": "",
  "firstName": "Jesse",
  "lastName": "Pinkman",
  "gender": "male",
  "classId": "unassigned",
  "voice": "white-m"
}
"""
/*
{
  "id": null,
  "title": null,
  "firstName": null,
  "lastName": null,
  "gender": null,
  "portrait": null,
  "classId": null,
  "morale": null,
  "injuries": null,
  "missionId": null,
  "assignmentId": null,
  "reassignTimer": null,
  "appearance": null,
  "scale": null,
  "voice": null
}
*/

===== C:\Users\Sulivan\Desktop\Projects\DeadZone-Private-Server\src\main\kotlin\socket\handler\SaveHandler.kt =====
package dev.deadzone.socket.handler

import dev.deadzone.context.ServerContext
import dev.deadzone.socket.core.Connection
import dev.deadzone.socket.messaging.NetworkMessage
import dev.deadzone.socket.messaging.SocketMessage
import dev.deadzone.socket.messaging.SocketMessageHandler
import dev.deadzone.utils.LogConfigSocketError
import dev.deadzone.utils.Logger
import dev.deadzone.utils.Time

/**
 * Handle `save` message by:
 *
 * 1. Receive the `data`, `_type`, and `id` (save id) for the said message.
 * 2. Route the save into the corresponding handler based on `_type`.
 * 3. Handlers determine what to do based on the given `data`.
 * 4. Optionally, response back a message of type 'r' with the expected JSON payload and the given save id.
 */
class SaveHandler(private val serverContext: ServerContext) : SocketMessageHandler {
    override fun match(message: SocketMessage): Boolean {
        return message.contains(NetworkMessage.SAVE) or (message.type?.equals(NetworkMessage.SAVE) == true)
    }

    @Suppress("UNCHECKED_CAST")
    override suspend fun handle(
        connection: Connection,
        message: SocketMessage,
        send: suspend (ByteArray) -> Unit
    ) {
        val body = message.getMap(NetworkMessage.SAVE) ?: emptyMap()
        val data = body["data"] as? Map<String, Any?> ?: emptyMap()
        val type = data["_type"] as String? ?: return
        val saveId = body["id"] as String? ?: return
        requireNotNull(connection.playerId) { "Missing playerId on save message for connection=$connection" }


        var match = false
        serverContext.saveHandlers.forEach { saveHandler ->
            if (type in saveHandler.supportedTypes) {
                match = true
                saveHandler.handle(connection, type, saveId, data, send, serverContext)
            }
        }

        if (!match) {
            Logger.warn(LogConfigSocketError) { "Handled 's' network message but unrouted for save type: $type with data=$data" }
        }
    }
}

fun buildMsg(saveId: String?, vararg payloads: Any): List<Any> {
    return buildList {
        add("r")
        add(saveId ?: "m")
        add(Time.now())
        addAll(payloads)
    }
}

===== C:\Users\Sulivan\Desktop\Projects\DeadZone-Private-Server\src\main\kotlin\socket\handler\ZombieAttackHandler.kt =====
package dev.deadzone.socket.handler

import dev.deadzone.socket.protocol.PIOSerializer
import dev.deadzone.socket.core.Connection
import dev.deadzone.socket.messaging.NetworkMessage
import dev.deadzone.socket.messaging.SocketMessage
import dev.deadzone.socket.messaging.SocketMessageHandler

class ZombieAttackHandler(): SocketMessageHandler {
    override fun match(message: SocketMessage): Boolean {
        return message.contains(NetworkMessage.REQUEST_ZOMBIE_ATTACK)
    }

    override suspend fun handle(
        connection: Connection,
        message: SocketMessage,
        send: suspend (ByteArray) -> Unit
    ) {
        val message = listOf(NetworkMessage.ZOMBIE_ATTACK)
        send(PIOSerializer.serialize(message))
    }
}

===== C:\Users\Sulivan\Desktop\Projects\DeadZone-Private-Server\src\main\kotlin\socket\handler\save\BaseResponse.kt =====
package dev.deadzone.socket.handler.save

import dev.deadzone.core.model.game.data.skills.SkillState

/**
 * Most save message expects coins and skills update from server, which can be left null
 *
 * @property coins also known as CASH or FUEL in the game
 * @property skills not sure what is this
 */
open class BaseResponse {
    val coins: Int? = null
    val skills: List<SkillState>? = null
}

===== C:\Users\Sulivan\Desktop\Projects\DeadZone-Private-Server\src\main\kotlin\socket\handler\save\SaveSubHandler.kt =====
package dev.deadzone.socket.handler.save

import dev.deadzone.context.ServerContext
import dev.deadzone.socket.core.Connection

interface SaveSubHandler {
    val supportedTypes: Set<String>

    suspend fun handle(
        connection: Connection,
        type: String,
        saveId: String,
        data: Map<String, Any?>,
        send: suspend (ByteArray) -> Unit,
        serverContext: ServerContext
    )
}

===== C:\Users\Sulivan\Desktop\Projects\DeadZone-Private-Server\src\main\kotlin\socket\handler\save\arena\ArenaSaveHandler.kt =====
package dev.deadzone.socket.handler.save.arena

import dev.deadzone.context.ServerContext
import dev.deadzone.socket.core.Connection
import dev.deadzone.socket.handler.save.SaveSubHandler
import dev.deadzone.socket.messaging.SaveDataMethod
import dev.deadzone.utils.LogConfigSocketToClient
import dev.deadzone.utils.Logger

class ArenaSaveHandler : SaveSubHandler {
    override val supportedTypes: Set<String> = SaveDataMethod.ARENA_SAVES

    override suspend fun handle(
        connection: Connection,
        type: String,
        saveId: String,
        data: Map<String, Any?>,
        send: suspend (ByteArray) -> Unit,
        serverContext: ServerContext
    ) {
        when (type) {
            SaveDataMethod.ARENA_START -> {
                Logger.warn(LogConfigSocketToClient) { "Received 'ARENA_START' message [not implemented]" }
            }

            SaveDataMethod.ARENA_CONTINUE -> {
                Logger.warn(LogConfigSocketToClient) { "Received 'ARENA_CONTINUE' message [not implemented]" }
            }

            SaveDataMethod.ARENA_FINISH -> {
                Logger.warn(LogConfigSocketToClient) { "Received 'ARENA_FINISH' message [not implemented]" }
            }

            SaveDataMethod.ARENA_ABORT -> {
                Logger.warn(LogConfigSocketToClient) { "Received 'ARENA_ABORT' message [not implemented]" }
            }

            SaveDataMethod.ARENA_DEATH -> {
                Logger.warn(LogConfigSocketToClient) { "Received 'ARENA_DEATH' message [not implemented]" }
            }

            SaveDataMethod.ARENA_UPDATE -> {
                Logger.warn(LogConfigSocketToClient) { "Received 'ARENA_UPDATE' message [not implemented]" }
            }

            SaveDataMethod.ARENA_LEADER -> {
                Logger.warn(LogConfigSocketToClient) { "Received 'ARENA_LEADER' message [not implemented]" }
            }

            SaveDataMethod.ARENA_LEADERBOARD -> {
                Logger.warn(LogConfigSocketToClient) { "Received 'ARENA_LEADERBOARD' message [not implemented]" }
            }
        }
    }
}

===== C:\Users\Sulivan\Desktop\Projects\DeadZone-Private-Server\src\main\kotlin\socket\handler\save\bounty\BountySaveHandler.kt =====
package dev.deadzone.socket.handler.save.bounty

import dev.deadzone.context.ServerContext
import dev.deadzone.socket.core.Connection
import dev.deadzone.socket.handler.save.SaveSubHandler
import dev.deadzone.socket.messaging.SaveDataMethod
import dev.deadzone.utils.LogConfigSocketToClient
import dev.deadzone.utils.Logger

class BountySaveHandler : SaveSubHandler {
    override val supportedTypes: Set<String> = SaveDataMethod.BOUNTY_SAVES

    override suspend fun handle(
        connection: Connection,
        type: String,
        saveId: String,
        data: Map<String, Any?>,
        send: suspend (ByteArray) -> Unit,
        serverContext: ServerContext
    ) {
        when (type) {
            SaveDataMethod.BOUNTY_VIEW -> {
                Logger.warn(LogConfigSocketToClient) { "Received 'BOUNTY_VIEW' message [not implemented]" }
            }

            SaveDataMethod.BOUNTY_SPEED_UP -> {
                Logger.warn(LogConfigSocketToClient) { "Received 'BOUNTY_SPEED_UP' message [not implemented]" }
            }

            SaveDataMethod.BOUNTY_NEW -> {
                Logger.warn(LogConfigSocketToClient) { "Received 'BOUNTY_NEW' message [not implemented]" }
            }

            SaveDataMethod.BOUNTY_ABANDON -> {
                Logger.warn(LogConfigSocketToClient) { "Received 'BOUNTY_ABANDON' message [not implemented]" }
            }

            SaveDataMethod.BOUNTY_ADD -> {
                Logger.warn(LogConfigSocketToClient) { "Received 'BOUNTY_ADD' message [not implemented]" }
            }
        }
    }
}

===== C:\Users\Sulivan\Desktop\Projects\DeadZone-Private-Server\src\main\kotlin\socket\handler\save\chat\ChatSaveHandler.kt =====
package dev.deadzone.socket.handler.save.chat

import dev.deadzone.context.ServerContext
import dev.deadzone.socket.core.Connection
import dev.deadzone.socket.handler.save.SaveSubHandler
import dev.deadzone.socket.messaging.SaveDataMethod
import dev.deadzone.utils.LogConfigSocketToClient
import dev.deadzone.utils.Logger

class ChatSaveHandler : SaveSubHandler {
    override val supportedTypes: Set<String> = SaveDataMethod.CHAT_SAVES

    override suspend fun handle(
        connection: Connection,
        type: String,
        saveId: String,
        data: Map<String, Any?>,
        send: suspend (ByteArray) -> Unit,
        serverContext: ServerContext
    ) {
        when (type) {
            SaveDataMethod.CHAT_SILENCED -> {
                Logger.warn(LogConfigSocketToClient) { "Received 'CHAT_SILENCED' message [not implemented]" }
            }

            SaveDataMethod.CHAT_KICKED -> {
                Logger.warn(LogConfigSocketToClient) { "Received 'CHAT_KICKED' message [not implemented]" }
            }

            SaveDataMethod.CHAT_GET_CONTACTS_AND_BLOCKS -> {
                Logger.warn(LogConfigSocketToClient) { "Received 'CHAT_GET_CONTACTS_AND_BLOCKS' message [not implemented]" }
            }

            SaveDataMethod.CHAT_MIGRATE_CONTACTS_AND_BLOCKS -> {
                Logger.warn(LogConfigSocketToClient) { "Received 'CHAT_MIGRATE_CONTACTS_AND_BLOCKS' message [not implemented]" }
            }

            SaveDataMethod.CHAT_ADD_CONTACT -> {
                Logger.warn(LogConfigSocketToClient) { "Received 'CHAT_ADD_CONTACT' message [not implemented]" }
            }

            SaveDataMethod.CHAT_REMOVE_CONTACT -> {
                Logger.warn(LogConfigSocketToClient) { "Received 'CHAT_REMOVE_CONTACT' message [not implemented]" }
            }

            SaveDataMethod.CHAT_REMOVE_ALL_CONTACTS -> {
                Logger.warn(LogConfigSocketToClient) { "Received 'CHAT_REMOVE_ALL_CONTACTS' message [not implemented]" }
            }

            SaveDataMethod.CHAT_ADD_BLOCK -> {
                Logger.warn(LogConfigSocketToClient) { "Received 'CHAT_ADD_BLOCK' message [not implemented]" }
            }

            SaveDataMethod.CHAT_REMOVE_BLOCK -> {
                Logger.warn(LogConfigSocketToClient) { "Received 'CHAT_REMOVE_BLOCK' message [not implemented]" }
            }

            SaveDataMethod.CHAT_REMOVE_ALL_BLOCKS -> {
                Logger.warn(LogConfigSocketToClient) { "Received 'CHAT_REMOVE_ALL_BLOCKS' message [not implemented]" }
            }
        }
    }
}

===== C:\Users\Sulivan\Desktop\Projects\DeadZone-Private-Server\src\main\kotlin\socket\handler\save\command\CommandSaveHandler.kt =====
package dev.deadzone.socket.handler.save.command

import dev.deadzone.context.GlobalContext
import dev.deadzone.context.ServerContext
import dev.deadzone.core.items.model.CrateItem
import dev.deadzone.core.items.model.Item
import dev.deadzone.core.items.model.SchematicItem
import dev.deadzone.socket.core.Connection
import dev.deadzone.socket.handler.buildMsg
import dev.deadzone.socket.handler.save.SaveSubHandler
import dev.deadzone.socket.messaging.CommandMessage
import dev.deadzone.socket.protocol.PIOSerializer
import dev.deadzone.utils.LogConfigSocketToClient
import dev.deadzone.utils.Logger
import dev.deadzone.utils.UUID

class CommandSaveHandler : SaveSubHandler {
    override val supportedTypes: Set<String> = CommandMessage.COMMAND_SAVES

    override suspend fun handle(
        connection: Connection,
        type: String,
        saveId: String,
        data: Map<String, Any?>,
        send: suspend (ByteArray) -> Unit,
        serverContext: ServerContext
    ) {
        when (type) {
            CommandMessage.GIVE -> {
                val type = data["type"] as? String ?: return

                Logger.info(LogConfigSocketToClient) { "Received 'give' command with type=$type | data=$data" }

                when (type) {
                    "schematic" -> {
                        val schem = data["schem"] as? String ?: return
                        val item = SchematicItem(type = type, schem = schem, new = true)
                        val response = GlobalContext.json.encodeToString(item)
                        send(PIOSerializer.serialize(buildMsg(saveId, response)))
                    }

                    "crate" -> {
                        val series = data["series"] as? Int ?: return
                        val repeat = (data["repeat"] as? Int) ?: 1
                        repeat(repeat) {
                            val item = CrateItem(type = type, series = series, new = true)
                            val response = GlobalContext.json.encodeToString(item)
                            send(PIOSerializer.serialize(buildMsg(saveId, response)))
                        }
                    }

                    "effect" -> {
                        Logger.warn(LogConfigSocketToClient) { "Received 'give' command of type effect [not implemented]" }
                    }

                    else -> {
                        val level = data["level"] as? Int ?: return
                        val qty = data["qty"] as? Int ?: 1
                        val mod1 = data["mod1"] as? String?
                        val mod2 = data["mod2"] as? String?
                        val item = Item(
                            id = UUID.new(),
                            type = type,
                            level = level,
                            qty = qty.toUInt(),
                            mod1 = mod1,
                            mod2 = mod2,
                            new = true,
                        )
                        val response = GlobalContext.json.encodeToString(item)
                        send(PIOSerializer.serialize(buildMsg(saveId, response)))
                    }
                }
            }


            CommandMessage.GIVE_RARE -> {
                val type = (data["type"] as String?) ?: return
                val level = (data["level"] as Int?) ?: return

                val item = Item(
                    id = UUID.new(),
                    type = type,
                    level = level,
                    quality = 50,
                    new = true,
                )

                Logger.info(LogConfigSocketToClient) { "Received 'giveRare' command with type=$type | level=$level" }

                val response = GlobalContext.json.encodeToString(item)
                send(PIOSerializer.serialize(buildMsg(saveId, response)))
            }

            CommandMessage.GIVE_UNIQUE -> {
                val type = (data["type"] as String?) ?: return
                val level = (data["level"] as Int?) ?: return

                val item = Item(
                    id = UUID.new(),
                    type = type,
                    level = level,
                    quality = 51,
                    new = true,
                )

                Logger.info(LogConfigSocketToClient) { "Received 'giveUnique' command with type=$type | level=$level" }

                val response = GlobalContext.json.encodeToString(item)
                send(PIOSerializer.serialize(buildMsg(saveId, response)))
            }

            CommandMessage.STORE_CLEAR -> {
                Logger.warn(LogConfigSocketToClient) { "Received 'STORE_CLEAR' message [not implemented]" }
            }

            CommandMessage.STORE_BLOCK -> {
                Logger.warn(LogConfigSocketToClient) { "Received 'STORE_BLOCK' message [not implemented]" }
            }

            CommandMessage.SPAWN_ELITE -> {
                Logger.warn(LogConfigSocketToClient) { "Received 'SPAWN_ELITE' message [not implemented]" }
            }

            CommandMessage.ELITE_CHANCE -> {
                Logger.warn(LogConfigSocketToClient) { "Received 'ELITE_CHANCE' message [not implemented]" }
            }

            CommandMessage.ADD_BOUNTY -> {
                Logger.warn(LogConfigSocketToClient) { "Received 'ADD_BOUNTY' message [not implemented]" }
            }

            CommandMessage.LEVEL -> {
                Logger.warn(LogConfigSocketToClient) { "Received 'LEVEL' message [not implemented]" }
            }

            CommandMessage.SERVER_TIME -> {
                Logger.warn(LogConfigSocketToClient) { "Received 'SERVER_TIME' message [not implemented]" }
            }

            CommandMessage.ZOMBIE -> {
                Logger.warn(LogConfigSocketToClient) { "Received 'ZOMBIE' message [not implemented]" }
            }

            CommandMessage.TIME -> {
                Logger.warn(LogConfigSocketToClient) { "Received 'TIME' message [not implemented]" }
            }

            CommandMessage.STAT -> {
                Logger.warn(LogConfigSocketToClient) { "Received 'STAT' message [not implemented]" }
            }

            CommandMessage.GIVE_AMOUNT -> {
                Logger.warn(LogConfigSocketToClient) { "Received 'GIVE_AMOUNT' message [not implemented]" }
            }

            CommandMessage.COUNTER -> {
                Logger.warn(LogConfigSocketToClient) { "Received 'COUNTER' message [not implemented]" }
            }

            CommandMessage.DAILY_QUEST -> {
                Logger.warn(LogConfigSocketToClient) { "Received 'DAILY_QUEST' message [not implemented]" }
            }

            CommandMessage.CHAT -> {
                Logger.warn(LogConfigSocketToClient) { "Received 'CHAT' message [not implemented]" }
            }

            CommandMessage.LANG -> {
                Logger.warn(LogConfigSocketToClient) { "Received 'LANG' message [not implemented]" }
            }

            CommandMessage.FLAG -> {
                Logger.warn(LogConfigSocketToClient) { "Received 'FLAG' message [not implemented]" }
            }

            CommandMessage.PROMO -> {
                Logger.warn(LogConfigSocketToClient) { "Received 'PROMO' message [not implemented]" }
            }

            CommandMessage.BOUNTY_ADD -> {
                Logger.warn(LogConfigSocketToClient) { "Received 'BOUNTY_ADD' message [not implemented]" }
            }

            CommandMessage.GIVE_INFECTED_BOUNTY -> {
                Logger.warn(LogConfigSocketToClient) { "Received 'GIVE_INFECTED_BOUNTY' message [not implemented]" }
            }

            CommandMessage.BOUNTY_ABANDON -> {
                Logger.warn(LogConfigSocketToClient) { "Received 'BOUNTY_ABANDON' message [not implemented]" }
            }

            CommandMessage.BOUNTY_COMPLETE -> {
                Logger.warn(LogConfigSocketToClient) { "Received 'BOUNTY_COMPLETE' message [not implemented]" }
            }

            CommandMessage.BOUNTY_TASK_COMPLETE -> {
                Logger.warn(LogConfigSocketToClient) { "Received 'BOUNTY_TASK_COMPLETE' message [not implemented]" }
            }

            CommandMessage.BOUNTY_CONDITION_COMPLETE -> {
                Logger.warn(LogConfigSocketToClient) { "Received 'BOUNTY_CONDITION_COMPLETE' message [not implemented]" }
            }

            CommandMessage.BOUNTY_KILL -> {
                Logger.warn(LogConfigSocketToClient) { "Received 'BOUNTY_KILL' message [not implemented]" }
            }

            CommandMessage.SKILL_GIVEXP -> {
                Logger.warn(LogConfigSocketToClient) { "Received 'SKILL_GIVEXP' message [not implemented]" }
            }

            CommandMessage.SKILL_LEVEL -> {
                Logger.warn(LogConfigSocketToClient) { "Received 'SKILL_LEVEL' message [not implemented]" }
            }
        }
    }
}

===== C:\Users\Sulivan\Desktop\Projects\DeadZone-Private-Server\src\main\kotlin\socket\handler\save\compound\building\BuildingSaveHandler.kt =====
package dev.deadzone.socket.handler.save.compound.building

import dev.deadzone.context.GlobalContext
import dev.deadzone.context.ServerContext
import dev.deadzone.context.requirePlayerContext
import dev.deadzone.core.model.game.data.*
import dev.deadzone.socket.core.Connection
import dev.deadzone.socket.handler.buildMsg
import dev.deadzone.socket.handler.save.SaveSubHandler
import dev.deadzone.socket.handler.save.compound.building.response.*
import dev.deadzone.socket.messaging.NetworkMessage
import dev.deadzone.socket.messaging.SaveDataMethod
import dev.deadzone.socket.protocol.PIOSerializer
import dev.deadzone.socket.tasks.TaskTemplate
import dev.deadzone.utils.LogConfigSocketError
import dev.deadzone.utils.LogConfigSocketToClient
import dev.deadzone.utils.Logger
import kotlin.math.max
import kotlin.time.Duration.Companion.minutes
import kotlin.time.Duration.Companion.seconds

class BuildingSaveHandler : SaveSubHandler {
    override val supportedTypes: Set<String> = SaveDataMethod.COMPOUND_BUILDING_SAVES

    override suspend fun handle(
        connection: Connection,
        type: String,
        saveId: String,
        data: Map<String, Any?>,
        send: suspend (ByteArray) -> Unit,
        serverContext: ServerContext
    ) {
        val playerId = connection.playerId
        val svc = serverContext.requirePlayerContext(playerId).services.compound

        when (type) {
            SaveDataMethod.BUILDING_CREATE -> {
                val bldId = data["id"] as? String ?: return
                val bldType = data["type"] as? String ?: return
                val x = data["tx"] as? Int ?: return
                val y = data["ty"] as? Int ?: return
                val r = data["rotation"] as? Int ?: return
                Logger.debug(LogConfigSocketToClient) { "'BUILDING_CREATE' message for $saveId and $bldId,$bldType to tx=$x, ty=$y, rotation=$r" }

                val buildDuration = if (bldType.contains("storage")) 1.minutes else 4.seconds
                val timer = TimerData.runForDuration(
                    duration = buildDuration,
                    data = mapOf("level" to 0, "type" to "upgrade", "xp" to 50)
                )

                val result = runCatching {
                    svc.createBuilding {
                        Building(
                            id = bldId,
                            name = null,
                            type = bldType,
                            level = 0,
                            rotation = r,
                            tx = x,
                            ty = y,
                            destroyed = false,
                            resourceValue = 0.0,
                            upgrade = timer,
                            repair = null
                        )
                    }
                }

                val response = if (result.isSuccess) {
                    BuildingCreateResponse(
                        success = true,
                        items = emptyMap(),
                        timer = timer
                    )
                } else {
                    Logger.error(LogConfigSocketError) { "Failed to create building bldId=$bldId for playerId=$playerId: ${result.exceptionOrNull()?.message}" }
                    BuildingCreateResponse(
                        success = false,
                        items = emptyMap(),
                        timer = null
                    )
                }

                val responseJson = GlobalContext.json.encodeToString(response)
                send(PIOSerializer.serialize(buildMsg(saveId, responseJson)))

                if (result.isSuccess) {
                    serverContext.taskDispatcher.runTask(
                        connection = connection,
                        taskTemplateKey = TaskTemplate.BUILDING,
                        cfgBuilder = {
                            it.copy(
                                targetTask = NetworkMessage.BUILDING_COMPLETE,
                                initialRunDelay = buildDuration,
                                extra = mapOf("msg" to listOf(bldId))
                            )
                        },
                        onComplete = {}
                    )
                }
            }

            SaveDataMethod.BUILDING_MOVE -> {
                val x = (data["tx"] as? Number)?.toInt() ?: return
                val y = (data["ty"] as? Number)?.toInt() ?: return
                val r = (data["rotation"] as? Number)?.toInt() ?: return
                val buildingId = data["id"] as? String ?: return
                Logger.debug(LogConfigSocketToClient) { "'bld_move' message for $saveId and $buildingId to tx=$x, ty=$y, rotation=$r" }

                val result = svc.updateBuilding(buildingId) { it.copy(tx = x, ty = y, rotation = r) }
                val response = if (result.isSuccess) {
                    BuildingMoveResponse(success = true, x = x, y = y, r = r)
                } else {
                    Logger.error(LogConfigSocketError) { "Failed to move building bldId=$buildingId for playerId=$playerId: ${result.exceptionOrNull()?.message}" }
                    BuildingMoveResponse(success = false, x = x, y = y, r = r)
                }

                val responseJson = GlobalContext.json.encodeToString(response)
                send(PIOSerializer.serialize(buildMsg(saveId, responseJson)))
            }

            SaveDataMethod.BUILDING_UPGRADE -> {
                val bldId = data["id"] as? String ?: return
                Logger.debug(LogConfigSocketToClient) { "'BUILDING_UPGRADE' message for $saveId and $bldId" }

                val buildDuration = 10.seconds
                lateinit var timer: TimerData
                val result = svc.updateBuilding(bldId) { bld ->
                    timer = TimerData.runForDuration(
                        duration = buildDuration,
                        data = mapOf("level" to (bld.level + 1), "type" to "upgrade", "xp" to 50)
                    )
                    bld.copy(upgrade = timer)
                }

                val response = if (result.isSuccess) {
                    BuildingUpgradeResponse(success = true, items = emptyMap(), timer = timer)
                } else {
                    Logger.error(LogConfigSocketError) { "Failed to upgrade building bldId=$bldId for playerId=$playerId: ${result.exceptionOrNull()?.message}" }
                    BuildingUpgradeResponse(success = false, items = emptyMap(), timer = null)
                }

                val responseJson = GlobalContext.json.encodeToString(response)
                send(PIOSerializer.serialize(buildMsg(saveId, responseJson)))

                if (result.isSuccess) {
                    serverContext.taskDispatcher.runTask(
                        connection = connection,
                        taskTemplateKey = TaskTemplate.BUILDING,
                        cfgBuilder = {
                            it.copy(
                                targetTask = NetworkMessage.BUILDING_COMPLETE,
                                initialRunDelay = buildDuration,
                                extra = mapOf("msg" to listOf(bldId))
                            )
                        },
                        onComplete = {}
                    )
                }
            }

            SaveDataMethod.BUILDING_RECYCLE -> {
                val bldId = data["id"] as? String ?: return
                Logger.debug(LogConfigSocketToClient) { "'BUILDING_RECYCLE' message for $saveId and $bldId" }

                val result = svc.deleteBuilding(bldId)
                val response = if (result.isSuccess) {
                    BuildingRecycleResponse(success = true, items = emptyMap())
                } else {
                    Logger.error(LogConfigSocketError) { "Failed to recycle building bldId=$bldId for playerId=$playerId: ${result.exceptionOrNull()?.message}" }
                    BuildingRecycleResponse(success = false, items = emptyMap())
                }

                val responseJson = GlobalContext.json.encodeToString(response)
                send(PIOSerializer.serialize(buildMsg(saveId, responseJson)))
            }

            SaveDataMethod.BUILDING_COLLECT -> {
                val bldId = data["id"] as? String ?: return
                Logger.debug(LogConfigSocketToClient) { "'BUILDING_COLLECT' message for $saveId and $bldId" }

                val collectResult = svc.collectBuilding(bldId)
                val response = if (collectResult.isSuccess) {
                    val res = collectResult.getOrThrow()
                    val resType = requireNotNull(res.getNonEmptyResTypeOrNull()) { "Unexpected null on getNonEmptyResTypeOrNull during collect resource" }
                    val resAmount = requireNotNull(res.getNonEmptyResAmountOrNull()?.toDouble()) { "Unexpected null on getNonEmptyResAmountOrNull during collect resource" }
                    val currentResource = svc.getResources()
                    val limit = 100.0 // TODO: Base this on storage capacity from GameDefinitions
                    val expectedResource = currentResource.wood + resAmount
                    val remainder = expectedResource - limit
                    val total = max(limit, expectedResource)
                    BuildingCollectResponse(
                        success = true,
                        locked = false,
                        resource = resType,
                        collected = resAmount,
                        remainder = remainder,
                        total = total,
                        bonus = 0.0,
                        destroyed = false
                    )
                } else {
                    Logger.error(LogConfigSocketError) { "Failed to collect building bldId=$bldId for playerId=$playerId: ${collectResult.exceptionOrNull()?.message}" }
                    BuildingCollectResponse(
                        success = false,
                        locked = false,
                        resource = "",
                        collected = 0.0,
                        remainder = 0.0,
                        total = 0.0,
                        bonus = 0.0,
                        destroyed = false
                    )
                }

                val responseJson = GlobalContext.json.encodeToString(response)
                send(PIOSerializer.serialize(buildMsg(saveId, responseJson)))
            }

            SaveDataMethod.BUILDING_CANCEL -> {
                val bldId = data["id"] as? String ?: return
                Logger.debug(LogConfigSocketToClient) { "'BUILDING_CANCEL' message for $saveId and $bldId" }

                val result = runCatching { svc.cancelBuilding(bldId) }
                val response = if (result.isSuccess) {
                    BuildingCancelResponse(success = true, items = emptyMap())
                } else {
                    Logger.error(LogConfigSocketError) { "Failed to cancel building bldId=$bldId for playerId=$playerId: ${result.exceptionOrNull()?.message}" }
                    BuildingCancelResponse(success = false, items = emptyMap())
                }

                val responseJson = GlobalContext.json.encodeToString(response)
                send(PIOSerializer.serialize(buildMsg(saveId, responseJson)))
            }

            SaveDataMethod.BUILDING_SPEED_UP -> {
                val bldId = data["id"] as? String ?: return
                Logger.debug(LogConfigSocketToClient) { "'BUILDING_SPEED_UP' message for $saveId and $bldId" }

                val result = svc.updateBuilding(bldId) { bld -> bld.copy(upgrade = null) }
                val response = if (result.isSuccess) {
                    BuildingSpeedUpResponse(success = true, error = "", cost = 0)
                } else {
                    Logger.error(LogConfigSocketError) { "Failed to speed up building bldId=$bldId for playerId=$playerId: ${result.exceptionOrNull()?.message}" }
                    BuildingSpeedUpResponse(success = false, error = result.exceptionOrNull()?.message ?: "Unknown error", cost = 0)
                }

                val responseJson = GlobalContext.json.encodeToString(response)
                send(PIOSerializer.serialize(buildMsg(saveId, responseJson)))
            }

            SaveDataMethod.BUILDING_REPAIR -> {
                val bldId = data["id"] as? String ?: return
                Logger.debug(LogConfigSocketToClient) { "'BUILDING_REPAIR' message for $saveId and $bldId" }

                val buildDuration = 10.seconds
                val timer = TimerData.runForDuration(
                    duration = buildDuration,
                    data = mapOf("type" to "repair")
                )

                val result = svc.updateBuilding(bldId) { bld -> bld.copy(repair = timer) }
                val response = if (result.isSuccess) {
                    BuildingRepairResponse(success = true, items = emptyMap(), timer = timer)
                } else {
                    Logger.error(LogConfigSocketError) { "Failed to repair building bldId=$bldId for playerId=$playerId: ${result.exceptionOrNull()?.message}" }
                    BuildingRepairResponse(success = false, items = emptyMap(), timer = null)
                }

                val responseJson = GlobalContext.json.encodeToString(response)
                send(PIOSerializer.serialize(buildMsg(saveId, responseJson)))

                if (result.isSuccess) {
                    serverContext.taskDispatcher.runTask(
                        connection = connection,
                        taskTemplateKey = TaskTemplate.BUILDING,
                        cfgBuilder = {
                            it.copy(
                                targetTask = NetworkMessage.BUILDING_REPAIR_COMPLETE,
                                initialRunDelay = buildDuration,
                                extra = mapOf("msg" to listOf(bldId))
                            )
                        },
                        onComplete = {}
                    )
                }
            }

            SaveDataMethod.BUILDING_REPAIR_SPEED_UP -> {
                val bldId = data["id"] as? String ?: return
                Logger.debug(LogConfigSocketToClient) { "'BUILDING_REPAIR_SPEED_UP' message for $saveId and $bldId" }

                val result = svc.updateBuilding(bldId) { bld -> bld.copy(repair = null) }
                val response = if (result.isSuccess) {
                    BuildingSpeedUpResponse(success = true, error = "", cost = 0)
                } else {
                    Logger.error(LogConfigSocketError) { "Failed to speed up repair for building bldId=$bldId for playerId=$playerId: ${result.exceptionOrNull()?.message}" }
                    BuildingSpeedUpResponse(success = false, error = result.exceptionOrNull()?.message ?: "Unknown error", cost = 0)
                }

                val responseJson = GlobalContext.json.encodeToString(response)
                send(PIOSerializer.serialize(buildMsg(saveId, responseJson)))
            }

            SaveDataMethod.BUILDING_CREATE_BUY -> {
                val bldId = data["id"] as? String ?: return
                val bldType = data["type"] as? String ?: return
                val x = data["tx"] as? Int ?: return
                val y = data["ty"] as? Int ?: return
                val r = data["rotation"] as? Int ?: return
                Logger.debug(LogConfigSocketToClient) { "'BUILDING_CREATE_BUY' message for $saveId and $bldId,$bldType to tx=$x, ty=$y, rotation=$r" }

                val buildDuration = 0.seconds
                val timer = TimerData.runForDuration(
                    duration = buildDuration,
                    data = mapOf("level" to 0, "type" to "upgrade", "xp" to 50)
                )

                val result = runCatching {
                    svc.createBuilding {
                        Building(
                            id = bldId,
                            name = null,
                            type = bldType,
                            level = 0,
                            rotation = r,
                            tx = x,
                            ty = y,
                            destroyed = false,
                            resourceValue = 0.0,
                            upgrade = timer,
                            repair = null
                        )
                    }
                }

                val response = if (result.isSuccess) {
                    BuildingCreateResponse(
                        success = true,
                        items = emptyMap(),
                        timer = timer
                    )
                } else {
                    Logger.error(LogConfigSocketError) { "Failed to create (buy) building bldId=$bldId for playerId=$playerId: ${result.exceptionOrNull()?.message}" }
                    BuildingCreateResponse(
                        success = false,
                        items = emptyMap(),
                        timer = null
                    )
                }

                val responseJson = GlobalContext.json.encodeToString(response)
                send(PIOSerializer.serialize(buildMsg(saveId, responseJson)))

                if (result.isSuccess) {
                    serverContext.taskDispatcher.runTask(
                        connection = connection,
                        taskTemplateKey = TaskTemplate.BUILDING,
                        cfgBuilder = {
                            it.copy(
                                targetTask = NetworkMessage.BUILDING_COMPLETE,
                                initialRunDelay = buildDuration,
                                extra = mapOf("msg" to listOf(bldId))
                            )
                        },
                        onComplete = {}
                    )
                }
            }

            SaveDataMethod.BUILDING_UPGRADE_BUY -> {
                val bldId = data["id"] as? String ?: return
                Logger.debug(LogConfigSocketToClient) { "'BUILDING_UPGRADE_BUY' message for $saveId and $bldId" }

                val buildDuration = 0.seconds
                lateinit var timer: TimerData
                val result = svc.updateBuilding(bldId) { bld ->
                    timer = TimerData.runForDuration(
                        duration = buildDuration,
                        data = mapOf("level" to (bld.level + 1), "type" to "upgrade", "xp" to 50)
                    )
                    bld.copy(upgrade = timer)
                }

                val response = if (result.isSuccess) {
                    BuildingUpgradeResponse(success = true, items = emptyMap(), timer = timer)
                } else {
                    Logger.error(LogConfigSocketError) { "Failed to upgrade (buy) building bldId=$bldId for playerId=$playerId: ${result.exceptionOrNull()?.message}" }
                    BuildingUpgradeResponse(success = false, items = emptyMap(), timer = null)
                }

                val responseJson = GlobalContext.json.encodeToString(response)
                send(PIOSerializer.serialize(buildMsg(saveId, responseJson)))

                if (result.isSuccess) {
                    serverContext.taskDispatcher.runTask(
                        connection = connection,
                        taskTemplateKey = TaskTemplate.BUILDING,
                        cfgBuilder = {
                            it.copy(
                                targetTask = NetworkMessage.BUILDING_COMPLETE,
                                initialRunDelay = buildDuration,
                                extra = mapOf("msg" to listOf(bldId))
                            )
                        },
                        onComplete = {}
                    )
                }
            }

            SaveDataMethod.BUILDING_REPAIR_BUY -> {
                Logger.warn(LogConfigSocketToClient) { "Received 'BUILDING_REPAIR_BUY' message [not implemented]" }
            }

            SaveDataMethod.BUILDING_TRAP_EXPLODE -> {
                Logger.warn(LogConfigSocketToClient) { "Received 'BUILDING_TRAP_EXPLODE' message [not implemented]" }
            }
        }
    }
}

===== C:\Users\Sulivan\Desktop\Projects\DeadZone-Private-Server\src\main\kotlin\socket\handler\save\compound\building\response\BuildingCancelResponse.kt =====
package dev.deadzone.socket.handler.save.compound.building.response

import kotlinx.serialization.Serializable

@Serializable
data class BuildingCancelResponse(
    val success: Boolean,
    val items: Map<String, Int>,
)

===== C:\Users\Sulivan\Desktop\Projects\DeadZone-Private-Server\src\main\kotlin\socket\handler\save\compound\building\response\BuildingCollectResponse.kt =====
package dev.deadzone.socket.handler.save.compound.building.response

import kotlinx.serialization.Serializable

@Serializable
data class BuildingCollectResponse(
    val success: Boolean = true,
    val locked: Boolean,
    val resource: String, // point to GameResources constants
    val collected: Double,
    val remainder: Double,
    val total: Double,
    val bonus: Double, // some special bonus IDK
    val destroyed: Boolean = false
)

===== C:\Users\Sulivan\Desktop\Projects\DeadZone-Private-Server\src\main\kotlin\socket\handler\save\compound\building\response\BuildingCreateBuyResponse.kt =====
package dev.deadzone.socket.handler.save.compound.building.response

import kotlinx.serialization.Serializable

@Serializable
data class BuildingCreateBuyResponse(
    val success: Boolean,
    val levelPts: Int? = null,
)

===== C:\Users\Sulivan\Desktop\Projects\DeadZone-Private-Server\src\main\kotlin\socket\handler\save\compound\building\response\BuildingCreateResponse.kt =====
package dev.deadzone.socket.handler.save.compound.building.response

import dev.deadzone.core.model.game.data.TimerData
import kotlinx.serialization.Serializable

@Serializable
data class BuildingCreateResponse(
    val success: Boolean,
    val items: Map<String, Int>, // item id to quantity
    val timer: TimerData?,        // build timer
)

===== C:\Users\Sulivan\Desktop\Projects\DeadZone-Private-Server\src\main\kotlin\socket\handler\save\compound\building\response\BuildingMoveResponse.kt =====
package dev.deadzone.socket.handler.save.compound.building.response

import dev.deadzone.socket.handler.save.BaseResponse
import kotlinx.serialization.Serializable

@Serializable
data class BuildingMoveResponse(
    val success: Boolean = true,
    val x: Int,
    val y: Int,
    val r: Int,
): BaseResponse()

===== C:\Users\Sulivan\Desktop\Projects\DeadZone-Private-Server\src\main\kotlin\socket\handler\save\compound\building\response\BuildingRecycleResponse.kt =====
package dev.deadzone.socket.handler.save.compound.building.response

import kotlinx.serialization.Serializable

@Serializable
data class BuildingRecycleResponse(
    val success: Boolean,
    val items: Map<String, Int>,
)

===== C:\Users\Sulivan\Desktop\Projects\DeadZone-Private-Server\src\main\kotlin\socket\handler\save\compound\building\response\BuildingRepairResponse.kt =====
package dev.deadzone.socket.handler.save.compound.building.response

import dev.deadzone.core.model.game.data.TimerData
import kotlinx.serialization.Serializable

@Serializable
data class BuildingRepairResponse(
    val success: Boolean = true,
    val items: Map<String, Int>? = emptyMap(),
    val timer: TimerData?
)

===== C:\Users\Sulivan\Desktop\Projects\DeadZone-Private-Server\src\main\kotlin\socket\handler\save\compound\building\response\BuildingRepairSpeedUpResponse.kt =====
package dev.deadzone.socket.handler.save.compound.building.response

import kotlinx.serialization.Serializable

@Serializable
data class BuildingRepairSpeedUpResponse(
    val error: String, // not enough fuel error: PlayerIOError.NotEnoughCoins.errorID
    val success: Boolean = true,
    val cost: Int,
)

===== C:\Users\Sulivan\Desktop\Projects\DeadZone-Private-Server\src\main\kotlin\socket\handler\save\compound\building\response\BuildingSpeedUpResponse.kt =====
package dev.deadzone.socket.handler.save.compound.building.response

import kotlinx.serialization.Serializable

@Serializable
data class BuildingSpeedUpResponse(
    val error: String, // not enough fuel error: PlayerIOError.NotEnoughCoins.errorID
    val success: Boolean = true,
    val cost: Int,
)

===== C:\Users\Sulivan\Desktop\Projects\DeadZone-Private-Server\src\main\kotlin\socket\handler\save\compound\building\response\BuildingUpgradeResponse.kt =====
package dev.deadzone.socket.handler.save.compound.building.response

import dev.deadzone.core.model.game.data.TimerData
import dev.deadzone.socket.handler.save.BaseResponse
import kotlinx.serialization.Serializable

@Serializable
data class BuildingUpgradeResponse(
    val success: Boolean = true,
    val items: Map<String, Int>? = emptyMap(),
    val timer: TimerData?,
    val xp: Int = 0,
): BaseResponse()

===== C:\Users\Sulivan\Desktop\Projects\DeadZone-Private-Server\src\main\kotlin\socket\handler\save\compound\misc\CmpMiscSaveHandler.kt =====
package dev.deadzone.socket.handler.save.compound.misc

import dev.deadzone.context.ServerContext
import dev.deadzone.socket.core.Connection
import dev.deadzone.socket.handler.save.SaveSubHandler
import dev.deadzone.socket.messaging.SaveDataMethod
import dev.deadzone.utils.LogConfigSocketToClient
import dev.deadzone.utils.Logger

class CmpMiscSaveHandler : SaveSubHandler {
    override val supportedTypes: Set<String> = SaveDataMethod.COMPOUND_MISC_SAVES

    override suspend fun handle(
        connection: Connection,
        type: String,
        saveId: String,
        data: Map<String, Any?>,
        send: suspend (ByteArray) -> Unit,
        serverContext: ServerContext
    ) {
        when (type) {
            SaveDataMethod.CRAFT_ITEM -> {
                Logger.warn(LogConfigSocketToClient) { "Received 'CRAFT_ITEM' message [not implemented]" }
            }

            SaveDataMethod.CRAFT_UPGRADE -> {
                Logger.warn(LogConfigSocketToClient) { "Received 'CRAFT_UPGRADE' message [not implemented]" }
            }

            SaveDataMethod.CRAFT_SCHEMATIC -> {
                Logger.warn(LogConfigSocketToClient) { "Received 'CRAFT_SCHEMATIC' message [not implemented]" }
            }

            SaveDataMethod.EFFECT_SET -> {
                Logger.warn(LogConfigSocketToClient) { "Received 'EFFECT_SET' message [not implemented]" }
            }

            SaveDataMethod.RESEARCH_START -> {
                Logger.warn(LogConfigSocketToClient) { "Received 'RESEARCH_START' message [not implemented]" }
            }

            SaveDataMethod.AH_EVENT -> {
                Logger.warn(LogConfigSocketToClient) { "Received 'AH_EVENT' message [not implemented]" }
            }

            SaveDataMethod.CULL_NEIGHBORS -> {
                Logger.warn(LogConfigSocketToClient) { "Received 'CULL_NEIGHBORS' message [not implemented]" }
            }

            SaveDataMethod.RALLY_ASSIGNMENT -> {
                Logger.warn(LogConfigSocketToClient) { "Received 'RALLY_ASSIGNMENT' message [not implemented]" }
            }
        }
    }
}

===== C:\Users\Sulivan\Desktop\Projects\DeadZone-Private-Server\src\main\kotlin\socket\handler\save\compound\task\TaskSaveHandler.kt =====
package socket.handler.save.compound.task

import dev.deadzone.utils.LogConfigSocketToClient
import dev.deadzone.utils.Logger
import dev.deadzone.socket.core.Connection
import dev.deadzone.context.ServerContext
import dev.deadzone.socket.messaging.SaveDataMethod
import dev.deadzone.socket.handler.buildMsg
import dev.deadzone.socket.protocol.PIOSerializer
import dev.deadzone.context.GlobalContext
import dev.deadzone.socket.handler.save.SaveSubHandler
import kotlinx.serialization.Serializable

@Serializable
data class TaskStartedResponse(
    val items: List<TaskItem>
)

@Serializable
data class TaskItem(
    val id: String,
    val quantity: Int,
    val quality: String? = null
)

class TaskSaveHandler : SaveSubHandler {
    override val supportedTypes: Set<String> = setOf(
        SaveDataMethod.TASK_STARTED,
        SaveDataMethod.TASK_CANCELLED,
        SaveDataMethod.TASK_SURVIVOR_ASSIGNED,
        SaveDataMethod.TASK_SURVIVOR_REMOVED,
        SaveDataMethod.TASK_SPEED_UP
    )

    override suspend fun handle(
        connection: Connection,
        type: String,
        saveId: String,
        data: Map<String, Any?>,
        send: suspend (ByteArray) -> Unit,
        serverContext: ServerContext
    ) {
        when (type) {
            SaveDataMethod.TASK_STARTED -> {
                val taskType = data["type"] as? String
                val targetId = data["targetId"] as? String
                val survivors = data["survivors"] as? List<*>

                Logger.info(LogConfigSocketToClient) { "Task started: type=$taskType, targetId=$targetId, survivors=${survivors?.size}" }

                val items = when (taskType) {
                    "junk_removal" -> generateJunkRemovalItems()
                    "scavenging" -> generateScavengingItems()
                    "construction" -> generateConstructionItems()
                    else -> emptyList()
                }

                val responseJson = GlobalContext.json.encodeToString(
                    TaskStartedResponse(items = items)
                )

                send(PIOSerializer.serialize(buildMsg(saveId, responseJson)))
            }

            SaveDataMethod.TASK_CANCELLED -> {
                val taskId = data["taskId"] as? String
                Logger.info(LogConfigSocketToClient) { "Task cancelled: taskId=$taskId" }

                send(PIOSerializer.serialize(buildMsg(saveId, "{}")))
            }

            SaveDataMethod.TASK_SURVIVOR_ASSIGNED -> {
                val taskId = data["taskId"] as? String
                val survivors = data["survivors"] as? List<*>
                Logger.info(LogConfigSocketToClient) { "Survivors assigned to task: taskId=$taskId, survivors=${survivors?.size}" }

                send(PIOSerializer.serialize(buildMsg(saveId, "{}")))
            }

            SaveDataMethod.TASK_SURVIVOR_REMOVED -> {
                val taskId = data["taskId"] as? String
                val survivors = data["survivors"] as? List<*>
                Logger.info(LogConfigSocketToClient) { "Survivors removed from task: taskId=$taskId, survivors=${survivors?.size}" }

                send(PIOSerializer.serialize(buildMsg(saveId, "{}")))
            }

            SaveDataMethod.TASK_SPEED_UP -> {
                val taskId = data["taskId"] as? String
                Logger.info(LogConfigSocketToClient) { "Task speed up: taskId=$taskId" }

                send(PIOSerializer.serialize(buildMsg(saveId, "{}")))
            }
        }
    }

    private fun generateJunkRemovalItems(): List<TaskItem> {
        return listOf(
            TaskItem("scrap_metal", kotlin.random.Random.nextInt(5, 15)),
            TaskItem("wood", kotlin.random.Random.nextInt(3, 10)),
            TaskItem("cloth", kotlin.random.Random.nextInt(2, 8))
        )
    }

    private fun generateScavengingItems(): List<TaskItem> {
        return listOf(
            TaskItem("food", kotlin.random.Random.nextInt(2, 6)),
            TaskItem("water", kotlin.random.Random.nextInt(1, 4)),
            TaskItem("medicine", kotlin.random.Random.nextInt(1, 3))
        )
    }

    private fun generateConstructionItems(): List<TaskItem> {
        return listOf(
            TaskItem("building_materials", kotlin.random.Random.nextInt(10, 25)),
            TaskItem("tools", kotlin.random.Random.nextInt(1, 5))
        )
    }
}

===== C:\Users\Sulivan\Desktop\Projects\DeadZone-Private-Server\src\main\kotlin\socket\handler\save\crate\CrateSaveHandler.kt =====
package dev.deadzone.socket.handler.save.crate

import dev.deadzone.context.GlobalContext
import dev.deadzone.context.ServerContext
import dev.deadzone.core.items.ItemFactory
import dev.deadzone.socket.core.Connection
import dev.deadzone.socket.handler.buildMsg
import dev.deadzone.socket.handler.save.SaveSubHandler
import dev.deadzone.socket.handler.save.crate.response.CrateUnlockResponse
import dev.deadzone.socket.messaging.SaveDataMethod
import dev.deadzone.socket.protocol.PIOSerializer
import dev.deadzone.utils.LogConfigSocketToClient
import dev.deadzone.utils.Logger

class CrateSaveHandler : SaveSubHandler {
    override val supportedTypes: Set<String> = SaveDataMethod.CRATE_SAVES

    override suspend fun handle(
        connection: Connection,
        type: String,
        saveId: String,
        data: Map<String, Any?>,
        send: suspend (ByteArray) -> Unit,
        serverContext: ServerContext
    ) {
        when (type) {
            SaveDataMethod.CRATE_UNLOCK -> {
                val keyId = data["keyId"] as String?
                val crateId = (data["crateId"] ?: "") as String?

                val responseJson = GlobalContext.json.encodeToString(
                    CrateUnlockResponse(
                        success = true,
                        item = ItemFactory.getRandomItem(),
                        keyId = keyId,
                        crateId = crateId,
                    )
                )

                Logger.info(LogConfigSocketToClient) { "Opening crateId=$crateId with keyId=$keyId" }

                send(PIOSerializer.serialize(buildMsg(saveId, responseJson)))
            }

            SaveDataMethod.CRATE_MYSTERY_UNLOCK -> {
                Logger.warn(LogConfigSocketToClient) { "Received 'CRATE_MYSTERY_UNLOCK' message [not implemented]" }
            }
        }
    }
}

===== C:\Users\Sulivan\Desktop\Projects\DeadZone-Private-Server\src\main\kotlin\socket\handler\save\crate\response\CrateUnlockResponse.kt =====
package dev.deadzone.socket.handler.save.crate.response

import dev.deadzone.core.items.ItemFactory
import dev.deadzone.core.items.model.Item
import kotlinx.serialization.Serializable

@Serializable
data class CrateUnlockResponse(
    val success: Boolean = true,
    val item: Item = ItemFactory.getRandomItem(),
    val effect: String? = null,   // base64 encoded, parsed to [Effect]
    val cooldown: String? = null, // similar as above
    val keyId: String? = null, // to remove the key used to open the crate
    val keyQty: Int? = null, // to remove the key used to open the crate
    val crateId: String? = null, // to remove the opened crate
)

val gachaPoolExample = listOf(
    ItemFactory.createItemFromId(idInXML = "exo-rig-heavyBrawler-replica"),
    ItemFactory.createItemFromId(idInXML = "helmet-exo-brawler-replica"),
    ItemFactory.createItemFromId(idInXML = "helmet-exo-targeting-replica"),
    ItemFactory.createItemFromId(idInXML = "mask-herc-exo-replica"),
    ItemFactory.createItemFromId(idInXML = "exo-undershirt-1-replica"),
    ItemFactory.createItemFromId(idInXML = "exo-underpants-1-replica"),
    ItemFactory.createItemFromId(idInXML = "pistol-halloween-reborn"),
    ItemFactory.createItemFromId(idInXML = "pistol-halloween-2-reborn"),
    ItemFactory.createItemFromId(idInXML = "rifle-halloween-reborn"),
    ItemFactory.createItemFromId(idInXML = "rifle-halloween-2-reborn"),
    ItemFactory.createItemFromId(idInXML = "sword-laser-purple-reborn"),
    ItemFactory.createItemFromId(idInXML = "trident-halloween-reborn"),
    ItemFactory.createItemFromId(idInXML = "trident-halloween-2-reborn"),
    ItemFactory.createItemFromId(idInXML = "crossbow-halloween-2015-reborn"),
    ItemFactory.createItemFromId(idInXML = "crossbow-halloween-2015-2-reborn"),
    ItemFactory.createItemFromId(idInXML = "halloween-exo-zombie"),
    ItemFactory.createItemFromId(idInXML = "bladesaw"),
    ItemFactory.createItemFromId(idInXML = "warclub")
)

===== C:\Users\Sulivan\Desktop\Projects\DeadZone-Private-Server\src\main\kotlin\socket\handler\save\item\ItemSaveHandler.kt =====
package dev.deadzone.socket.handler.save.item

import dev.deadzone.context.ServerContext
import dev.deadzone.socket.core.Connection
import dev.deadzone.socket.handler.save.SaveSubHandler
import dev.deadzone.socket.messaging.SaveDataMethod
import dev.deadzone.utils.LogConfigSocketToClient
import dev.deadzone.utils.Logger

class ItemSaveHandler : SaveSubHandler {
    override val supportedTypes: Set<String> = SaveDataMethod.ITEM_SAVES

    override suspend fun handle(
        connection: Connection,
        type: String,
        saveId: String,
        data: Map<String, Any?>,
        send: suspend (ByteArray) -> Unit,
        serverContext: ServerContext
    ) {
        when (type) {
            SaveDataMethod.ITEM -> {
                Logger.warn(LogConfigSocketToClient) { "Received 'ITEM' message [not implemented]" }
            }

            SaveDataMethod.ITEM_BUY -> {
                Logger.warn(LogConfigSocketToClient) { "Received 'ITEM_BUY' message [not implemented]" }
            }

            SaveDataMethod.ITEM_LIST -> {
                Logger.warn(LogConfigSocketToClient) { "Received 'ITEM_LIST' message [not implemented]" }
            }

            SaveDataMethod.ITEM_RECYCLE -> {
                Logger.warn(LogConfigSocketToClient) { "Received 'ITEM_RECYCLE' message [not implemented]" }
            }

            SaveDataMethod.ITEM_DISPOSE -> {
                Logger.warn(LogConfigSocketToClient) { "Received 'ITEM_DISPOSE' message [not implemented]" }
            }

            SaveDataMethod.ITEM_CLEAR_NEW -> {
                Logger.warn(LogConfigSocketToClient) { "Received 'ITEM_CLEAR_NEW' message [not implemented]" }
            }

            SaveDataMethod.ITEM_BATCH_RECYCLE -> {
                Logger.warn(LogConfigSocketToClient) { "Received 'ITEM_BATCH_RECYCLE' message [not implemented]" }
            }

            SaveDataMethod.ITEM_BATCH_RECYCLE_SPEED_UP -> {
                Logger.warn(LogConfigSocketToClient) { "Received 'ITEM_BATCH_RECYCLE_SPEED_UP' message [not implemented]" }
            }

            SaveDataMethod.ITEM_BATCH_DISPOSE -> {
                Logger.warn(LogConfigSocketToClient) { "Received 'ITEM_BATCH_DISPOSE' message [not implemented]" }
            }
        }
    }
}

===== C:\Users\Sulivan\Desktop\Projects\DeadZone-Private-Server\src\main\kotlin\socket\handler\save\misc\MiscSaveHandler.kt =====
package dev.deadzone.socket.handler.save.misc

import dev.deadzone.context.ServerContext
import dev.deadzone.socket.core.Connection
import dev.deadzone.socket.handler.save.SaveSubHandler
import dev.deadzone.socket.messaging.SaveDataMethod
import dev.deadzone.utils.LogConfigSocketToClient
import dev.deadzone.utils.Logger
import dev.deadzone.context.requirePlayerContext
import core.metadata.model.PlayerFlags_Constants
import kotlin.experimental.inv

class MiscSaveHandler : SaveSubHandler {
    override val supportedTypes: Set<String> = SaveDataMethod.MISC_SAVES

    override suspend fun handle(
        connection: Connection,
        type: String,
        saveId: String,
        data: Map<String, Any?>,
        send: suspend (ByteArray) -> Unit,
        serverContext: ServerContext
    ) {
        when (type) {
            SaveDataMethod.TUTORIAL_PVP_PRACTICE -> {
                Logger.warn(LogConfigSocketToClient) { "Received 'TUTORIAL_PVP_PRACTICE' message [not implemented]" }
            }

            SaveDataMethod.TUTORIAL_COMPLETE -> {
                val playerId = connection.playerId
                val services = serverContext.requirePlayerContext(playerId).services
                val current = services.playerObjectMetadata.getPlayerFlags()
                val bitIndex = PlayerFlags_Constants.TutorialComplete.toInt()
                val updated = setFlag(current, bitIndex, true)
                services.playerObjectMetadata.updatePlayerFlags(updated)
                Logger.info(LogConfigSocketToClient) { "Tutorial completed flag set for playerId=$playerId" }
            }

            SaveDataMethod.GET_OFFERS -> {
                Logger.warn(LogConfigSocketToClient) { "Received 'GET_OFFERS' message [not implemented]" }
            }

            SaveDataMethod.NEWS_READ -> {
                Logger.warn(LogConfigSocketToClient) { "Received 'NEWS_READ' message [not implemented]" }
            }

            SaveDataMethod.CLEAR_NOTIFICATIONS -> {
                Logger.warn(LogConfigSocketToClient) { "Received 'CLEAR_NOTIFICATIONS' message [not implemented]" }
            }

            SaveDataMethod.FLUSH_PLAYER -> {
                Logger.warn(LogConfigSocketToClient) { "Received 'FLUSH_PLAYER' message [not implemented]" }
            }

            SaveDataMethod.SAVE_ALT_IDS -> {
                Logger.warn(LogConfigSocketToClient) { "Received 'SAVE_ALT_IDS' message [not implemented]" }
            }

            SaveDataMethod.TRADE_DO_TRADE -> {
                Logger.warn(LogConfigSocketToClient) { "Received 'TRADE_DO_TRADE' message [not implemented]" }
            }

            SaveDataMethod.GET_INVENTORY_SIZE -> {
                Logger.warn(LogConfigSocketToClient) { "Received 'GET_INVENTORY_SIZE' message [not implemented]" }
            }
        }
    }

    private fun setFlag(flags: ByteArray, bitIndex: Int, value: Boolean): ByteArray {
        val byteIndex = bitIndex / 8
        val bitInByte = bitIndex % 8

        val arr = if (flags.size <= byteIndex) {
            flags.copyOf(byteIndex + 1)
        } else {
            flags.copyOf()
        }

        val mask = (1 shl bitInByte).toByte()
        arr[byteIndex] = if (value) {
            (arr[byteIndex].toInt() or mask.toInt()).toByte()
        } else {
            (arr[byteIndex].toInt() and mask.inv().toInt()).toByte()
        }

        return arr
    }

}

===== C:\Users\Sulivan\Desktop\Projects\DeadZone-Private-Server\src\main\kotlin\socket\handler\save\mission\MissionSaveHandler.kt =====
package dev.deadzone.socket.handler.save.mission

import dev.deadzone.context.GlobalContext
import dev.deadzone.context.ServerContext
import dev.deadzone.context.requirePlayerContext
import dev.deadzone.core.mission.LootService
import dev.deadzone.core.mission.model.LootParameter
import dev.deadzone.core.model.game.data.ZombieData
import dev.deadzone.core.model.game.data.toFlatList
import dev.deadzone.core.model.game.data.MissionStats
import dev.deadzone.socket.core.Connection
import dev.deadzone.socket.handler.buildMsg
import dev.deadzone.socket.handler.save.SaveSubHandler
import dev.deadzone.socket.handler.save.mission.response.*
import dev.deadzone.socket.messaging.SaveDataMethod
import dev.deadzone.socket.protocol.PIOSerializer
import dev.deadzone.utils.LogConfigSocketToClient
import dev.deadzone.utils.Logger
import kotlin.random.Random

class MissionSaveHandler : SaveSubHandler {
    override val supportedTypes: Set<String> = SaveDataMethod.MISSION_SAVES

    override suspend fun handle(
        connection: Connection,
        type: String,
        saveId: String,
        data: Map<String, Any?>,
        send: suspend (ByteArray) -> Unit,
        serverContext: ServerContext
    ) {
        val playerId = connection.playerId
        when (type) {
            SaveDataMethod.MISSION_START -> {
                val isCompoundZombieAttack = data["compound"]?.equals(true)
                val areaType = if (isCompoundZombieAttack == true) "compound" else data["areaType"] as String
                Logger.info(LogConfigSocketToClient) { "Going to scene with areaType=$areaType" }

                val svc = serverContext.requirePlayerContext(playerId).services
                val leader = svc.survivor.getSurvivorLeader()

                val sceneXML = resolveAndLoadScene(areaType)
                if (sceneXML == null) {
                    Logger.error(LogConfigSocketToClient) { "That area=$areaType isn't working yet, typically because the map file is lost" }
                    return
                }
                val lootParameter = LootParameter(
                    areaLevel = (data["areaLevel"] as? Int ?: 0),
                    playerLevel = leader.level,
                    itemWeightOverrides = mapOf(),
                    specificItemBoost = mapOf(
                        "fuel-bottle" to 3.0,    // +300% find fuel chance (of the base chance)
                        "fuel-container" to 3.0,
                        "fuel" to 3.0,
                        "fuel-cans" to 3.0,
                    ),
                    itemTypeBoost = mapOf(
                        "junk" to 0.8 // +80% junk find chance
                    ),
                    itemQualityBoost = mapOf(
                        "blue" to 0.5 // +50% blue quality find chance
                    ),
                    baseWeight = 1.0,
                    fuelLimit = 50
                )
                val lootService = LootService(GlobalContext.gameDefinitions, sceneXML, lootParameter)
                val sceneXMLWithLoot = lootService.insertLoots()

                val zombies = listOf(
                    ZombieData.standardZombieWeakAttack(Random.nextInt()),
                    ZombieData.standardZombieWeakAttack(Random.nextInt()),
                    ZombieData.standardZombieWeakAttack(Random.nextInt()),
                    ZombieData.standardZombieWeakAttack(Random.nextInt()),
                    ZombieData.dogStandard(Random.nextInt()),
                    ZombieData.dogStandard(Random.nextInt()),
                    ZombieData.fatWalkerStrongAttack(Random.nextInt()),
                ).flatMap { it.toFlatList() }

                val timeSeconds = if (isCompoundZombieAttack == true) 30 else 240

                val responseJson = GlobalContext.json.encodeToString(
                    MissionStartResponse(
                        id = saveId,
                        time = timeSeconds,
                        assignmentType = "None", // 'None' because not a raid or arena. see AssignmentType
                        areaClass = (data["areaClass"] as String?) ?: "", // supposedly depend on the area
                        automated = false, // this depends on request data
                        sceneXML = sceneXMLWithLoot,
                        z = zombies,
                        allianceAttackerEnlisting = false,
                        allianceAttackerLockout = false,
                        allianceAttackerAllianceId = null,
                        allianceAttackerAllianceTag = null,
                        allianceMatch = false,
                        allianceRound = 0,
                        allianceRoundActive = false,
                        allianceError = false,
                        allianceAttackerWinPoints = 0
                    )
                )

                send(PIOSerializer.serialize(buildMsg(saveId, responseJson)))
            }

            SaveDataMethod.MISSION_START_FLAG -> {
                Logger.info { "<----- Mission start flag received ----->" }
            }

            SaveDataMethod.MISSION_INTERACTION_FLAG -> {
                Logger.info { "<----- First interaction received ----->" }
            }

            SaveDataMethod.MISSION_END -> {
                val svc = serverContext.requirePlayerContext(playerId).services
                val leader = svc.survivor.getSurvivorLeader()

                val responseJson = GlobalContext.json.encodeToString(
                    MissionEndResponse(
                        automated = false,
                        xpEarned = 100,
                        xp = null,
                        returnTimer = null,
                        lockTimer = null,
                        loot = emptyList(),
                        itmCounters = emptyMap(),
                        injuries = null,
                        survivors = emptyList(),
                        player = PlayerSurvivor(xp = 100, level = leader.level),
                        levelPts = 0,
                        cooldown = null
                    )
                )

                val currentResource = svc.compound.getResources()

                val resourceResponseJson = GlobalContext.json.encodeToString(currentResource)

                send(PIOSerializer.serialize(buildMsg(saveId, responseJson, resourceResponseJson)))
            }

            SaveDataMethod.MISSION_ZOMBIES -> {

                val zombies = listOf(
                    ZombieData.strongRunner(Random.nextInt()),
                    ZombieData.strongRunner(Random.nextInt()),
                    ZombieData.standardZombieWeakAttack(Random.nextInt()),
                    ZombieData.standardZombieWeakAttack(Random.nextInt()),
                    ZombieData.fatWalkerStrongAttack(104),
                    ZombieData.fatWalkerStrongAttack(105),
                ).flatMap { it.toFlatList() }

                val responseJson = GlobalContext.json.encodeToString(
                    GetZombieResponse(
                        max = false,
                        z = zombies
                    )
                )

                Logger.info(LogConfigSocketToClient) { "'mis_zombies' message (spawn zombie) request received" }

                send(PIOSerializer.serialize(buildMsg(saveId, responseJson)))
            }

            SaveDataMethod.MISSION_INJURY -> {
                Logger.warn(LogConfigSocketToClient) { "Received 'MISSION_INJURY' message [not implemented]" }
            }

            SaveDataMethod.MISSION_SPEED_UP -> {
                Logger.warn(LogConfigSocketToClient) { "Received 'MISSION_SPEED_UP' message [not implemented]" }
            }

            SaveDataMethod.MISSION_SCOUTED -> {
                Logger.warn(LogConfigSocketToClient) { "Received 'MISSION_SCOUTED' message [not implemented]" }
            }

            SaveDataMethod.MISSION_ITEM_USE -> {
                Logger.warn(LogConfigSocketToClient) { "Received 'MISSION_ITEM_USE' message [not implemented]" }
            }

            SaveDataMethod.MISSION_TRIGGER -> {
                Logger.warn(LogConfigSocketToClient) { "Received 'MISSION_TRIGGER' message [not implemented]" }
            }

            SaveDataMethod.MISSION_ELITE_SPAWNED -> {
                Logger.warn(LogConfigSocketToClient) { "Received 'MISSION_ELITE_SPAWNED' message [not implemented]" }
            }

            SaveDataMethod.MISSION_ELITE_KILLED -> {
                Logger.warn(LogConfigSocketToClient) { "Received 'MISSION_ELITE_KILLED' message [not implemented]" }
            }

            SaveDataMethod.STAT_DATA -> {
                val stats = data["stats"]
                Logger.debug(logFull = true) { data["stats"].toString() }
                Logger.warn(LogConfigSocketToClient) { "Received 'STAT_DATA' message on MissionSaveHandler [not implemented] with stats: $stats" }
                val missionStats = parseMissionStats(data["stats"])
                Logger.debug(logFull = true) { "STAT_DATA parsed: $missionStats" }
            }
            SaveDataMethod.STAT -> {
                val stats = data["stats"]
                Logger.debug(logFull = true) { data["stats"].toString() }
                Logger.warn(LogConfigSocketToClient) { "Received 'STAT_DATA' message on MissionSaveHandler [not implemented] with stats: $stats" }
                val missionStats = parseMissionStats(data["stats"])
                Logger.debug(logFull = true) { "STAT parsed: $missionStats" }
            }
        }
    }

    private fun parseMissionStats(raw: Any?): MissionStats {
        val m = (raw as? Map<*, *>) ?: emptyMap<Any?, Any?>()
        fun asInt(v: Any?): Int = when (v) {
            is Int -> v
            is Long -> v.toInt()
            is Double -> v.toInt()
            is Float -> v.toInt()
            is Number -> v.toInt()
            is String -> v.toIntOrNull() ?: 0
            else -> 0
        }
        fun asDouble(v: Any?): Double = when (v) {
            is Double -> v
            is Float -> v.toDouble()
            is Int -> v.toDouble()
            is Long -> v.toDouble()
            is Number -> v.toDouble()
            is String -> v.toDoubleOrNull() ?: 0.0
            else -> 0.0
        }

        val knownKeys = setOf(
            "zombieSpawned", "levelUps", "damageOutput", "damageTaken", "containersSearched",
            "survivorKills", "survivorsDowned", "survivorExplosiveKills",
            "humanKills", "humanExplosiveKills",
            "zombieKills", "zombieExplosiveKills",
            "hpHealed", "explosivesPlaced", "grenadesThrown", "grenadesSmokeThrown",
            "allianceFlagCaptured", "buildingsDestroyed", "buildingsLost", "buildingsExplosiveDestroyed",
            "trapsTriggered", "trapDisarmTriggered",
            "cashFound", "woodFound", "metalFound", "clothFound", "foodFound", "waterFound",
            "ammunitionFound", "ammunitionUsed",
            "weaponsFound", "gearFound", "junkFound", "medicalFound", "craftingFound",
            "researchFound", "researchNoteFound", "clothingFound", "cratesFound", "schematicsFound",
            "effectFound", "rareWeaponFound", "rareGearFound", "uniqueWeaponFound", "uniqueGearFound",
            "greyWeaponFound", "greyGearFound", "whiteWeaponFound", "whiteGearFound",
            "greenWeaponFound", "greenGearFound", "blueWeaponFound", "blueGearFound",
            "purpleWeaponFound", "purpleGearFound", "premiumWeaponFound", "premiumGearFound"
        )

        val killData = buildMap<String, Int> {
            for ((kAny, v) in m) {
                val k = kAny?.toString() ?: continue
                if (k.endsWith("-kills") || k.endsWith("-explosive-kills")) {
                    put(k, asInt(v))
                }
            }
        }

        val customData = buildMap<String, Int> {
            for ((kAny, v) in m) {
                val k = kAny?.toString() ?: continue
                if (k !in knownKeys && !k.endsWith("-kills") && !k.endsWith("-explosive-kills")) {
                    val iv = asInt(v)
                    if (iv != 0) put(k, iv)
                }
            }
        }

        return MissionStats(
            zombieSpawned = asInt(m["zombieSpawned"]),
            levelUps = asInt(m["levelUps"]),
            damageOutput = asDouble(m["damageOutput"]),
            damageTaken = asDouble(m["damageTaken"]),
            containersSearched = asInt(m["containersSearched"]),
            survivorKills = asInt(m["survivorKills"]),
            survivorsDowned = asInt(m["survivorsDowned"]),
            survivorExplosiveKills = asInt(m["survivorExplosiveKills"]),
            humanKills = asInt(m["humanKills"]),
            humanExplosiveKills = asInt(m["humanExplosiveKills"]),
            zombieKills = asInt(m["zombieKills"]),
            zombieExplosiveKills = asInt(m["zombieExplosiveKills"]),
            hpHealed = asInt(m["hpHealed"]),
            explosivesPlaced = asInt(m["explosivesPlaced"]),
            grenadesThrown = asInt(m["grenadesThrown"]),
            grenadesSmokeThrown = asInt(m["grenadesSmokeThrown"]),
            allianceFlagCaptured = asInt(m["allianceFlagCaptured"]),
            buildingsDestroyed = asInt(m["buildingsDestroyed"]),
            buildingsLost = asInt(m["buildingsLost"]),
            buildingsExplosiveDestroyed = asInt(m["buildingsExplosiveDestroyed"]),
            trapsTriggered = asInt(m["trapsTriggered"]),
            trapDisarmTriggered = asInt(m["trapDisarmTriggered"]),
            cashFound = asInt(m["cashFound"]),
            woodFound = asInt(m["woodFound"]),
            metalFound = asInt(m["metalFound"]),
            clothFound = asInt(m["clothFound"]),
            foodFound = asInt(m["foodFound"]),
            waterFound = asInt(m["waterFound"]),
            ammunitionFound = asInt(m["ammunitionFound"]),
            ammunitionUsed = asInt(m["ammunitionUsed"]),
            weaponsFound = asInt(m["weaponsFound"]),
            gearFound = asInt(m["gearFound"]),
            junkFound = asInt(m["junkFound"]),
            medicalFound = asInt(m["medicalFound"]),
            craftingFound = asInt(m["craftingFound"]),
            researchFound = asInt(m["researchFound"]),
            researchNoteFound = asInt(m["researchNoteFound"]),
            clothingFound = asInt(m["clothingFound"]),
            cratesFound = asInt(m["cratesFound"]),
            schematicsFound = asInt(m["schematicsFound"]),
            effectFound = asInt(m["effectFound"]),
            rareWeaponFound = asInt(m["rareWeaponFound"]),
            rareGearFound = asInt(m["rareGearFound"]),
            uniqueWeaponFound = asInt(m["uniqueWeaponFound"]),
            uniqueGearFound = asInt(m["uniqueGearFound"]),
            greyWeaponFound = asInt(m["greyWeaponFound"]),
            greyGearFound = asInt(m["greyGearFound"]),
            whiteWeaponFound = asInt(m["whiteWeaponFound"]),
            whiteGearFound = asInt(m["whiteGearFound"]),
            greenWeaponFound = asInt(m["greenWeaponFound"]),
            greenGearFound = asInt(m["greenGearFound"]),
            blueWeaponFound = asInt(m["blueWeaponFound"]),
            blueGearFound = asInt(m["blueGearFound"]),
            purpleWeaponFound = asInt(m["purpleWeaponFound"]),
            purpleGearFound = asInt(m["purpleGearFound"]),
            premiumWeaponFound = asInt(m["premiumWeaponFound"]),
            premiumGearFound = asInt(m["premiumGearFound"]),
            killData = killData,
            customData = customData
        )
    }
}

===== C:\Users\Sulivan\Desktop\Projects\DeadZone-Private-Server\src\main\kotlin\socket\handler\save\mission\response\GetZombieResponse.kt =====
package dev.deadzone.socket.handler.save.mission.response

import dev.deadzone.socket.handler.save.BaseResponse
import kotlinx.serialization.Serializable

/**
 * Get zombie response (mis_zombies)
 *
 * @property max server spawning is disabled if set to false
 */
@Serializable
data class GetZombieResponse(
    val z: List<String>,
    val max: Boolean = false,
): BaseResponse()

===== C:\Users\Sulivan\Desktop\Projects\DeadZone-Private-Server\src\main\kotlin\socket\handler\save\mission\response\MissionEndResponse.kt =====
package dev.deadzone.socket.handler.save.mission.response

import dev.deadzone.core.items.model.Item
import dev.deadzone.core.model.game.data.Morale
import dev.deadzone.core.model.game.data.TimerData
import dev.deadzone.core.model.game.data.assignment.AssignmentResult
import dev.deadzone.core.survivor.model.injury.Injury
import kotlinx.serialization.Serializable

@Serializable
data class MissionEndResponse(
    val bountyCollect: Boolean = false,
    val bounty: Double? = null,
    val allianceFlagCaptured: Boolean = false,
    val bountyCap: Int? = null,
    val bountyCapTimestamp: Long? = null,

    val assignmentresult: AssignmentResult? = null,

    val automated: Boolean = false,
    val xpEarned: Int = 120,
    val xp: XpBreakdown? = null,
    val returnTimer: TimerData? = null,
    val lockTimer: TimerData? = null,
    val loot: List<Item> = emptyList(),
    val itmCounters: Map<String, Int> = emptyMap(), // item id to quantity
    val injuries: List<InjuryData>? = null,
    val survivors: List<SurvivorResult> = emptyList(),
    val player: PlayerSurvivor = PlayerSurvivor(),
    val levelPts: Int = 0,
    val cooldown: String? = null // base64 encoded string
)

@Serializable
data class XpBreakdown(
    val total: Int? = 120,
)

@Serializable
data class InjuryData(
    val success: Boolean = false, // false = didn't die
    val survivorId: String,
    val injury: Injury
)

@Serializable
data class SurvivorResult(
    val id: String, // survivor id
    val morale: Morale? = null,
    val xp: Int,
    val level: Int
)

@Serializable
data class PlayerSurvivor(
    val xp: Int = 120, // end xp after mission
    val level: Int = 60 // end level after mission
)

===== C:\Users\Sulivan\Desktop\Projects\DeadZone-Private-Server\src\main\kotlin\socket\handler\save\mission\response\MissionStartResponse.kt =====
package dev.deadzone.socket.handler.save.mission.response

import dev.deadzone.socket.handler.save.BaseResponse
import kotlinx.serialization.Serializable
import java.io.File
import java.io.InputStreamReader
import java.util.zip.GZIPInputStream

@Serializable
data class MissionStartResponse(
    val disabled: Boolean = false,
    val id: String,
    val time: Int,
    val assignmentType: String,
    val areaClass: String,
    val automated: Boolean = false,
    val sceneXML: String,
    val z: List<String>,
    val allianceAttackerEnlisting: Boolean,
    val allianceAttackerLockout: Boolean,
    val allianceAttackerAllianceId: String?,
    val allianceAttackerAllianceTag: String?,
    val allianceMatch: Boolean,
    val allianceRound: Int,
    val allianceRoundActive: Boolean,
    val allianceError: Boolean,
    val allianceAttackerWinPoints: Int,
) : BaseResponse()

fun resolveAndLoadScene(areaType: String): String? {
    val scene = areaTypeToScenes[areaType]?.random()
    return scene?.let { loadSceneXML(it) }
}

fun loadSceneXML(filename: String): String {
    val path = "static/game/data/xml/scenes/$filename.xml.gz"
    val file = File(path)

    GZIPInputStream(file.inputStream()).use { gzipStream ->
        InputStreamReader(gzipStream, Charsets.UTF_8).use { reader ->
            return reader.readText()
        }
    }
}

val areaTypeToScenes = mapOf(

    "compound" to listOf(
        "compound"
    ),
    "bridge" to listOf(
        "exterior-bridge-1",
        "exterior-bridge-2",
        "exterior-bridge-3"
    ),
    "cityBlock" to listOf(
        "exterior-cityblock-1",
        "exterior-cityblock-2",
        "exterior-cityblock-3",
        "exterior-cityblock-4",
        "exterior-cityblock-5"
    ),
    "constSiteLarge" to listOf(
        "exterior-construction-1",
        "exterior-construction-2",
        "exterior-construction-3"
    ),
    "constSiteSmall" to listOf(
        "exterior-construction-small-1",
        "exterior-construction-small-2",
        "exterior-construction-small-3"
    ),
    "depot" to listOf(
        "exterior-depot-1",
        "exterior-depot-2",
        "exterior-depot-3"
    ),
    "dock" to listOf(
        "exterior-dock-1",
        "exterior-dock-2"
    ),
    "farm" to listOf(
        "exterior-farm-1",
        "exterior-farm-2",
    ),
    "highway" to listOf(
        "exterior-highway-1",
        "exterior-highway-2",
        "exterior-highway-3",
    ),
    "highwaySmall" to listOf(
        "exterior-highway-small-1",
        "exterior-highway-small-2",
        "exterior-highway-small-3",
    ),
    "militarybase" to listOf(
        "exterior-militarybase-1",
        "exterior-militarybase-2",
        "exterior-militarybase-3"
    ),
    "militaryDock" to listOf(
        "exterior-militarydock-1",
        "exterior-militarydock-2",
    ),
    "motelLarge" to listOf(
        "exterior-motel-1",
        "exterior-motel-2",
        "exterior-motel-3"
    ),
    "motel" to listOf(
        "exterior-motel-small-1",
        "exterior-motel-small-2",
        "exterior-motel-small-3"
    ),
    "parkLarge" to listOf(
        "exterior-park-large-1",
        "exterior-park-large-2",
        "exterior-park-large-3"
    ),
    "parkMedium" to listOf(
        "exterior-park-medium-1",
        "exterior-park-medium-2",
        "exterior-park-medium-3"
    ),
    "prison" to listOf(
        "exterior-prison-1",
        "exterior-prison-2",
        "exterior-prison-3",
    ),
    "shoppingstrip" to listOf(
        "exterior-shoppingstrip-1",
        "exterior-shoppingstrip-2",
    ),
    "shoppingStripSmall" to listOf(
        "exterior-shoppingstrip-small-1",
        "exterior-shoppingstrip-small-2",
    ),
    "subblock" to listOf(
        "exterior-subblock-1",
        "exterior-subblock-2"
    ),
    "trainStationLarge" to listOf(
        "exterior-trainstation-1",
        "exterior-trainstation-2"
    ),
    "trainStationSmall" to listOf(
        "exterior-trainstation-small-1",
        "exterior-trainstation-small-2"
    ),
    "trainYard" to listOf(
        "exterior-trainyard-1",
        "exterior-trainyard-2"
    ),
    "gunStore" to listOf(
        "interior-gunstore-1",
        "interior-gunstore-2",
        "interior-gunstore-3"
    ),
    "hardwareStoreLarge" to listOf(
        "interior-hardwarestore-large-1",
        "interior-hardwarestore-large-2",
        "interior-hardwarestore-large-3"
    ),
    "hospital" to listOf(
        "interior-hospital-1",
        "interior-hospital-2",
        "interior-hospital-3"
    ),
    "officeLarge" to listOf(
        "interior-office-large-1",
        "interior-office-large-2",
        "interior-office-large-3"
    ),
    "officeMedium" to listOf(
        "interior-office-medium-1",
        "interior-office-medium-2"
    ),
    "office" to listOf(
        "interior-office-small-1"
    ),
    "police" to listOf(
        "interior-police-large-1",
        "interior-police-large-2",
        "interior-police-large-3",
        "interior-police-medium-1",
        "interior-police-medium-2",
        "interior-police-medium-3"
    ),
    "residential" to listOf(
        "interior-residential",
        "interior-residential-2",
        "interior-residential-3",
        "interior-residential-4",
        "interior-residential-5"
    ),
    "resLarge" to listOf(
        "interior-residential-large-1",
        "interior-residential-large-2",
        "interior-residential-large-3"
    ),
    "security" to listOf(
        "interior-security-1",
        "interior-security-2",
        "interior-security-3",
    ),
    "store" to listOf(
        "interior-store-1",
        "interior-store-2",
        "interior-store-3"
    ),
    "tutorialStore" to listOf(
        "interior-store-small-1",
        "interior-store-small-2"
    ),
    "hardwareStore" to listOf(
        "interior-store-small-1",
        "interior-store-small-2"
    ),
    "subway" to listOf(
        "interior-subway-1",
        "interior-subway-2",
        "interior-subway-3"
    ),
    "subwayLarge" to listOf(
        "interior-subway-large-1",
        "interior-subway-large-2",
        "interior-subway-large-3"
    ),
    "superMarket" to listOf(
        "interior-supermarket-1",
        "interior-supermarket-2"
    ),
    "superMarketLarge" to listOf(
        "interior-supermarket-large-1",
        "interior-supermarket-large-2"
    ),
    "warehouse" to listOf(
        "interior-warehouse-1",
        "interior-warehouse-2",
        "interior-warehouse-3"
    ),
    "warehouseMedium" to listOf(
        "interior-warehouse-small-1",
        "interior-warehouse-small-2",
        "interior-warehouse-small-3"
    ),
    "streetSmall" to listOf(
        "street-small-1",
        "street-small-2",
        "street-small-3"
    ),

    "raidBridgeHuman" to listOf(
        "raid-island-bridge-human-01",
        "raid-island-bridge-human-02",
        "raid-island-bridge-human-03"
    ),
    "raidBridgeZombie" to listOf(
        "raid-island-bridge-zombie-01",
        "raid-island-bridge-zombie-02",
        "raid-island-bridge-zombie-03"
    ),
    "raidCompoundHuman" to listOf(
        "raid-island-compound-human-01",
        "raid-island-compound-human-02",
        "raid-island-compound-human-03"
    ),
    "raidCompoundZombie" to listOf(
        "raid-island-compound-zombie-01",
        "raid-island-compound-zombie-02",
        "raid-island-compound-zombie-03"
    ),
    "raidMonumentHuman" to listOf(
        "raid-island-monument-human-01",
        "raid-island-monument-human-02",
        "raid-island-monument-human-03"
    ),
    "raidMonumentZombie" to listOf(
        "raid-island-monument-zombie-01",
        "raid-island-monument-zombie-02",
        "raid-island-monument-zombie-03"
    ),

    "stadium" to listOf(
        "exterior-stadium-1-no-spawn",
        "exterior-stadium-3-no-spawn",
        "exterior-stadium-5-no-spawn",
        "exterior-stadium-6-no-spawn",
        "exterior-stadium-7-no-spawn",
        "exterior-stadium-8-no-spawn",
        "exterior-stadium-9-no-spawn",
        "exterior-stadium-10-no-spawn",
        "exterior-stadium-11-no-spawn"
    ),
)

===== C:\Users\Sulivan\Desktop\Projects\DeadZone-Private-Server\src\main\kotlin\socket\handler\save\purchase\PurchaseSaveHandler.kt =====
package dev.deadzone.socket.handler.save.purchase

import dev.deadzone.context.ServerContext
import dev.deadzone.socket.core.Connection
import dev.deadzone.socket.handler.save.SaveSubHandler
import dev.deadzone.socket.messaging.SaveDataMethod
import dev.deadzone.utils.LogConfigSocketToClient
import dev.deadzone.utils.Logger

class PurchaseSaveHandler : SaveSubHandler {
    override val supportedTypes: Set<String> = SaveDataMethod.PURCHASE_SAVES

    override suspend fun handle(
        connection: Connection,
        type: String,
        saveId: String,
        data: Map<String, Any?>,
        send: suspend (ByteArray) -> Unit,
        serverContext: ServerContext
    ) {
        when (type) {
            SaveDataMethod.RESOURCE_BUY -> {
                Logger.warn(LogConfigSocketToClient) { "Received 'RESOURCE_BUY' message [not implemented]" }
            }

            SaveDataMethod.PROTECTION_BUY -> {
                Logger.warn(LogConfigSocketToClient) { "Received 'PROTECTION_BUY' message [not implemented]" }
            }

            SaveDataMethod.PAYVAULT_BUY -> {
                Logger.warn(LogConfigSocketToClient) { "Received 'PAYVAULT_BUY' message [not implemented]" }
            }

            SaveDataMethod.CLAIM_PROMO_CODE -> {
                Logger.warn(LogConfigSocketToClient) { "Received 'CLAIM_PROMO_CODE' message [not implemented]" }
            }

            SaveDataMethod.BUY_PACKAGE -> {
                Logger.warn(LogConfigSocketToClient) { "Received 'BUY_PACKAGE' message [not implemented]" }
            }

            SaveDataMethod.CHECK_APPLY_DIRECT_PURCHASE -> {
                Logger.warn(LogConfigSocketToClient) { "Received 'CHECK_APPLY_DIRECT_PURCHASE' message [not implemented]" }
            }

            SaveDataMethod.HAS_PAYVAULT_ITEM -> {
                Logger.warn(LogConfigSocketToClient) { "Received 'HAS_PAYVAULT_ITEM' message [not implemented]" }
            }

            SaveDataMethod.INCREMENT_PURCHASE_COUNT -> {
                Logger.warn(LogConfigSocketToClient) { "Received 'INCREMENT_PURCHASE_COUNT' message [not implemented]" }
            }

            SaveDataMethod.DEATH_MOBILE_RENAME -> {
                Logger.warn(LogConfigSocketToClient) { "Received 'DEATH_MOBILE_RENAME' message [not implemented]" }
            }
        }
    }
}

===== C:\Users\Sulivan\Desktop\Projects\DeadZone-Private-Server\src\main\kotlin\socket\handler\save\quest\QuestSaveHandler.kt =====
package dev.deadzone.socket.handler.save.quest

import dev.deadzone.context.ServerContext
import dev.deadzone.socket.core.Connection
import dev.deadzone.socket.handler.save.SaveSubHandler
import dev.deadzone.socket.messaging.SaveDataMethod
import dev.deadzone.utils.LogConfigSocketToClient
import dev.deadzone.utils.Logger

class QuestSaveHandler : SaveSubHandler {
    override val supportedTypes: Set<String> = SaveDataMethod.QUEST_SAVES

    override suspend fun handle(
        connection: Connection,
        type: String,
        saveId: String,
        data: Map<String, Any?>,
        send: suspend (ByteArray) -> Unit,
        serverContext: ServerContext
    ) {
        when (type) {
            SaveDataMethod.QUEST_COLLECT -> {
                Logger.warn(LogConfigSocketToClient) { "Received 'QUEST_COLLECT' message [not implemented]" }
            }

            SaveDataMethod.QUEST_TRACK -> {
                Logger.warn(LogConfigSocketToClient) { "Received 'QUEST_TRACK' message [not implemented]" }
            }

            SaveDataMethod.QUEST_UNTRACK -> {
                Logger.warn(LogConfigSocketToClient) { "Received 'QUEST_UNTRACK' message [not implemented]" }
            }

            SaveDataMethod.QUEST_DAILY_DECLINE -> {
                Logger.warn(LogConfigSocketToClient) { "Received 'QUEST_DAILY_DECLINE' message [not implemented]" }
            }

            SaveDataMethod.QUEST_DAILY_ACCEPT -> {
                Logger.warn(LogConfigSocketToClient) { "Received 'QUEST_DAILY_ACCEPT' message [not implemented]" }
            }

            SaveDataMethod.REPEAT_ACHIEVEMENT -> {
                Logger.warn(LogConfigSocketToClient) { "Received 'REPEAT_ACHIEVEMENT' message [not implemented]" }
            }

            SaveDataMethod.GLOBAL_QUEST_COLLECT -> {
                Logger.warn(LogConfigSocketToClient) { "Received 'GLOBAL_QUEST_COLLECT' message [not implemented]" }
            }
        }
    }
}

===== C:\Users\Sulivan\Desktop\Projects\DeadZone-Private-Server\src\main\kotlin\socket\handler\save\raid\RaidSaveHandler.kt =====
package dev.deadzone.socket.handler.save.raid

import dev.deadzone.context.ServerContext
import dev.deadzone.socket.core.Connection
import dev.deadzone.socket.handler.save.SaveSubHandler
import dev.deadzone.socket.messaging.SaveDataMethod
import dev.deadzone.utils.LogConfigSocketToClient
import dev.deadzone.utils.Logger

class RaidSaveHandler : SaveSubHandler {
    override val supportedTypes: Set<String> = SaveDataMethod.RAID_SAVES

    override suspend fun handle(
        connection: Connection,
        type: String,
        saveId: String,
        data: Map<String, Any?>,
        send: suspend (ByteArray) -> Unit,
        serverContext: ServerContext
    ) {
        when (type) {
            SaveDataMethod.RAID_START -> {
                Logger.warn(LogConfigSocketToClient) { "Received 'RAID_START' message [not implemented]" }
            }

            SaveDataMethod.RAID_CONTINUE -> {
                Logger.warn(LogConfigSocketToClient) { "Received 'RAID_CONTINUE' message [not implemented]" }
            }

            SaveDataMethod.RAID_ABORT -> {
                Logger.warn(LogConfigSocketToClient) { "Received 'RAID_ABORT' message [not implemented]" }
            }

            SaveDataMethod.RAID_DEATH -> {
                Logger.warn(LogConfigSocketToClient) { "Received 'RAID_DEATH' message [not implemented]" }
            }
        }
    }
}

===== C:\Users\Sulivan\Desktop\Projects\DeadZone-Private-Server\src\main\kotlin\socket\handler\save\survivor\SurvivorSaveHandler.kt =====
package dev.deadzone.socket.handler.save.survivor

import dev.deadzone.context.GlobalContext
import dev.deadzone.context.ServerContext
import dev.deadzone.context.requirePlayerContext
import core.metadata.model.PlayerFlags
import dev.deadzone.core.model.game.data.HumanAppearance
import dev.deadzone.socket.core.Connection
import dev.deadzone.socket.handler.buildMsg
import dev.deadzone.socket.handler.save.SaveSubHandler
import dev.deadzone.socket.handler.save.survivor.response.PlayerCustomResponse
import dev.deadzone.socket.messaging.SaveDataMethod
import dev.deadzone.socket.protocol.PIOSerializer
import dev.deadzone.utils.LogConfigSocketToClient
import dev.deadzone.utils.Logger

class SurvivorSaveHandler : SaveSubHandler {
    override val supportedTypes: Set<String> = SaveDataMethod.SURVIVOR_SAVES

    override suspend fun handle(
        connection: Connection,
        type: String,
        saveId: String,
        data: Map<String, Any?>,
        send: suspend (ByteArray) -> Unit,
        serverContext: ServerContext
    ) {
        val playerId = connection.playerId

        when (type) {
            SaveDataMethod.SURVIVOR_CLASS -> {
                Logger.warn(LogConfigSocketToClient) { "Received 'SURVIVOR_CLASS' message [not implemented]" }
            }

            SaveDataMethod.SURVIVOR_OFFENCE_LOADOUT -> {
                Logger.warn(LogConfigSocketToClient) { "Received 'SURVIVOR_OFFENCE_LOADOUT' message [not implemented]" }
            }

            SaveDataMethod.SURVIVOR_DEFENCE_LOADOUT -> {
                Logger.warn(LogConfigSocketToClient) { "Received 'SURVIVOR_DEFENCE_LOADOUT' message [not implemented]" }
            }

            SaveDataMethod.SURVIVOR_CLOTHING_LOADOUT -> {
                Logger.warn(LogConfigSocketToClient) { "Received 'SURVIVOR_CLOTHING_LOADOUT' message [not implemented]" }
            }

            SaveDataMethod.SURVIVOR_INJURY_SPEED_UP -> {
                Logger.warn(LogConfigSocketToClient) { "Received 'SURVIVOR_INJURY_SPEED_UP' message [not implemented]" }
            }

            SaveDataMethod.SURVIVOR_RENAME -> {
                Logger.warn(LogConfigSocketToClient) { "Received 'SURVIVOR_RENAME' message [not implemented]" }
            }

            SaveDataMethod.SURVIVOR_REASSIGN -> {
                Logger.warn(LogConfigSocketToClient) { "Received 'SURVIVOR_REASSIGN' message [not implemented]" }
            }

            SaveDataMethod.SURVIVOR_REASSIGN_SPEED_UP -> {
                Logger.warn(LogConfigSocketToClient) { "Received 'SURVIVOR_REASSIGN_SPEED_UP' message [not implemented]" }
            }

            SaveDataMethod.SURVIVOR_BUY -> {
                Logger.warn(LogConfigSocketToClient) { "Received 'SURVIVOR_BUY' message [not implemented]" }
            }

            SaveDataMethod.SURVIVOR_INJURE -> {
                Logger.warn(LogConfigSocketToClient) { "Received 'SURVIVOR_INJURE' message [not implemented]" }
            }

            SaveDataMethod.SURVIVOR_ENEMY_INJURE -> {
                Logger.warn(LogConfigSocketToClient) { "Received 'SURVIVOR_ENEMY_INJURE' message [not implemented]" }
            }

            SaveDataMethod.SURVIVOR_HEAL_INJURY -> {
                Logger.warn(LogConfigSocketToClient) { "Received 'SURVIVOR_HEAL_INJURY' message [not implemented]" }
            }

            SaveDataMethod.SURVIVOR_HEAL_ALL -> {
                Logger.warn(LogConfigSocketToClient) { "Received 'SURVIVOR_HEAL_ALL' message [not implemented]" }
            }

            SaveDataMethod.PLAYER_CUSTOM -> {
                val ap = data["ap"] as? Map<*, *> ?: return
                val title = data["name"] as? String ?: return
                val voice = data["v"] as? String ?: return
                val gender = data["g"] as? String ?: return
                val appearance = HumanAppearance.parse(ap)
                if (appearance == null) {
                    Logger.error(LogConfigSocketToClient) { "Failed to parse rawappearance=$ap" }
                    return
                }

                val bannedNicknames = listOf("dick")
                val nicknameNotAllowed = bannedNicknames.any { bannedWord ->
                    title.contains(bannedWord)
                }
                if (nicknameNotAllowed) {
                    val responseJson = GlobalContext.json.encodeToString(
                        PlayerCustomResponse(error = "Nickname not allowed")
                    )
                    send(PIOSerializer.serialize(buildMsg(saveId, responseJson)))
                    return
                }

                val svc = serverContext.requirePlayerContext(playerId).services

                svc.playerObjectMetadata.updatePlayerFlags(
                    flags = PlayerFlags.create(nicknameVerified = true)
                )

                svc.playerObjectMetadata.updatePlayerNickname(nickname = title)

                svc.survivor.updateSurvivor(srvId = svc.survivor.survivorLeaderId) {
                    svc.survivor.getSurvivorLeader().copy(
                        title = title,
                        firstName = title.split(" ").firstOrNull() ?: "",
                        lastName = title.split(" ").getOrNull(1) ?: "",
                        voice = voice,
                        gender = gender,
                        appearance = appearance
                    )
                }

                val responseJson = GlobalContext.json.encodeToString(PlayerCustomResponse())

                send(PIOSerializer.serialize(buildMsg(saveId, responseJson)))
            }

            SaveDataMethod.SURVIVOR_EDIT -> {
                Logger.warn(LogConfigSocketToClient) { "Received 'SURVIVOR_EDIT' message [not implemented]" }
            }

            SaveDataMethod.NAMES -> {
                Logger.warn(LogConfigSocketToClient) { "Received 'NAMES' message [not implemented]" }
            }

            SaveDataMethod.RESET_LEADER -> {
                Logger.warn(LogConfigSocketToClient) { "Received 'RESET_LEADER' message [not implemented]" }
            }
        }
    }
}

===== C:\Users\Sulivan\Desktop\Projects\DeadZone-Private-Server\src\main\kotlin\socket\handler\save\survivor\response\PlayerCustomResponse.kt =====
package dev.deadzone.socket.handler.save.survivor.response

import dev.deadzone.socket.handler.save.BaseResponse
import kotlinx.serialization.Serializable

/**
 * Any update to player's leader, such as create leader, respec
 */
@Serializable
data class PlayerCustomResponse(
    val error: String? = null,

    val attributes: List<String> = emptyList(),

    val levelPts: Int? = null,

    val cooldown: String? = null,
): BaseResponse()

===== C:\Users\Sulivan\Desktop\Projects\DeadZone-Private-Server\src\main\kotlin\socket\messaging\CommandMessage.kt =====
package dev.deadzone.socket.messaging

/**
 * CC commands constants used by the game.
 */
@Suppress("Unused", "SpellCheckingInspection")
object CommandMessage {
    const val STORE_CLEAR = "storeClear"
    const val STORE_BLOCK = "storeBlock"
    const val SPAWN_ELITE = "spawnelite"
    const val ELITE_CHANCE = "elitechance"
    const val ADD_BOUNTY = "addbounty"
    const val LEVEL = "level"
    const val SERVER_TIME = "serverTime"
    const val ZOMBIE = "zombie"
    const val TIME = "time"
    const val STAT = "stat"
    const val GIVE_AMOUNT = "giveAmount"
    const val GIVE = "give"
    const val GIVE_RARE = "giveRare"
    const val GIVE_UNIQUE = "giveUnique"
    const val COUNTER = "counter"
    const val DAILY_QUEST = "dq"
    const val CHAT = "chat"
    const val LANG = "lang"
    const val FLAG = "flag"
    const val PROMO = "promo"
    const val BOUNTY_ADD = "badd"
    const val GIVE_INFECTED_BOUNTY = "giveinfectedbounty"
    const val BOUNTY_ABANDON = "bountyabandon"
    const val BOUNTY_COMPLETE = "bountycomplete"
    const val BOUNTY_TASK_COMPLETE = "bountytaskcomplete"
    const val BOUNTY_CONDITION_COMPLETE = "bountycondcomplete"
    const val BOUNTY_KILL = "bountykill"
    const val SKILL_GIVEXP = "skillgivexp"
    const val SKILL_LEVEL = "skilllevel"

    val COMMAND_SAVES = setOf(
        STORE_CLEAR,
        STORE_BLOCK,
        SPAWN_ELITE,
        ELITE_CHANCE,
        ADD_BOUNTY,
        LEVEL,
        SERVER_TIME,
        ZOMBIE,
        TIME,
        STAT,
        GIVE_AMOUNT,
        GIVE,
        GIVE_RARE,
        GIVE_UNIQUE,
        COUNTER,
        DAILY_QUEST,
        CHAT,
        LANG,
        FLAG,
        PROMO,
        BOUNTY_ADD,
        GIVE_INFECTED_BOUNTY,
        BOUNTY_ABANDON,
        BOUNTY_COMPLETE,
        BOUNTY_TASK_COMPLETE,
        BOUNTY_CONDITION_COMPLETE,
        BOUNTY_KILL,
        SKILL_GIVEXP,
        SKILL_LEVEL,
    )
}

===== C:\Users\Sulivan\Desktop\Projects\DeadZone-Private-Server\src\main\kotlin\socket\messaging\NetworkMessage.kt =====
package dev.deadzone.socket.messaging

/**
 * Network message constants used by the game.
 */
@Suppress("Unused", "SpellCheckingInspection")
object NetworkMessage {
    const val JOIN = "join"
    const val JOIN_RESULT = "playerio.joinresult"

    const val INIT_COMPLETE = "ic"
    const val ERROR = "err"
    const val BANNED = "ban"
    const val SEND_RESPONSE = "r"
    const val SERVER_SHUTDOWN_UPDATE = "ssu"
    const val SERVER_SHUTDOWN_MAINTENANCE = "ssm"
    const val SERVER_ROOM_DISABLED = "srd"
    const val SERVER_SETTINGS = "ssup"
    const val SERVER_NEW_VERSION = "snv"
    const val GAME_READY = "gr"
    const val GAME_LOADING_PROGRESS = "gp"
    const val SERVER_INIT_PROGRESS = "sip"
    const val SIGN_IN_FAILED = "sf"
    const val SCENE_READY = "sr"
    const val SCENE_REQUEST = "srq"
    const val SERVER_UPDATE = "su"
    const val TIME_UPDATE = "tu"
    const val OUT_OF_SYNC = "os"
    const val PURCHASE_COIN = "p"
    const val SAVE = "s"
    const val SAVE_SUCCCESS = "ss"
    const val MISSION_LOOT = "ml"
    const val RESOURCE_UPDATE = "ru"
    const val SURVIVOR_NEW = "sn"
    const val PLAYER_VIEW_REQUEST = "pvr"
    const val PLAYER_ATTACK_REQUEST = "par"
    const val PLAYER_ATTACK_RESPONSE = "parp"
    const val HELP_PLAYER = "hp"
    const val NEW_NOTIFICATIONS = "nn"
    const val UNDER_ATTACK = "ua"
    const val ZOMBIE_ATTACK = "za"
    const val GET_PLAYER_SURVIVOR = "ps"
    const val GET_NEIGHBOR_STATES = "ns"
    const val REQUEST_ZOMBIE_ATTACK = "rza"
    const val REQUEST_SURVIVOR_CHECK = "rsc"
    const val TASK_COMPLETE = "tc"
    const val BUILDING_COMPLETE = "bc"
    const val BUILDING_REPAIR_COMPLETE = "brpc"
    const val MISSION_RETURN_COMPLETE = "mrc"
    const val MISSION_LOCK_COMPLETE = "mlc"
    const val SURVIVOR_INJURY_COMPLETE = "sic"
    const val BATCH_RECYCLE_COMPLETE = "brc"
    const val QUEST_PROGRESS = "qp"
    const val QUEST_DAILY_FAILED = "qdf"
    const val QUEST_ARMOR_GAMES_COMPLETE = "agq"
    const val SURVIVOR_REASSIGNMENT_COMPLETE = "src"
    const val EFFECT_COMPLETE = "ec"
    const val EFFECT_LOCKOUT_COMPLETE = "elc"
    const val COOLDOWN_COMPLETE = "cc"
    const val FLAG_CHANGED = "fc"
    const val UPGRADE_FLAG_CHANGED = "ufc"
    const val MISSION_EVENT = "me"
    const val PVP_LIST_UPDATE = "pvplist"
    const val SCAV_STARTED = "sc =strt"
    const val SCAV_ENDED = "scvend"
    const val FUEL_UPDATE = "fuel"
    const val TRADE_DISABLED = "td"
    const val LINKED_ALLIANCES = "alink"
    const val RESEARCH_COMPLETE = "rscmp"
    const val GLOBAL_QUEST_CONTRIBUTE = "gqcon"
    const val GLOBAL_QUEST_PROGRESS = "gqpr"
    const val BOUNTY_COMPLETE = "bcmp"
    const val BOUNTY_TASK_COMPLETE = "btcmp"
    const val BOUNTY_TASK_CONDITION_COMPLETE = "btccmp"
    const val BOUNTY_UPDATE = "bup"
    const val RPC = "rpc"
    const val RPC_RESPONSE = "rpcr"
}

===== C:\Users\Sulivan\Desktop\Projects\DeadZone-Private-Server\src\main\kotlin\socket\messaging\SaveDataMethod.kt =====
package dev.deadzone.socket.messaging

/**
 * Save data method constants used by the game.
 */
@Suppress("Unused", "SpellCheckingInspection")
object SaveDataMethod {
    const val BUILDING_CREATE = "bld_create"
    const val BUILDING_CREATE_BUY = "bld_create_buy"
    const val BUILDING_UPGRADE = "bld_upgrade"
    const val BUILDING_UPGRADE_BUY = "bld_upgrade_buy"
    const val BUILDING_MOVE = "bld_move"
    const val BUILDING_RECYCLE = "bld_recycle"
    const val BUILDING_COLLECT = "bld_collect"
    const val BUILDING_CANCEL = "bld_cancel"
    const val BUILDING_SPEED_UP = "bld_speedup"
    const val BUILDING_REPAIR = "bld_repair"
    const val BUILDING_REPAIR_BUY = "bld_repair_buy"
    const val BUILDING_REPAIR_SPEED_UP = "bld_repair_speedup"
    const val BUILDING_TRAP_EXPLODE = "bld_trap_exp"

    val COMPOUND_BUILDING_SAVES = setOf(
        BUILDING_CREATE,
        BUILDING_CREATE_BUY,
        BUILDING_UPGRADE,
        BUILDING_UPGRADE_BUY,
        BUILDING_MOVE,
        BUILDING_RECYCLE,
        BUILDING_COLLECT,
        BUILDING_CANCEL,
        BUILDING_SPEED_UP,
        BUILDING_REPAIR,
        BUILDING_REPAIR_BUY,
        BUILDING_REPAIR_SPEED_UP,
        BUILDING_TRAP_EXPLODE,
    )

    const val TASK_STARTED = "tsk_start"
    const val TASK_CANCELLED = "tsk_cancelled"
    const val TASK_SURVIVOR_ASSIGNED = "tsk_srv_assign"
    const val TASK_SURVIVOR_REMOVED = "tsk_srv_remove"
    const val TASK_SPEED_UP = "tsk_speedup"

    val COMPOUND_TASK_SAVES = setOf(
        TASK_STARTED,
        TASK_CANCELLED,
        TASK_SURVIVOR_ASSIGNED,
        TASK_SURVIVOR_REMOVED,
        TASK_SPEED_UP,
    )

    const val CRAFT_ITEM = "craft_item"
    const val CRAFT_UPGRADE = "craft_upgrade"
    const val CRAFT_SCHEMATIC = "craft_schematic"
    const val EFFECT_SET = "effect_set"
    const val RESEARCH_START = "rsstrt"
    const val AH_EVENT = "ahEvent"
    const val CULL_NEIGHBORS = "cullneighbors"
    const val RALLY_ASSIGNMENT = "rally_assign"

    val COMPOUND_MISC_SAVES = setOf(
        CRAFT_ITEM,
        CRAFT_UPGRADE,
        CRAFT_SCHEMATIC,
        EFFECT_SET,
        RESEARCH_START,
        AH_EVENT,
        CULL_NEIGHBORS,
        RALLY_ASSIGNMENT
    )

    const val ITEM = "itm"
    const val ITEM_BUY = "itm_buy"
    const val ITEM_LIST = "itm_list"
    const val ITEM_RECYCLE = "itm_recycle"
    const val ITEM_DISPOSE = "itm_dispose"
    const val ITEM_CLEAR_NEW = "itm_clear_new"
    const val ITEM_BATCH_RECYCLE = "itm_batch_recycle"
    const val ITEM_BATCH_RECYCLE_SPEED_UP = "itm_batch_recycle_speedup"
    const val ITEM_BATCH_DISPOSE = "itm_batch_dispose"

    val ITEM_SAVES = setOf(
        ITEM,
        ITEM_BUY,
        ITEM_LIST,
        ITEM_RECYCLE,
        ITEM_DISPOSE,
        ITEM_CLEAR_NEW,
        ITEM_BATCH_RECYCLE,
        ITEM_BATCH_RECYCLE_SPEED_UP,
        ITEM_BATCH_DISPOSE,
    )

    const val MISSION_START = "mis_start"
    const val MISSION_END = "mis_end"
    const val MISSION_INJURY = "mis_inj"
    const val MISSION_SPEED_UP = "mis_speedup"
    const val MISSION_ZOMBIES = "mis_zombies"
    const val MISSION_START_FLAG = "mis_startFlag"
    const val MISSION_INTERACTION_FLAG = "mis_interacted"
    const val MISSION_SCOUTED = "mis_scouted"
    const val MISSION_ITEM_USE = "mis_use"
    const val MISSION_TRIGGER = "mis_trig"
    const val MISSION_ELITE_SPAWNED = "mis_elsp"
    const val MISSION_ELITE_KILLED = "mis_elkl"

    val MISSION_SAVES = setOf(
        MISSION_START,
        MISSION_END,
        MISSION_INJURY,
        MISSION_SPEED_UP,
        MISSION_ZOMBIES,
        MISSION_START_FLAG,
        MISSION_INTERACTION_FLAG,
        MISSION_SCOUTED,
        MISSION_ITEM_USE,
        MISSION_TRIGGER,
        MISSION_ELITE_SPAWNED,
        MISSION_ELITE_KILLED,
        STAT_DATA,
        STAT
    )

    const val SURVIVOR_CLASS = "srv_class"
    const val SURVIVOR_OFFENCE_LOADOUT = "srv_oLoadout"
    const val SURVIVOR_DEFENCE_LOADOUT = "srv_dLoadout"
    const val SURVIVOR_CLOTHING_LOADOUT = "srv_cLoadout"
    const val SURVIVOR_INJURY_SPEED_UP = "srv_injury_speedup"
    const val SURVIVOR_RENAME = "srv_rename"
    const val SURVIVOR_REASSIGN = "srv_reassign"
    const val SURVIVOR_REASSIGN_SPEED_UP = "srv_reassign_speedup"
    const val SURVIVOR_BUY = "srv_buy"
    const val SURVIVOR_INJURE = "srv_inj"
    const val SURVIVOR_ENEMY_INJURE = "srv_einj"
    const val SURVIVOR_HEAL_INJURY = "srv_heal"
    const val SURVIVOR_HEAL_ALL = "srv_healall"
    const val PLAYER_CUSTOM = "ply_custom"
    const val SURVIVOR_EDIT = "srv_edit"
    const val NAMES = "names"
    const val RESET_LEADER = "resetLeader"

    val SURVIVOR_SAVES = setOf(
        SURVIVOR_CLASS,
        SURVIVOR_OFFENCE_LOADOUT,
        SURVIVOR_DEFENCE_LOADOUT,
        SURVIVOR_CLOTHING_LOADOUT,
        SURVIVOR_INJURY_SPEED_UP,
        SURVIVOR_RENAME,
        SURVIVOR_REASSIGN,
        SURVIVOR_REASSIGN_SPEED_UP,
        SURVIVOR_BUY,
        SURVIVOR_INJURE,
        SURVIVOR_ENEMY_INJURE,
        SURVIVOR_HEAL_INJURY,
        SURVIVOR_HEAL_ALL,
        PLAYER_CUSTOM,
        SURVIVOR_EDIT,
        NAMES,
        RESET_LEADER,
    )

    const val RAID_START = "raid_start"
    const val RAID_CONTINUE = "raid_cont"
    const val RAID_ABORT = "raid_abort"
    const val RAID_DEATH = "raid_death"

    val RAID_SAVES = setOf(
        RAID_START,
        RAID_CONTINUE,
        RAID_ABORT,
        RAID_DEATH,
    )

    const val ARENA_START = "arena_start"
    const val ARENA_CONTINUE = "arena_cont"
    const val ARENA_FINISH = "arena_fin"
    const val ARENA_ABORT = "arena_abort"
    const val ARENA_DEATH = "arena_death"
    const val ARENA_UPDATE = "arena_update"
    const val ARENA_LEADER = "arena_ldr"
    const val ARENA_LEADERBOARD = "arena_lb"

    val ARENA_SAVES = setOf(
        ARENA_START,
        ARENA_CONTINUE,
        ARENA_FINISH,
        ARENA_ABORT,
        ARENA_DEATH,
        ARENA_UPDATE,
        ARENA_LEADER,
        ARENA_LEADERBOARD,
    )

    const val QUEST_COLLECT = "quest_collect"
    const val QUEST_TRACK = "quest_track"
    const val QUEST_UNTRACK = "quest_untrack"
    const val QUEST_DAILY_DECLINE = "quest_daily_dec"
    const val QUEST_DAILY_ACCEPT = "quest_daily_acc"
    const val REPEAT_ACHIEVEMENT = "rep_ach"
    const val GLOBAL_QUEST_COLLECT = "gQuest_collect"

    val QUEST_SAVES = setOf(
        QUEST_COLLECT,
        QUEST_TRACK,
        QUEST_UNTRACK,
        QUEST_DAILY_DECLINE,
        QUEST_DAILY_ACCEPT,
        REPEAT_ACHIEVEMENT,
        GLOBAL_QUEST_COLLECT
    )

    const val CRATE_UNLOCK = "crate_unlock"
    const val CRATE_MYSTERY_UNLOCK = "crate_mystery_unlock"

    val CRATE_SAVES = setOf(
        CRATE_UNLOCK,
        CRATE_MYSTERY_UNLOCK
    )

    const val ALLIANCE_CREATE = "alliance_create"
    const val ALLIANCE_COLLECT_WINNINGS = "alliance_collectWinnings"
    const val ALLIANCE_QUERY_WINNINGS = "alliance_queryWinnings"
    const val ALLIANCE_GET_PREV_ROUND_RESULT = "alliance_getPrevRoundResults"
    const val ALLIANCE_EFFECT_UPDATE = "alliance_effects"
    const val ALLIANCE_INFORM_ABOUT_LEAVE = "alliance_informAboutLeave"
    const val ALLIANCE_GET_LIFETIMESTATS = "alliance_getLifeStats"

    val ALLIANCE_SAVES = setOf(
        ALLIANCE_CREATE,
        ALLIANCE_COLLECT_WINNINGS,
        ALLIANCE_QUERY_WINNINGS,
        ALLIANCE_GET_PREV_ROUND_RESULT,
        ALLIANCE_EFFECT_UPDATE,
        ALLIANCE_INFORM_ABOUT_LEAVE,
        ALLIANCE_GET_LIFETIMESTATS,
    )

    const val CHAT_SILENCED = "chat_silenced"
    const val CHAT_KICKED = "chat_kicked"
    const val CHAT_GET_CONTACTS_AND_BLOCKS = "chat_getContactsBlocks"
    const val CHAT_MIGRATE_CONTACTS_AND_BLOCKS = "chat_migrateContactsBlocks"
    const val CHAT_ADD_CONTACT = "chat_addContact"
    const val CHAT_REMOVE_CONTACT = "chat_removeContact"
    const val CHAT_REMOVE_ALL_CONTACTS = "chat_removeAllContacts"
    const val CHAT_ADD_BLOCK = "chat_addBlock"
    const val CHAT_REMOVE_BLOCK = "chat_removeBlock"
    const val CHAT_REMOVE_ALL_BLOCKS = "chat_removeAllBlocks"

    val CHAT_SAVES = setOf(
        CHAT_SILENCED,
        CHAT_KICKED,
        CHAT_GET_CONTACTS_AND_BLOCKS,
        CHAT_MIGRATE_CONTACTS_AND_BLOCKS,
        CHAT_ADD_CONTACT,
        CHAT_REMOVE_CONTACT,
        CHAT_REMOVE_ALL_CONTACTS,
        CHAT_ADD_BLOCK,
        CHAT_REMOVE_BLOCK,
        CHAT_REMOVE_ALL_BLOCKS,
    )

    const val BOUNTY_VIEW = "dzbountyview"
    const val BOUNTY_SPEED_UP = "dzbountyspeedup"
    const val BOUNTY_NEW = "dzbountynew"
    const val BOUNTY_ABANDON = "dzbountyabn"
    const val BOUNTY_ADD = "addBounty"

    val BOUNTY_SAVES = setOf(
        BOUNTY_VIEW,
        BOUNTY_SPEED_UP,
        BOUNTY_NEW,
        BOUNTY_ABANDON,
        BOUNTY_ADD,
    )

    const val RESOURCE_BUY = "res_buy"
    const val PROTECTION_BUY = "prot_buy"
    const val PAYVAULT_BUY = "payvault_buy"
    const val CLAIM_PROMO_CODE = "claim_promo"
    const val BUY_PACKAGE = "pack_buy"
    const val CHECK_APPLY_DIRECT_PURCHASE = "chk_dp"
    const val HAS_PAYVAULT_ITEM = "haspvitem"
    const val INCREMENT_PURCHASE_COUNT = "incPrchCnt"
    const val DEATH_MOBILE_RENAME = "dm_rename"

    val PURCHASE_SAVES = setOf(
        RESOURCE_BUY,
        PROTECTION_BUY,
        PAYVAULT_BUY,
        CLAIM_PROMO_CODE,
        BUY_PACKAGE,
        CHECK_APPLY_DIRECT_PURCHASE,
        HAS_PAYVAULT_ITEM,
        INCREMENT_PURCHASE_COUNT,
        DEATH_MOBILE_RENAME
    )

    const val STAT = "stat"
    const val GET_STATS = "stat_get"
    const val GLOBAL_STAT = "gstat"
    const val STAT_DATA = "stat_data"

    const val TUTORIAL_PVP_PRACTICE = "tut_pvppractice"
    const val TUTORIAL_COMPLETE = "tut_complete"
    const val GET_OFFERS = "get_offers"
    const val NEWS_READ = "news_read"
    const val CLEAR_NOTIFICATIONS = "clear_notes"
    const val FLUSH_PLAYER = "flushPlayer"
    const val SAVE_ALT_IDS = "savealts"
    const val TRADE_DO_TRADE = "trade_doTrade"
    const val GET_INVENTORY_SIZE = "get_invsize"

    val MISC_SAVES = setOf(
        TUTORIAL_PVP_PRACTICE,
        TUTORIAL_COMPLETE,
        GET_OFFERS,
        NEWS_READ,
        CLEAR_NOTIFICATIONS,
        FLUSH_PLAYER,
        SAVE_ALT_IDS,
        TRADE_DO_TRADE,
        GET_INVENTORY_SIZE
    )
}

===== C:\Users\Sulivan\Desktop\Projects\DeadZone-Private-Server\src\main\kotlin\socket\messaging\SocketMessage.kt =====
package dev.deadzone.socket.messaging

import dev.deadzone.utils.parseJsonToMap

/**
 * A higher-level representation of game message sent to the socket server.
 *
 * Message is always a flat list of even length (if odd then the first is the type).
 * Two of each element is paired as key-value pair.
 *
 * @constructor Raw deserialized data received from socket connection
 *
 */
class SocketMessage(private val raw: List<Any>) {
    val type: String? = if (raw.size % 2 == 1 && raw.size != 1) raw.firstOrNull() as? String else null

    private val map: Map<String, Any?> = buildMap {
        val start = if (type != null) 1 else 0
        val end = raw.size
        for (i in start until end step 2) {
            val key = raw.getOrNull(i) as? String ?: continue
            val value = raw.getOrNull(i + 1)
            put(key, value)
        }
    }

    fun isEmpty(): Boolean {
        return map.keys.isEmpty()
    }

    /**
     * Get a value (`any` type) from particular key.
     * Use [getString], [getInt], etc for typed result
     *
     * @param key
     * @return the value from the corresponding key in the message
     */
    fun get(key: String): Any? = map[key]

    fun contains(key: String): Boolean {
        return map.containsKey(key)
    }

    fun getString(key: String): String? = map[key] as? String
    fun getInt(key: String): Int? = (map[key] as? Number)?.toInt()
    fun getMap(key: String): Map<String, Any?>? {
        val rawValue = map[key] ?: return null
        return when (rawValue) {
            is Map<*, *> -> rawValue as? Map<String, Any?>
            is String -> {
                try {
                    parseJsonToMap(rawValue)
                } catch (_: Exception) {
                    null
                }
            }
            else -> null
        }
    }

    override fun toString(): String = if (type != null)
        "Message(type=$type, map=$map)"
    else
        "Message(map=$map)"

    companion object {
        fun fromRaw(raw: List<Any>): SocketMessage {
            return SocketMessage(raw)
        }
    }
}

===== C:\Users\Sulivan\Desktop\Projects\DeadZone-Private-Server\src\main\kotlin\socket\messaging\SocketMessageDispatcher.kt =====
package dev.deadzone.socket.messaging

import dev.deadzone.socket.handler.DefaultHandler
import dev.deadzone.utils.Logger

/**
 * Dispatch [SocketMessage] to a registered handler
 */
class SocketMessageDispatcher() {
    private val handlers = mutableListOf<SocketMessageHandler>()

    fun register(handler: SocketMessageHandler) {
        handlers.add(handler)
    }

    fun findHandlerFor(msg: SocketMessage): SocketMessageHandler {
        Logger.info { "Finding handler for type: ${msg.type} | message: $msg" }
        return (handlers.find { it.match(msg) } ?: DefaultHandler()).also {
            Logger.info {"Dispatching to $it" }
        }
    }

    fun shutdown() {
        handlers.clear()
    }
}

===== C:\Users\Sulivan\Desktop\Projects\DeadZone-Private-Server\src\main\kotlin\socket\messaging\SocketMessageHandler.kt =====
package dev.deadzone.socket.messaging

import dev.deadzone.socket.core.Connection

/**
 * A template for socket message handler
 *
 * See example
 * - [dev.deadzone.socket.handler.JoinHandler]
 * - [dev.deadzone.socket.handler.DefaultHandler]
 */
interface SocketMessageHandler {
    fun match(message: SocketMessage): Boolean
    suspend fun handle(connection: Connection, message: SocketMessage, send: suspend (ByteArray) -> Unit)
}

===== C:\Users\Sulivan\Desktop\Projects\DeadZone-Private-Server\src\main\kotlin\socket\protocol\Pattern.kt =====
package dev.deadzone.socket.protocol

internal enum class Pattern(val value: Int) {
    STRING_SHORT_PATTERN(0xC0),
    STRING_PATTERN(0x0C),
    BYTE_ARRAY_SHORT_PATTERN(0x40),
    BYTE_ARRAY_PATTERN(0x10),
    UNSIGNED_LONG_SHORT_PATTERN(0x38),
    UNSIGNED_LONG_PATTERN(0x3C),
    LONG_SHORT_PATTERN(0x30),
    LONG_PATTERN(0x34),
    UNSIGNED_INT_SHORT_PATTERN(0x80),
    UNSIGNED_INT_PATTERN(0x08),
    INT_PATTERN(0x04),
    DOUBLE_PATTERN(0x03),
    FLOAT_PATTERN(0x02),
    BOOLEAN_TRUE_PATTERN(0x01),
    BOOLEAN_FALSE_PATTERN(0x00),
    DOES_NOT_EXIST(0xFF);

    companion object {
        fun fromByte(byte: Int): Pattern {
            return entries.toTypedArray().sortedByDescending { it.value }.firstOrNull {
                byte and it.value == it.value
            } ?: DOES_NOT_EXIST
        }
    }
}

===== C:\Users\Sulivan\Desktop\Projects\DeadZone-Private-Server\src\main\kotlin\socket\protocol\PIODeserializer.kt =====
package dev.deadzone.socket.protocol

import dev.deadzone.utils.LogConfigSocketError
import dev.deadzone.utils.LogSource
import dev.deadzone.utils.Logger
import dev.deadzone.utils.parseJsonToMap
import java.io.ByteArrayOutputStream
import java.nio.ByteBuffer
import java.nio.ByteOrder

object PIODeserializer {
    fun deserialize(data: ByteArray): List<Any> {
        var state = "init"
        var pattern = Pattern.DOES_NOT_EXIST
        val buffer = ByteArrayOutputStream()
        var partLength = 0
        val length = -1
        val message = mutableListOf<Any>()

        fun onValue(value: Any?) {
            if (length == -1 && value is Int) {
            } else {
                message.add(value ?: "null")
            }
        }

        fun ByteArray.padStart(size: Int): ByteArray {
            return ByteArray(size - this.size) { 0 } + this
        }

        try {
            for (byte in data) {
                when (state) {
                    "init" -> {
                        pattern = Pattern.fromByte(byte.toInt() and 0xFF)
                        val part = byte.toInt() and 0x3F

                        when (pattern) {
                            Pattern.STRING_SHORT_PATTERN,
                            Pattern.BYTE_ARRAY_SHORT_PATTERN -> {
                                partLength = part
                                state = if (partLength > 0) "data" else {
                                    val value = if (pattern == Pattern.STRING_SHORT_PATTERN) "" else ByteArray(0)
                                    onValue(value)
                                    "init"
                                }
                            }

                            Pattern.STRING_PATTERN,
                            Pattern.BYTE_ARRAY_PATTERN,
                            Pattern.UNSIGNED_INT_PATTERN,
                            Pattern.INT_PATTERN -> {
                                partLength = 4
                                state = "header"
                            }

                            Pattern.UNSIGNED_INT_SHORT_PATTERN -> {
                                onValue(part)
                            }

                            Pattern.UNSIGNED_LONG_SHORT_PATTERN,
                            Pattern.LONG_SHORT_PATTERN -> {
                                partLength = 1
                                state = "data"
                            }

                            Pattern.UNSIGNED_LONG_PATTERN,
                            Pattern.LONG_PATTERN -> {
                                partLength = 6
                                state = "data"
                            }

                            Pattern.DOUBLE_PATTERN -> {
                                partLength = 8
                                state = "data"
                            }

                            Pattern.FLOAT_PATTERN -> {
                                partLength = 4
                                state = "data"
                            }

                            Pattern.BOOLEAN_TRUE_PATTERN -> onValue(true)
                            Pattern.BOOLEAN_FALSE_PATTERN -> onValue(false)
                            else -> {} // unsupported
                        }
                    }

                    "header" -> {
                        buffer.write(byte.toInt())
                        if (buffer.size() == partLength) {
                            val padded = buffer.toByteArray().padStart(4)
                            partLength = ByteBuffer.wrap(padded).order(ByteOrder.LITTLE_ENDIAN).int

                            if (partLength !in 0..10_000_000) {
                                throw IllegalArgumentException("Invalid partLength = $partLength")
                            }

                            buffer.reset()
                            state = "data"
                        }
                    }

                    "data" -> {
                        buffer.write(byte.toInt())
                        if (buffer.size() == partLength) {
                            val bytes = buffer.toByteArray()
                            val padded = { b: ByteArray, size: Int -> b.padStart(size) }

                            val value = try {
                                when (pattern) {
                                    Pattern.STRING_SHORT_PATTERN,
                                    Pattern.STRING_PATTERN -> bytes.toString(Charsets.UTF_8)

                                    Pattern.UNSIGNED_INT_PATTERN,
                                    Pattern.INT_PATTERN -> ByteBuffer.wrap(padded(bytes, 4))
                                        .order(ByteOrder.BIG_ENDIAN).int

                                    Pattern.UNSIGNED_LONG_PATTERN,
                                    Pattern.UNSIGNED_LONG_SHORT_PATTERN,
                                    Pattern.LONG_PATTERN,
                                    Pattern.LONG_SHORT_PATTERN -> ByteBuffer.wrap(padded(bytes, 8))
                                        .order(ByteOrder.BIG_ENDIAN).long

                                    Pattern.DOUBLE_PATTERN -> ByteBuffer.wrap(padded(bytes, 8))
                                        .order(ByteOrder.BIG_ENDIAN).double

                                    Pattern.FLOAT_PATTERN -> ByteBuffer.wrap(padded(bytes, 4))
                                        .order(ByteOrder.BIG_ENDIAN).float

                                    Pattern.BYTE_ARRAY_SHORT_PATTERN,
                                    Pattern.BYTE_ARRAY_PATTERN -> bytes

                                    else -> null
                                }
                            } catch (e: Exception) {
                                Logger.error(LogConfigSocketError) { "Error deserializing pattern $pattern: ${e.message}" }
                                null
                            }

                            onValue(value)
                            buffer.reset()
                            state = "init"
                        }
                    }
                }
            }

            return message
        } catch (_: Exception) {
            Logger.info(LogSource.SOCKET) { "Deserializer receives JSON-like message" }
        }

        val offset = data.indexOfFirst { it == '{'.code.toByte() }

        return if (offset != -1) {
            try {
                val jsonBytes = data.copyOfRange(offset, data.size)
                val json = jsonBytes.toString(Charsets.UTF_8)
                val parsed = parseJsonToMap(json)
                val type = message.firstOrNull() as? String

                if (type != null) {
                    val isAlreadyWrapped = parsed.size == 1 && parsed.containsKey(type)

                    val final = if (isAlreadyWrapped) {
                        listOf(type, parsed[type]!!)
                    } else {
                        listOf(type, parsed)
                    }
                    final
                } else {
                    Logger.error(LogConfigSocketError) { "Cannot determine message type from partial data" }
                    emptyList()
                }
            } catch (e: Exception) {
                Logger.error(LogConfigSocketError) { "JSON fallback deserialization failed: ${e.message}" }
                emptyList()
            }
        } else {
            emptyList()
        }
    }
}

===== C:\Users\Sulivan\Desktop\Projects\DeadZone-Private-Server\src\main\kotlin\socket\protocol\PIOSerializer.kt =====
package dev.deadzone.socket.protocol

import java.nio.ByteBuffer
import java.nio.ByteOrder

object PIOSerializer {
    fun serialize(message: List<Any>): ByteArray {
        val buffer = mutableListOf<Byte>()

        fun reverseBytes(bytes: ByteArray): ByteArray = bytes.reversedArray()

        fun writeTagWithLength(length: Int, shortPattern: Pattern, fullPattern: Pattern) {
            if (length in 0..63) {
                buffer.add((shortPattern.value or length).toByte())
            } else {
                val encoded = reverseBytes(ByteBuffer.allocate(4).order(ByteOrder.LITTLE_ENDIAN).putInt(length).array())
                val nonZero = encoded.indexOfFirst { it != 0.toByte() }.takeIf { it >= 0 } ?: 3
                val used = 4 - nonZero
                buffer.add((fullPattern.value or (used - 1)).toByte())
                buffer.addAll(encoded.drop(nonZero))
            }
        }

        fun writeLongPattern(value: Long, shortPattern: Pattern, longPattern: Pattern) {
            val encoded = reverseBytes(ByteBuffer.allocate(8).order(ByteOrder.LITTLE_ENDIAN).putLong(value).array())
            val nonZero = encoded.indexOfFirst { it != 0.toByte() }.takeIf { it >= 0 } ?: 7
            val used = 8 - nonZero
            val pattern = if (used > 4) longPattern else shortPattern
            val offset = if (used > 4) used - 5 else used - 1
            buffer.add((pattern.value or offset).toByte())
            buffer.addAll(encoded.drop(nonZero))
        }

        fun serializeValue(value: Any) {
            when (value) {
                is String -> {
                    val encoded = value.toByteArray(Charsets.UTF_8)
                    writeTagWithLength(encoded.size, Pattern.STRING_SHORT_PATTERN, Pattern.STRING_PATTERN)
                    buffer.addAll(encoded.toList())
                }

                is Boolean -> {
                    buffer.add(if (value) Pattern.BOOLEAN_TRUE_PATTERN.value.toByte() else Pattern.BOOLEAN_FALSE_PATTERN.value.toByte())
                }

                is Int -> {
                    writeTagWithLength(value, Pattern.UNSIGNED_INT_SHORT_PATTERN, Pattern.INT_PATTERN)
                }

                is Long -> {
                    writeLongPattern(value, Pattern.LONG_SHORT_PATTERN, Pattern.LONG_PATTERN)
                }

                is Float -> {
                    buffer.add(Pattern.DOUBLE_PATTERN.value.toByte())
                    buffer.addAll(
                        reverseBytes(
                            ByteBuffer.allocate(8).order(ByteOrder.LITTLE_ENDIAN).putDouble(value.toDouble()).array()
                        ).toList()
                    )
                }

                is Double -> {
                    buffer.add(Pattern.DOUBLE_PATTERN.value.toByte())
                    buffer.addAll(
                        reverseBytes(
                            ByteBuffer.allocate(8).order(ByteOrder.LITTLE_ENDIAN).putDouble(value).array()
                        ).toList()
                    )
                }

                is ByteArray -> {
                    writeTagWithLength(value.size, Pattern.BYTE_ARRAY_SHORT_PATTERN, Pattern.BYTE_ARRAY_PATTERN)
                    buffer.addAll(value.toList())
                }

                else -> throw IllegalArgumentException("Unsupported type: ${value::class}")
            }
        }

        serializeValue(message.size - 1)
        for (value in message) {
            serializeValue(value)
        }

        return buffer.toByteArray()
    }
}

===== C:\Users\Sulivan\Desktop\Projects\DeadZone-Private-Server\src\main\kotlin\socket\tasks\ServerTask.kt =====
package dev.deadzone.socket.tasks

import dev.deadzone.socket.core.Connection

/**
 * A template of task which can be run flexibly
 *
 * Implementations of this interface can push data to clients through client's [Connection]
 * if needed.
 *
 * We may need to implement sort of queue system for task that needs to be run.
 * During LoadObjects, we re-check the game timers. We don't want to send BUILDING_COMPLETE message
 * if the building completes while the game is in loading, hence the idea of making queued task.
 *
 * Open the queue and run all tasks when the game reached INIT_COMPLETE
 */
interface ServerTask {
    /**
     * Unique identifier for each task template
     */
    val key: TaskTemplate

    /**
     * Default config for the task.
     */
    val config: TaskConfig

    /**
     * A scheduler override from the default [ServerTaskDispatcher].
     */
    val scheduler: TaskScheduler?

    /**
     * Run the task. Task do not need to schedule its running as scheduling is done by [TaskScheduler]
     *
     * @param connection the player's socket connection to send message if needed.
     */
    suspend fun run(connection: Connection, finalConfig: TaskConfig)
}

===== C:\Users\Sulivan\Desktop\Projects\DeadZone-Private-Server\src\main\kotlin\socket\tasks\ServerTaskDispatcher.kt =====
package dev.deadzone.socket.tasks

import dev.deadzone.socket.core.Connection
import dev.deadzone.utils.LogConfigSocketError
import dev.deadzone.utils.LogSource
import dev.deadzone.utils.Logger
import kotlinx.coroutines.*
import java.util.UUID
import kotlin.collections.component1
import kotlin.coroutines.cancellation.CancellationException

/**
 * Manages and dispatches registered [ServerTask]s for each playerId or connection
 *
 * This is used to register tasks that the server runs independently, usually
 * to push messages to the connected clients (e.g., time update, real-time events).
 *
 * @property registeredTasks keep tracks registered tasks
 * @property defaultConfigs config for each task. The default config can be overridden from [runTask].
 * @property runningInstances list of globally unique running tasks
 */
class ServerTaskDispatcher : TaskScheduler {
    private val registeredTasks = mutableMapOf<TaskTemplate, ServerTask>()

    private val defaultConfigs = mutableMapOf<TaskTemplate, TaskConfig>()

    private val runningInstances = mutableMapOf<UUID, TaskInstance>()


    fun register(task: ServerTask) {
        registeredTasks[task.key] = task
        defaultConfigs[task.key] = task.config
    }

    /**
     * Run a task for the socket connection, returning the task ID (UUID).
     */
    fun runTask(
        connection: Connection,
        taskTemplateKey: TaskTemplate,
        cfgBuilder: (TaskConfig) -> TaskConfig?,
        onComplete: (() -> Unit)? = null
    ): UUID {
        val task = requireNotNull(registeredTasks[taskTemplateKey]) { "Task not registered: $taskTemplateKey" }
        val defaultCfg = requireNotNull(defaultConfigs[taskTemplateKey]) { "Missing default config for $taskTemplateKey" }
        val cfg = cfgBuilder(defaultCfg) ?: defaultCfg

        val taskId = UUID.randomUUID()

        val job = connection.scope.launch {
            try {
                Logger.debug(LogSource.SOCKET) { "Push task ${task.key} is going to run." }
                val scheduler = task.scheduler ?: this@ServerTaskDispatcher
                scheduler.schedule(task, connection, cfg)
            } catch (_: CancellationException) {
                Logger.debug(LogSource.SOCKET) { "Push task '${task.key}' was cancelled." }
            } catch (e: Exception) {
                Logger.error(LogConfigSocketError) { "Error running push task '${task.key}': $e" }
            } finally {
                Logger.debug(LogSource.SOCKET) { "Push task ${task.key} has finished running." }
                runningInstances.remove(taskId)
                onComplete?.invoke()
            }
        }

        runningInstances[taskId] = TaskInstance(connection.playerId, taskTemplateKey, cfg, job, onComplete)
        return taskId
    }

    fun stopTask(taskId: UUID) {
        runningInstances.remove(taskId)?.job?.cancel()
    }

    fun stopAllTasksForPlayer(playerId: String) {
        runningInstances
            .filterValues { it.playerId == playerId }
            .forEach { (taskId, _) -> stopTask(taskId) }
    }

    override suspend fun schedule(
        task: ServerTask,
        connection: Connection,
        cfg: TaskConfig
    ) {
        delay(cfg.initialRunDelay)

        val shouldRunInfinitely = cfg.repeatDelay != null
        if (shouldRunInfinitely) {
            while (currentCoroutineContext().isActive) {
                delay(cfg.repeatDelay)
                task.run(connection, cfg)
            }
        } else {
            task.run(connection, cfg)
        }
    }

    fun stopAllPushTasks() {
        runningInstances.forEach { (taskId, _) -> stopTask(taskId) }
    }

    fun shutdown() {
        registeredTasks.clear()
        defaultConfigs.clear()
        stopAllPushTasks()
    }
}

/**
 * An instance of task.
 *
 * @property playerId the player the task belongs to.
 * @property taskKey the [ServerTask] identifier.
 * @property config the configuration of the task.
 * @property job coroutine reference for the task.
 * @property onComplete callback after task has finished running.
 */
data class TaskInstance(
    val playerId: String,
    val taskKey: TaskTemplate,
    val config: TaskConfig,
    val job: Job,
    val onComplete: (() -> Unit)?
)

===== C:\Users\Sulivan\Desktop\Projects\DeadZone-Private-Server\src\main\kotlin\socket\tasks\TaskConfig.kt =====
package dev.deadzone.socket.tasks

import kotlin.time.Duration

/**
 * The configuration for a particular task.
 */
data class TaskConfig(
    /**
     * The identifier for the task within the template, usually NetworkMessage.
     */
    val targetTask: String,

    /**
     * The time delay before running the task on the first time after its ready.
     * If null task will be run immediately after its ready.
     */
    val initialRunDelay: Duration,

    /**
     * The time delay if the task is repeatable. If null then task only run once.
     */
    val repeatDelay: Duration? = null,

    /**
     * Extra data for task if needed. Usually used when want to send list of PIO message.
     */
    val extra: Map<String, Any>,
)

===== C:\Users\Sulivan\Desktop\Projects\DeadZone-Private-Server\src\main\kotlin\socket\tasks\TaskScheduler.kt =====
package dev.deadzone.socket.tasks

import dev.deadzone.socket.core.Connection

/**
 * Entity that can schedule task.
 *
 * By default, the scheduling of task is done by scheduler default implementation of [ServerTaskDispatcher].
 * However, if task scheduling is complex, the particular [ServerTask] can override the implementation.
 */
interface TaskScheduler {
    suspend fun schedule(task: ServerTask, connection: Connection, cfg: TaskConfig)
}

===== C:\Users\Sulivan\Desktop\Projects\DeadZone-Private-Server\src\main\kotlin\socket\tasks\TaskTemplate.kt =====
package dev.deadzone.socket.tasks

enum class TaskTemplate {
    TIME_UPDATE, BUILDING
}

===== C:\Users\Sulivan\Desktop\Projects\DeadZone-Private-Server\src\main\kotlin\socket\tasks\impl\BuildingTask.kt =====
package dev.deadzone.socket.tasks.impl

import dev.deadzone.socket.core.Connection
import dev.deadzone.socket.messaging.NetworkMessage
import dev.deadzone.socket.tasks.ServerTask
import dev.deadzone.socket.tasks.TaskConfig
import dev.deadzone.socket.tasks.TaskTemplate
import dev.deadzone.socket.tasks.TaskScheduler
import kotlin.time.Duration.Companion.seconds

class BuildingTask() : ServerTask {
    override val key: TaskTemplate
        get() = TaskTemplate.BUILDING

    override val config: TaskConfig
        get() = TaskConfig(
            targetTask = NetworkMessage.BUILDING_COMPLETE,
            initialRunDelay = 0.seconds,
            repeatDelay = null,
            extra = emptyMap(),
        )

    override val scheduler: TaskScheduler?
        get() = null

    override suspend fun run(connection: Connection, finalConfig: TaskConfig) {
        val customMessage = finalConfig.extra["msg"] as? List<*> ?: emptyList<Any?>()
        val nonnull = customMessage.filterNotNull().toTypedArray()
        connection.sendMessage(finalConfig.targetTask, *nonnull)
    }
}

===== C:\Users\Sulivan\Desktop\Projects\DeadZone-Private-Server\src\main\kotlin\socket\tasks\impl\TimeUpdateTask.kt =====
package dev.deadzone.socket.tasks.impl

import dev.deadzone.socket.core.Connection
import dev.deadzone.socket.messaging.NetworkMessage
import dev.deadzone.socket.tasks.ServerTask
import dev.deadzone.socket.tasks.TaskConfig
import dev.deadzone.socket.tasks.TaskTemplate
import dev.deadzone.socket.tasks.TaskScheduler
import dev.deadzone.utils.Time
import kotlin.time.Duration.Companion.milliseconds
import kotlin.time.Duration.Companion.seconds

/**
 * Sends a time update ('tu') message to client.
 *
 * The game registers callback for such message, though not sure how frequent should we send the message.
 */
class TimeUpdateTask() : ServerTask {
    override val key: TaskTemplate
        get() = TaskTemplate.TIME_UPDATE

    override val config: TaskConfig
        get() = TaskConfig(
            targetTask = NetworkMessage.TIME_UPDATE,
            initialRunDelay = 1.seconds,
            repeatDelay = 1000.milliseconds,
            extra = emptyMap(),
        )

    override val scheduler: TaskScheduler?
        get() = null

    override suspend fun run(connection: Connection, finalConfig: TaskConfig) {
        connection.sendMessage(finalConfig.targetTask, Time.now())
    }
}

===== C:\Users\Sulivan\Desktop\Projects\DeadZone-Private-Server\src\main\kotlin\user\PlayerAccountRepository.kt =====
package dev.deadzone.user

import dev.deadzone.user.model.UserProfile
import dev.deadzone.data.collection.PlayerAccount

/**
 * Player account repository, analogous to game service's repo
 */
interface PlayerAccountRepository {
    suspend fun doesUserExist(username: String): Result<Boolean>

    suspend fun getUserDocByUsername(username: String): Result<PlayerAccount?>

    suspend fun getUserDocByPlayerId(playerId: String): Result<PlayerAccount?>

    suspend fun getPlayerIdOfUsername(username: String): Result<String?>

    suspend fun getProfileOfPlayerId(playerId: String): Result<UserProfile?>

    suspend fun updatePlayerAccount(playerId: String, account: PlayerAccount): Result<Unit>

    suspend fun updateLastLogin(playerId: String, lastLogin: Long): Result<Unit>

    /**
     * Verify credentials of the given username and password
     *
     * @return playerId for the corresponding username if success
     */
    suspend fun verifyCredentials(username: String, password: String): Result<String?>
}

===== C:\Users\Sulivan\Desktop\Projects\DeadZone-Private-Server\src\main\kotlin\user\PlayerAccountRepositoryMaria.kt =====
package dev.deadzone.user

import com.toxicbakery.bcrypt.Bcrypt
import dev.deadzone.data.collection.PlayerAccount
import dev.deadzone.data.db.PlayerAccounts
import dev.deadzone.user.model.UserProfile
import dev.deadzone.utils.Logger
import kotlinx.serialization.json.Json
import org.jetbrains.exposed.sql.Database
import org.jetbrains.exposed.sql.selectAll
import org.jetbrains.exposed.sql.transactions.transaction
import org.jetbrains.exposed.sql.update
import kotlin.io.encoding.Base64

class PlayerAccountRepositoryMaria(private val database: Database?) : PlayerAccountRepository {
    private val json = Json {
        ignoreUnknownKeys = true
        encodeDefaults = true
    }

    override suspend fun verifyCredentials(username: String, password: String): Result<String?> {
        return try {
            transaction(database) {
                val row = PlayerAccounts.selectAll()
                    .where { PlayerAccounts.profileJson like "%\"displayName\":\"$username\"%" }
                    .singleOrNull()
                if (row == null) {
                    Logger.info { "No account found for username=$username" }
                    return@transaction null
                }
                val hashedPassword = row[PlayerAccounts.hashedPassword]
                val decodedHash = Base64.decode(hashedPassword)
                if (Bcrypt.verify(password, decodedHash)) {
                    row[PlayerAccounts.playerId]
                } else {
                    Logger.info { "Password verification failed for username=$username" }
                    null
                }
            }.let { Result.success(it) }
        } catch (e: Exception) {
            Logger.error { "Failed to verify credentials for username=$username: ${e.message}" }
            Result.failure(e)
        }
    }

    override suspend fun doesUserExist(username: String): Result<Boolean> {
        return try {
            transaction(database) {
                PlayerAccounts.selectAll()
                    .where { PlayerAccounts.profileJson like "%\"displayName\":\"$username\"%" }
                    .count() > 0
            }.let { Result.success(it) }
        } catch (e: Exception) {
            Logger.error { "Failed to check if user exists for username=$username: ${e.message}" }
            Result.failure(e)
        }
    }

    override suspend fun getProfileOfPlayerId(playerId: String): Result<UserProfile?> {
        return try {
            transaction(database) {
                PlayerAccounts.selectAll()
                    .where { PlayerAccounts.playerId eq playerId }
                    .singleOrNull()?.let { row ->
                        val profileJson = row[PlayerAccounts.profileJson]
                        if (profileJson.isNotEmpty()) {
                            json.decodeFromString<UserProfile>(profileJson)
                        } else {
                            Logger.warn { "Profile JSON is empty for playerId=$playerId" }
                            null
                        }
                    } ?: run {
                    Logger.info { "No profile found for playerId=$playerId" }
                    null
                }
            }.let { profile ->
                if (profile == null) {
                    Logger.warn { "getProfileOfPlayerId returned null for playerId=$playerId" }
                    Result.failure(Exception("Profile not found for playerId=$playerId"))
                } else {
                    Result.success(profile)
                }
            }
        } catch (e: Exception) {
            Logger.error { "Failed to get profile for playerId=$playerId: ${e.message}" }
            Result.failure(e)
        }
    }

    override suspend fun getUserDocByUsername(username: String): Result<PlayerAccount?> {
        return try {
            transaction(database) {
                PlayerAccounts.selectAll()
                    .where { PlayerAccounts.profileJson like "%\"displayName\":\"$username\"%" }
                    .singleOrNull()?.let { row ->
                        PlayerAccount(
                            playerId = row[PlayerAccounts.playerId],
                            hashedPassword = row[PlayerAccounts.hashedPassword],
                            profile = json.decodeFromString(row[PlayerAccounts.profileJson]),
                            serverMetadata = json.decodeFromString(row[PlayerAccounts.serverMetadataJson])
                        )
                    }
            }.let { Result.success(it) }
        } catch (e: Exception) {
            Logger.error { "Failed to get user doc for username=$username: ${e.message}" }
            Result.failure(e)
        }
    }

    override suspend fun getUserDocByPlayerId(playerId: String): Result<PlayerAccount?> {
        return try {
            transaction(database) {
                PlayerAccounts.selectAll()
                    .where { PlayerAccounts.playerId eq playerId }
                    .singleOrNull()?.let { row ->
                        PlayerAccount(
                            playerId = row[PlayerAccounts.playerId],
                            hashedPassword = row[PlayerAccounts.hashedPassword],
                            profile = json.decodeFromString(row[PlayerAccounts.profileJson]),
                            serverMetadata = json.decodeFromString(row[PlayerAccounts.serverMetadataJson])
                        )
                    }
            }.let { Result.success(it) }
        } catch (e: Exception) {
            Logger.error { "Failed to get user doc for playerId=$playerId: ${e.message}" }
            Result.failure(e)
        }
    }

    override suspend fun getPlayerIdOfUsername(username: String): Result<String?> {
        return try {
            transaction(database) {
                PlayerAccounts.selectAll()
                    .where { PlayerAccounts.profileJson like "%\"displayName\":\"$username\"%" }
                    .singleOrNull()?.let { row ->
                        row[PlayerAccounts.playerId]
                    }
            }.let { Result.success(it) }
        } catch (e: Exception) {
            Logger.error { "Failed to get playerId for username=$username: ${e.message}" }
            Result.failure(e)
        }
    }

    override suspend fun updatePlayerAccount(playerId: String, account: PlayerAccount): Result<Unit> {
        return try {
            transaction(database) {
                val rowsUpdated = PlayerAccounts.update({ PlayerAccounts.playerId eq playerId }) {
                    it[hashedPassword] = account.hashedPassword
                    it[profileJson] = json.encodeToString(account.profile)
                    it[serverMetadataJson] = json.encodeToString(account.serverMetadata)
                }
                if (rowsUpdated == 0) {
                    Logger.warn { "No account found to update for playerId=$playerId" }
                    Result.failure(Exception("No account found for playerId=$playerId"))
                } else {
                    Result.success(Unit)
                }
            }
        } catch (e: Exception) {
            Logger.error { "Failed to update account for playerId=$playerId: ${e.message}" }
            Result.failure(e)
        }
    }

    override suspend fun updateLastLogin(playerId: String, lastLogin: Long): Result<Unit> {
        return try {
            transaction(database) {
                val row = PlayerAccounts.selectAll()
                    .where { PlayerAccounts.playerId eq playerId }
                    .singleOrNull()
                if (row == null) {
                    Logger.warn { "No account found to update last login for playerId=$playerId" }
                    return@transaction Result.failure(Exception("No account found for playerId=$playerId"))
                }
                val profile = json.decodeFromString<UserProfile>(row[PlayerAccounts.profileJson])
                val updatedProfile = profile.copy(lastLogin = lastLogin)
                val rowsUpdated = PlayerAccounts.update({ PlayerAccounts.playerId eq playerId }) {
                    it[profileJson] = json.encodeToString(updatedProfile)
                }
                if (rowsUpdated == 0) {
                    Logger.warn { "Failed to update last login for playerId=$playerId" }
                    Result.failure(Exception("Failed to update last login for playerId=$playerId"))
                } else {
                    Result.success(Unit)
                }
            }
        } catch (e: Exception) {
            Logger.error { "Failed to update last login for playerId=$playerId: ${e.message}" }
            Result.failure(e)
        }
    }
}

===== C:\Users\Sulivan\Desktop\Projects\DeadZone-Private-Server\src\main\kotlin\user\auth\AuthProvider.kt =====
package dev.deadzone.core.auth

import dev.deadzone.user.model.PlayerSession

/**
 * Represent system that provides authentication mechanism
 */
interface AuthProvider {
    /**
     * Register a new account with [username] and [password].
     *
     * @return [PlayerSession] of the newly created account for further authentication.
     */
    suspend fun register(username: String, password: String): PlayerSession

    /**
     * Login with [username] and [password].
     *
     * @return [PlayerSession] which is used for further authentication, null if login is failed.
     */
    suspend fun login(username: String, password: String): PlayerSession?

    /**
     * Login with admin account, will always succeed.
     */
    suspend fun adminLogin(): PlayerSession?

    /**
     * Check whether a user with [username] exists.
     */
    suspend fun doesUserExist(username: String): Boolean
}

===== C:\Users\Sulivan\Desktop\Projects\DeadZone-Private-Server\src\main\kotlin\user\auth\SessionManager.kt =====
package dev.deadzone.core.auth

import dev.deadzone.user.model.PlayerSession
import dev.deadzone.core.data.AdminData
import dev.deadzone.utils.UUID
import io.ktor.util.date.getTimeMillis
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.Job
import kotlinx.coroutines.delay
import kotlinx.coroutines.isActive
import kotlinx.coroutines.launch
import java.util.concurrent.ConcurrentHashMap

/**
 * Manages authentication sessions between web login and game client.
 *
 * - After a successful website login, this class issues a session token for the player.
 * - The client uses this token for API requests.
 * - On API requests, this class verifies if the token is valid and unexpired.
 * - Token will be refreshed upon successful verification.
 * - The client website makes API requests every 50 minutes to refresh the token.
 * This ensures that the token remains valid, even when the game is not actively making API requests.
 * - Session refreshes is limited to 6 hours. This means player will not be able to make API requests after 6 hours online.
 */
class SessionManager {
    private val sessions = ConcurrentHashMap<String, PlayerSession>() // token -> session
    private val CLEANUP_INTERVAL_MS = 5 * 60 * 1000L // 5 minutes
    private val cleanupJob = Job()
    private val SESSION_DURATION_MS = 1 * 60 * 60 * 1000L // 2 hours
    private val SESSION_LIFETIME_MS = 6 * 60 * 60 * 1000L // 6 hours
    private val scope = CoroutineScope(Dispatchers.IO + cleanupJob)

    init {
        scope.launch {
            while (isActive) {
                cleanupExpiredSessions()
                delay(CLEANUP_INTERVAL_MS)
            }
        }
    }

    fun create(playerId: String): PlayerSession {
        val now = getTimeMillis()

        val token = if (playerId == AdminData.PLAYER_ID) {
            AdminData.TOKEN
        } else {
            UUID.new()
        }

        val session = PlayerSession(
            playerId = playerId,
            token = token,
            issuedAt = now,
            expiresAt = now + SESSION_DURATION_MS,
            lifetime = SESSION_LIFETIME_MS
        )

        sessions[token] = session
        return session
    }

    fun verify(token: String): Boolean {
        val session = sessions[token] ?: return false
        val now = getTimeMillis()

        if (now >= session.expiresAt) {
            sessions.remove(token)
            return false
        }

        return true
    }

    fun refresh(token: String): Boolean {
        val session = sessions[token] ?: return false
        val now = getTimeMillis()

        val lifetime = now - session.issuedAt
        if (lifetime > SESSION_LIFETIME_MS) {
            sessions.remove(token)
            return false
        }

        session.expiresAt = now + 1 * 60 * 60 * 1000 // refresh to 1 hour
        return true
    }

    fun getPlayerId(token: String): String? {
        return sessions[token]?.takeIf { getTimeMillis() < it.expiresAt }?.playerId
    }

    fun getSession(token: String): PlayerSession? {
        val session = sessions[token] ?: return null
        val now = getTimeMillis()

        return if (now >= session.expiresAt) {
            sessions.remove(token)
            null
        } else {
            session
        }
    }

    fun invalidate(playerId: String) {
        sessions.remove(playerId)
    }

    fun cleanupExpiredSessions() {
        val now = getTimeMillis()
        val expiredKeys = sessions.filterValues { it.expiresAt <= now }.keys
        expiredKeys.forEach { sessions.remove(it) }
    }

    /**
     * Shutdown [cleanupExpiredSessions] task and clear sessions.
     */
    fun shutdown() {
        sessions.clear()
        cleanupJob.cancel()
    }
}

===== C:\Users\Sulivan\Desktop\Projects\DeadZone-Private-Server\src\main\kotlin\user\auth\WebsiteAuthProvider.kt =====
package dev.deadzone.user.auth

import dev.deadzone.core.auth.AuthProvider
import dev.deadzone.core.auth.SessionManager
import dev.deadzone.user.model.PlayerSession
import dev.deadzone.core.data.AdminData
import dev.deadzone.data.db.BigDB
import dev.deadzone.user.PlayerAccountRepository
import dev.deadzone.utils.LogConfigAPIError
import dev.deadzone.utils.Logger

class WebsiteAuthProvider(
    private val db: BigDB,
    private val playerAccountRepository: PlayerAccountRepository,
    private val sessionManager: SessionManager
) : AuthProvider {
    override suspend fun register(username: String, password: String): PlayerSession {
        val pid = db.createUser(username, password)
        return sessionManager.create(playerId = pid)
    }

    override suspend fun login(username: String, password: String): PlayerSession? {
        val result = playerAccountRepository.verifyCredentials(username, password)
        result.onFailure {
            Logger.error(LogConfigAPIError) { "Failure on verifyCredentials for username=$username: ${it.message}" }
            return null
        }
        val pid = result.getOrThrow()
        return if (pid != null) {
            sessionManager.create(pid)
        } else {
            null
        }
    }

    override suspend fun adminLogin(): PlayerSession {
        return sessionManager.create(AdminData.PLAYER_ID)
    }

    override suspend fun doesUserExist(username: String): Boolean {
        val result = playerAccountRepository.doesUserExist(username)
        result.onFailure {
            Logger.error(LogConfigAPIError) { "Failure on doesUserExist for username=$username: ${it.message}" }
        }
        val doesExist = requireNotNull(result.getOrThrow()) {
            "doesUserExist succeed but returned boolean is null"
        }
        return doesExist
    }
}

===== C:\Users\Sulivan\Desktop\Projects\DeadZone-Private-Server\src\main\kotlin\user\model\PlayerSession.kt =====
package dev.deadzone.user.model

/**
 * Representation of a player's authentication session.
 *
 * This session is issued during website login and included in API 13 (Authenticate)
 * and API 601 (SocialRefresh) responses.
 *
 * When the game client connects to the game socket using a `playerId`,
 * the server must verify that a valid session with a matching token exists.
 *
 * @property playerId The internal ID, used for linking session to [dev.deadzone.data.collection.PlayerAccount].
 * @property token A unique prove for authentication; currently not much used.
 * @property issuedAt Epoch millis when this session was created.
 * @property expiresAt Epoch millis when this session is no longer valid.
 */
data class PlayerSession(
    val playerId: String,
    val token: String,
    val issuedAt: Long,
    var expiresAt: Long,
    var lifetime: Long,
)

===== C:\Users\Sulivan\Desktop\Projects\DeadZone-Private-Server\src\main\kotlin\user\model\ServerMetadata.kt =====
package dev.deadzone.user.model

import kotlinx.serialization.Serializable

/**
 * Extra data for server. This is unused, but prepared just in case it is needed.
 *
 * May include cheat tracking or activity analysis here.
 */
@Serializable
data class ServerMetadata(
    val notes: String? = null,
    val flags: Map<String, Boolean> = emptyMap(),
    val extra: Map<String, String> = emptyMap(),
)

===== C:\Users\Sulivan\Desktop\Projects\DeadZone-Private-Server\src\main\kotlin\user\model\UserProfile.kt =====
package dev.deadzone.user.model

import dev.deadzone.core.data.AdminData
import io.ktor.util.date.getTimeMillis
import kotlinx.serialization.Serializable

/**
 * @property playerId reference to `playerId` in [dev.deadzone.data.collection.PlayerAccount]
 * @property email unused
 * @property displayName nickname or display name in-game
 * @property avatarUrl in-game avatar display and website
 * @property createdAt account creation date
 * @property lastLogin date for last login, may be same with last online in-game
 * @property countryCode country code
 * @property friends unused
 * @property enemies unused
 */
@Serializable
data class UserProfile(
    val playerId: String,
    val email: String = "",
    val displayName: String,
    val avatarUrl: String,
    val createdAt: Long = getTimeMillis(),
    val lastLogin: Long = getTimeMillis(),
    val countryCode: String? = null,
    val friends: Set<UserProfile> = emptySet(),
    val enemies: Set<UserProfile> = emptySet(),
) {
    companion object {
        fun admin(): UserProfile {
            return UserProfile(
                playerId = AdminData.PLAYER_ID,
                email = AdminData.EMAIL,
                displayName = AdminData.DISPLAY_NAME,
                avatarUrl = AdminData.AVATAR_URL,
                countryCode = AdminData.COUNTRY_CODE,
            )
        }

        fun default(username: String, pid: String): UserProfile {
            return UserProfile(
                playerId = pid,
                email = "dummyemail@email.com",
                displayName = username,
                avatarUrl = "https://picsum.photos/200",
            )
        }
    }
}

===== C:\Users\Sulivan\Desktop\Projects\DeadZone-Private-Server\src\main\kotlin\utils\AnyMapSerializer.kt =====
package dev.deadzone.utils

import kotlinx.serialization.KSerializer
import kotlinx.serialization.builtins.MapSerializer
import kotlinx.serialization.builtins.serializer
import kotlinx.serialization.descriptors.SerialDescriptor
import kotlinx.serialization.encoding.Decoder
import kotlinx.serialization.encoding.Encoder
import kotlinx.serialization.json.JsonArray
import kotlinx.serialization.json.JsonDecoder
import kotlinx.serialization.json.JsonElement
import kotlinx.serialization.json.JsonEncoder
import kotlinx.serialization.json.JsonNull
import kotlinx.serialization.json.JsonObject
import kotlinx.serialization.json.JsonPrimitive
import kotlinx.serialization.json.jsonObject

object AnyMapSerializer : KSerializer<Map<String, Any>> {
    override val descriptor: SerialDescriptor =
        MapSerializer(String.serializer(), JsonElement.serializer()).descriptor

    override fun serialize(encoder: Encoder, value: Map<String, Any>) {
        val jsonEncoder = encoder as? JsonEncoder
            ?: error("This serializer only works with JSON")
        val jsonObject = JsonObject(
            value.entries.associate { (k, v) -> k to toJsonElement(v) }
        )
        jsonEncoder.encodeJsonElement(jsonObject)
    }

    private fun toJsonElement(v: Any?): JsonElement {
        return when (v) {
            null -> JsonNull
            is JsonElement -> v
            is String -> JsonPrimitive(v)
            is Number -> JsonPrimitive(v)
            is Boolean -> JsonPrimitive(v)
            is Map<*, *> -> {
                val mapped = v.entries
                    .mapNotNull { (key, value) ->
                        (key as? String)?.let { it to toJsonElement(value) }
                    }
                    .toMap()
                JsonObject(mapped)
            }
            is Iterable<*> -> JsonArray(v.map { toJsonElement(it) })
            is Array<*> -> JsonArray(v.map { toJsonElement(it) })
            else -> JsonPrimitive(v.toString())
        }
    }

    override fun deserialize(decoder: Decoder): Map<String, Any> {
        val jsonDecoder = decoder as? JsonDecoder
            ?: error("This serializer only works with JSON")
        val obj = jsonDecoder.decodeJsonElement().jsonObject
        return obj.mapValues { it.value }
    }
}

===== C:\Users\Sulivan\Desktop\Projects\DeadZone-Private-Server\src\main\kotlin\utils\JsonUtils.kt =====
@file:Suppress("UNCHECKED_CAST")

package dev.deadzone.utils

import kotlinx.serialization.json.Json
import kotlinx.serialization.json.JsonArray
import kotlinx.serialization.json.JsonElement
import kotlinx.serialization.json.JsonNull
import kotlinx.serialization.json.JsonObject
import kotlinx.serialization.json.JsonPrimitive
import kotlinx.serialization.json.boolean
import kotlinx.serialization.json.booleanOrNull
import kotlinx.serialization.json.buildJsonArray
import kotlinx.serialization.json.buildJsonObject
import kotlinx.serialization.json.double
import kotlinx.serialization.json.doubleOrNull
import kotlinx.serialization.json.int
import kotlinx.serialization.json.intOrNull
import kotlinx.serialization.json.long
import kotlinx.serialization.json.longOrNull
import kotlin.collections.map
import kotlin.collections.mapValues

fun parseJsonToMap(json: String): Map<String, Any?> {
    return try {
        val parsed = Json.decodeFromString<JsonObject>(json)
        parsed.mapValues { (_, v) -> parseJsonElement(v) }
    } catch (_: Exception) {
        emptyMap()
    }
}

fun parseJsonElement(el: JsonElement): Any = when (el) {
    is JsonPrimitive -> {
        when {
            el.isString -> el.content
            el.booleanOrNull != null -> el.boolean
            el.intOrNull != null -> el.int
            el.longOrNull != null -> el.long
            el.doubleOrNull != null -> el.double
            else -> el.content
        }
    }

    is JsonObject -> el.mapValues { parseJsonElement(it.value) }
    is JsonArray -> el.map { parseJsonElement(it) }
}

fun Map<String, *>?.toJsonElement(): JsonObject = buildJsonObject {
    this@toJsonElement?.forEach { (key, value) ->
        put(key, value.toJsonValue())
    }
}

fun Any?.toJsonValue(): JsonElement = when (this) {
    null -> JsonNull
    is String -> JsonPrimitive(this)
    is Number -> JsonPrimitive(this)
    is Boolean -> JsonPrimitive(this)
    is Map<*, *> -> {
        (this as? Map<String, *>)?.toJsonElement()
            ?: error("Map keys must be strings: $this")
    }
    is Iterable<*> -> buildJsonArray { this@toJsonValue.forEach { add(it.toJsonValue()) } }
    else -> JsonPrimitive(this.toString()) // fallback ‚Äî stores as string
}

===== C:\Users\Sulivan\Desktop\Projects\DeadZone-Private-Server\src\main\kotlin\utils\Logger.kt =====
package dev.deadzone.utils

import dev.deadzone.utils.Logger.info
import io.ktor.server.routing.*
import io.ktor.util.date.*
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.launch
import kotlinx.serialization.Serializable
import java.io.File
import java.text.SimpleDateFormat

fun RoutingContext.logInput(txt: Any?, logFull: Boolean = false) {
    info(LogSource.API, logFull = logFull) { "Received [API ${call.parameters["path"]}]: $txt" }
}

fun RoutingContext.logOutput(txt: ByteArray?, logFull: Boolean = false) {
    info(LogSource.API, logFull = logFull) { "Sent [API ${call.parameters["path"]}]: ${txt?.decodeToString()}" }
}

/**
 * Custom logging utility object that supports multiple log levels, output targets, and log configurations.
 *
 * ### Usage
 *
 * There are four main styles of usage:
 *
 * **1)** Simple logging (direct message):
 *
 * ```kotlin
 * Logger.debug("Simple debug message")
 * Logger.info("Something happened")
 * ```
 *
 * **2)** Lazy-evaluated logging (only evaluated if level is enabled):
 *
 * ```kotlin
 * Logger.debug { "Expensive to compute: ${'$'}{expensiveCalculation()}" }
 * ```
 *
 * **3)** Structured logging using [LogConfig] presets:
 *
 * ```kotlin
 * Logger.info(LogConfigAPIToClient) { "API response sent to client" }
 * Logger.error(LogConfigSocketError) { "Socket connection failed" }
 * ```
 *
 * **4)** Override truncation behavior:
 *
 * ```kotin
 * Logger.info(LogConfigAPIToClient, forceLogFull = true) { "Very long message..." }
 * ```
 *
 * ### Features
 *
 * - Four log levels: [LogLevel.DEBUG], [LogLevel.INFO], [LogLevel.WARN], [LogLevel.ERROR]
 * - Output to:
 *     - Standard output via `[LogTarget.PRINT]`
 *     - Log files via `[LogTarget.FILE]`
 *     - WebSocket via `[LogTarget.CLIENT]`
 * - Message truncation unless `logFull = true`
 * - Timestamped messages (`HH:mm:ss`)
 *
 * ### Configuration
 *
 * - Set the global log level with `Logger.level`
 * - Use [LogConfig] presets for common sources/targets
 * - Extend [LogFile] and update `logFileMap` if needed
 *
 * ### Example custom config
 *
 * ```kotlin
 * val LogConfigCustom = LogConfig(
 *     src = LogSource.API,
 *     targets = setOf(LogTarget.PRINT, LogTarget.FILE(LogFile.API_SERVER_ERROR)),
 *     logFull = false
 * )
 * ```
 */
object Logger {
    private val logDir = File("logs").apply { mkdirs() }
    private val clientWriteError = File(logDir, "client_write_error-1.log")
    private val assetsError = File(logDir, "assets_error-1.log")
    private val apiServerError = File(logDir, "api_server_error-1.log")
    private val socketServerError = File(logDir, "socket_server_error-1.log")

    private val logFileMap = mapOf(
        LogFile.CLIENT_WRITE_ERROR to clientWriteError,
        LogFile.ASSETS_ERROR to assetsError,
        LogFile.API_SERVER_ERROR to apiServerError,
        LogFile.SOCKET_SERVER_ERROR to socketServerError,
    )

    var level: LogLevel = LogLevel.DEBUG
    private const val MAX_LOG_LENGTH = 500
    private const val MAX_LOG_FILE_SIZE = 1024 * 5 // 5 mb
    private const val MAX_LOG_ROTATES = 5
    private val dateFormatter = SimpleDateFormat("yyyy-MM-dd HH:mm:ss")

    private var broadcast: (suspend (logMsg: LogMessage) -> Unit)? = null
    fun init(broadcastFunc: suspend (LogMessage) -> Unit) {
        broadcast = broadcastFunc
    }
    suspend fun wslog(logMsg: LogMessage) {
        broadcast?.invoke(logMsg)
    }

    private fun log(
        src: LogSource = LogSource.SOCKET,
        targets: Set<LogTarget> = setOf(LogTarget.PRINT),
        level: LogLevel = LogLevel.DEBUG,
        msg: () -> String,
        logFull: Boolean = false
    ) {
        if (level < this.level) return

        val srcName = if (src != LogSource.ANY) src.name else ""
        var msgString = msg()

        if (msgString.length > MAX_LOG_LENGTH && !logFull) {
            msgString = msgString.take(MAX_LOG_LENGTH) + "... [truncated]"
        }

        val timestamp = dateFormatter.format(getTimeMillis())
        val logMessage = if (srcName.isEmpty()) {
            "[$timestamp] [${level.name}]: $msgString"
        } else {
            "[$srcName | $timestamp] [${level.name}]: $msgString"
        }

        targets.forEach { target ->
            when (target) {
                is LogTarget.PRINT -> {
                    println(logMessage)
                }

                is LogTarget.FILE -> {
                    val targetFile = logFileMap[target.file]
                    if (targetFile != null) {
                        if (targetFile.exists() && targetFile.length() > MAX_LOG_FILE_SIZE) {
                            rotateLogFile(targetFile)
                        }
                        targetFile.appendText("$logMessage\n")
                    } else {
                        println("Unknown log file target: ${target.file}")
                    }
                }

                is LogTarget.CLIENT -> {
                    val logMsg = LogMessage(level, logMessage)

                    CoroutineScope(Dispatchers.IO).launch {
                        wslog(logMsg)
                    }
                }
            }
        }
    }

    fun debug(msg: String) = debug { msg }
    fun debug(config: LogConfig, forceLogFull: Boolean? = null, msg: () -> String) {
        val logFull = forceLogFull ?: config.logFull
        debug(config.src, config.targets, logFull) { msg() }
    }

    fun debug(
        src: LogSource = LogSource.SOCKET,
        targets: Set<LogTarget> = setOf(LogTarget.PRINT),
        logFull: Boolean = false,
        msg: () -> String
    ) {
        if (level == LogLevel.NOTHING) return
        log(src, targets, LogLevel.DEBUG, msg, logFull)
    }

    fun info(msg: String) = info { msg }
    fun info(config: LogConfig, forceLogFull: Boolean? = null, msg: () -> String) {
        val logFull = forceLogFull ?: config.logFull
        info(config.src, config.targets, logFull) { msg() }
    }

    fun info(
        src: LogSource = LogSource.SOCKET,
        targets: Set<LogTarget> = setOf(LogTarget.PRINT),
        logFull: Boolean = false,
        msg: () -> String
    ) {
        if (level == LogLevel.NOTHING) return
        log(src, targets, LogLevel.INFO, msg, logFull)
    }

    fun warn(msg: String) = warn { msg }
    fun warn(config: LogConfig, forceLogFull: Boolean? = null, msg: () -> String) {
        val logFull = forceLogFull ?: config.logFull
        warn(config.src, config.targets, logFull) { msg() }
    }

    fun warn(
        src: LogSource = LogSource.SOCKET,
        targets: Set<LogTarget> = setOf(LogTarget.PRINT),
        logFull: Boolean = false,
        msg: () -> String
    ) {
        if (level == LogLevel.NOTHING) return
        log(src, targets, LogLevel.WARN, msg, logFull)
    }

    fun error(msg: String) = error { msg }
    fun error(config: LogConfig, forceLogFull: Boolean? = null, msg: () -> String) {
        val logFull = forceLogFull ?: config.logFull
        error(config.src, config.targets, logFull) { msg() }
    }

    fun error(
        src: LogSource = LogSource.SOCKET,
        targets: Set<LogTarget> = setOf(LogTarget.PRINT),
        logFull: Boolean = false,
        msg: () -> String
    ) {
        if (level == LogLevel.NOTHING) return
        log(src, targets, LogLevel.ERROR, msg, logFull)
    }

    fun rotateLogFile(file: File): File {
        val nameRegex = Regex("""(.+)-(\d+)\.log""")
        val match = nameRegex.matchEntire(file.name)
            ?: return file

        val (baseName, currentIndexStr) = match.destructured
        val currentIndex = currentIndexStr.toInt()
        val nextIndex = (currentIndex % MAX_LOG_ROTATES) + 1
        val newFileName = "$baseName-$nextIndex.log"
        val newFile = File(file.parentFile, newFileName)

        if (newFile.exists()) newFile.delete()

        return newFile
    }
}

enum class LogLevel() {
    NOTHING, DEBUG, INFO, WARN, ERROR
}

sealed class LogTarget {
    object PRINT : LogTarget()
    object CLIENT : LogTarget()
    data class FILE(val file: LogFile = LogFile.CLIENT_WRITE_ERROR) : LogTarget()
}

enum class LogFile {
    CLIENT_WRITE_ERROR, ASSETS_ERROR, API_SERVER_ERROR, SOCKET_SERVER_ERROR,
}

enum class LogSource {
    SOCKET, API, ANY
}

data class LogConfig(
    val src: LogSource,
    val targets: Set<LogTarget> = setOf(LogTarget.PRINT),
    val logFull: Boolean = false
)

val LogConfigWriteError = LogConfig(
    src = LogSource.API,
    targets = setOf(LogTarget.PRINT, LogTarget.FILE(LogFile.CLIENT_WRITE_ERROR), LogTarget.CLIENT),
    logFull = true
)

val LogConfigAPIError = LogConfig(
    src = LogSource.API,
    targets = setOf(LogTarget.PRINT, LogTarget.FILE(LogFile.API_SERVER_ERROR), LogTarget.CLIENT),
    logFull = true
)

val LogConfigSocketToClient = LogConfig(
    src = LogSource.SOCKET,
    targets = setOf(LogTarget.PRINT, LogTarget.FILE(LogFile.SOCKET_SERVER_ERROR), LogTarget.CLIENT),
    logFull = false
)

val LogConfigSocketError = LogConfig(
    src = LogSource.SOCKET,
    targets = setOf(LogTarget.PRINT, LogTarget.FILE(LogFile.SOCKET_SERVER_ERROR), LogTarget.CLIENT),
    logFull = true
)

val LogConfigAssetsError = LogConfig(
    src = LogSource.ANY,
    targets = setOf(LogTarget.PRINT, LogTarget.FILE(LogFile.ASSETS_ERROR), LogTarget.CLIENT),
    logFull = true
)

@Serializable
data class LogMessage(
    val level: LogLevel,
    val msg: String,
)

===== C:\Users\Sulivan\Desktop\Projects\DeadZone-Private-Server\src\main\kotlin\utils\Time.kt =====
package dev.deadzone.utils

import io.ktor.util.date.getTimeMillis

object Time {
    /**
     * Return the epoch millis in Double type.
     *
     * IMPORTANT! TLSDZ AS3 code uses msg.getNumber(n++) to get the serverTime
     * If we send the epoch in Long, this means getNumber will fail and will default to 0 instead
     * Using Double type is better because it won't fail.
     */
    fun now(): Double {
        return getTimeMillis().toDouble()
    }
}

===== C:\Users\Sulivan\Desktop\Projects\DeadZone-Private-Server\src\main\kotlin\utils\UUID.kt =====
package dev.deadzone.utils

import java.util.UUID

object UUID {
    /**
     * Returns an uppercased UUID from java.util.uuid.
     *
     * game used uppercase UUID so make sure to ignorecase when comparing or just use uppercase UUID too
     */
    fun new(): String {
        return UUID.randomUUID().toString().uppercase()
    }
}

===== C:\Users\Sulivan\Desktop\Projects\DeadZone-Private-Server\src\main\kotlin\websocket\WebsocketManager.kt =====
package dev.deadzone.websocket

import io.ktor.server.websocket.DefaultWebSocketServerSession
import io.ktor.websocket.Frame
import kotlinx.serialization.json.Json
import java.util.concurrent.ConcurrentHashMap

typealias ClientSessions = ConcurrentHashMap<String, DefaultWebSocketServerSession>

class WebsocketManager() {
    private val connectedDebugClients = ClientSessions()
    private var resourceLoadCompleted: Boolean = false

    fun addClient(clientId: String, session: DefaultWebSocketServerSession) {
        connectedDebugClients[clientId] = session
    }

    fun removeClient(clientId: String): Boolean {
        return connectedDebugClients.remove(clientId) != null
    }

    fun getAllClients(): ClientSessions {
        return connectedDebugClients
    }

    suspend fun onResourceLoadComplete() {
        resourceLoadCompleted = true
        connectedDebugClients.values.forEach {
            it.send(Frame.Text(Json.encodeToString(WsMessage(type = "ready", payload = null))))
        }
    }

    suspend fun handleMessage(session: DefaultWebSocketServerSession, message: WsMessage) {
        when (message.type) {
            "isready" -> {
                val response = if (resourceLoadCompleted) "ready" else "notready"
                session.send(Frame.Text(Json.encodeToString(WsMessage(type = response, payload = null))))
            }
        }
    }
}

===== C:\Users\Sulivan\Desktop\Projects\DeadZone-Private-Server\src\main\kotlin\websocket\WsMessage.kt =====
package dev.deadzone.websocket

import kotlinx.serialization.Serializable
import kotlinx.serialization.json.JsonElement

@Serializable
data class WsMessage(
    val type: String,
    val payload: JsonElement? = null,
)

